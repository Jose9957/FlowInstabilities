//
//  PROGRAM Newton_2D_simple.edp
//  computation of 2D base flow [ux,uy](x,y) using Newton iteration
//
//  This version of the program is a simple Newton solver which will work only
//  for the wake of a cylinder (or other simple objects), and is made voluntarily as simple as possible
//  for pedagogical reasons.
//
//  There is also a generic solver for 2D flow which allows much more options 
//  and is customizable through macros : see program Newton_2D.edp
//   
//
//  INPUT PARAMETERS (now managed with getARGV)
//   	Re
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, return exit code 201.
//
// This file by DF, 27 nov. 2020

		
cout << "$$$$ ENTERING Newton_2D_simple.edp " << endl << "$$" << endl; 
include "StabFem.idp"

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters		
//
real Re;
cout << "$$  Physical parameters " << endl;
Re = getARGV("-Re",0.);
cout << "Re = " << Re << endl;
real nu=1./Re; 


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files and declare FE-spaces		
//

mesh th=readmesh(ffdatadir+"mesh.msh");
		
//fespace Xh(th,P2,periodic=MESHPERIODICITY);       //f.e. space for veloecity components
//fespace Mh(th,P1,periodic=MESHPERIODICITY);      //f.e space for pressure
fespace XXMh(th,[P2,P2,P1]); // f.e. space for triplet [u,v,p]

XXMh [ux,uy,up];          ///////  -> unknown for the Navier-Stokes problem
XXMh [vx,vy,q];          ///////  -> test function for Navier-Stokes
XXMh [upx,upy,upp];   	 ///////  -> buffer vector  to store previous iteration (Newton) 
XXMh [dux,duy,dup]; 		 ///////  -> increment for the Newton iteration


// Baseflow
int testCB;
SFcheckfile("BaseFlow_guess.txt",testCB);
if (testCB<0)
		{
		SFwarning("No file BaseFlow_guess.txt : starting from arbitrary initial condition");
		[ux,uy,up] = [0,0,0]; //EOM
		} 
		else
		{
		cout << "$$ Reading file BaseFlow_guess.txt" << endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[];
};


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Some macros 	
//

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 
macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] 
// macro for rate-of-deformation tensor



//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem to be solved at each step of the iteration
//

problem NewtonIter([dux,duy,dup],[vx,vy,q]) =
    int2d(th)( 
			-2*nu*(D(du):D(v))
             + q*div(du)
             + div(v)*dup
			 - Conv(up,du,v)
             )
             +
    int2d(th)(
    		-2*nu*(D(up):D(v))
             + q*div(up)
             + div(v)*upp
             - .5*Conv(up,up,v)
             )
	+ on(1,dux=1.-upx,duy=0.-upy)
	+ on(2,dux=-upx,duy=-upy) 	                      
	+ on(6,duy=-upy);
    
//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//    
   
   
real res=1; // residual
int iter=0;
cout << "$$ Starting Newton algorithm for Re = " << Re << endl;	


while((res>1e-10)&(res<100)&(iter<=30))
  {
  iter++;	
  upx[]=ux[];      
  NewtonIter ;          
  ux[] = ux[]+dux[];
  real enerl2=dux[].l2;
  res=sqrt(int2d(th)(dux^2+duy^2)/th.area);
  cout << "$$ Iter = "<< iter << " Re = " << Re << " ; res = " << res << " ; res l2 = " << enerl2 << endl;
  };


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//    
   

// Saving data in BaseFlow.txt 
{
	ofstream file(ffdatadir+"BaseFlow.txt"); 
	file << ux[]; 
	file << endl  << Re << endl;
};	
	

// Generating the auxiliary file BaseFlow.ff2m
{
	fespace p1forff2m(th,P1);  
    p1forff2m vort;
	vort=-dy(ux)+dx(uy); /* vorticity */
	p1forff2m psi,test; 
	solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
		                    - int2d(th)(vort*test) + on(6,2,21,22,23,psi=0) + on(1,3,4,psi=y);
    /* NB this way to compute streamfunction will only work for a wake problem */
	ofstream file(ffdatadir+"BaseFlow.ff2m");
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
    file << "datatype BaseFlow datastoragemode ReP2P2P1.1 datadescriptors ux,uy,p,Re" << endl;
	file << "real* Re real* Fx P1 vort P1 psi real iter " << endl ;
	file << Re << endl;	
	real Fx = 2*(int1d(th,2,21,22,23)(up*N.x)
			  -nu*int1d(th,2,21,22,23)( (2*dx(ux)*N.x+(dx(uy)+dy(ux))*N.y)));
	file << Fx << endl;
	for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
}
// NB in more advanced solvers this part is expected to be done in a macro "SFWriteBaseFlow".
                  
cout << "$$$$ SUCESSFULLY LEAVING Newton_2D_simple.edp "  << endl; 
