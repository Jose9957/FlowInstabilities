/// 
/// file SF_Custom.idp
///
/// This file defines a few options needed for you case. This file may content :
/// * The case-dependent boundary conditions and postprocessing output macros
///   (BoundaryconditionsBaseFlow, SFWriteBaseFlow, SFWriteMode, NormalizeMode, etc...)
///   (NB all these macros have default values, so just put them here if they differ from the default ones!)
/// * Miscelanous other things possibly needed by your solvers.
///
/// This program is part of the StabFem project distributed under GNU licence.
///
/// The present case is for the CYLINDER case


//// NB : The macros defined in the sequel are only needed if you are using 
////      the generic solver Newton_2D.edp. They are not used in the simplified version Newton_2D_simple.edp





// HERE ARE SOME MACROS WHICH ARE USEFUL FOR POST-PROCESSING WITH A 2D FLOW OVER A BLUFF BODY

macro Trainee(u,symmetry)   
	(
	(1*(symmetry=="N")+2*(symmetry=="S"))
	*(
	int1d(th,2,21,22,23)(u#p*N.x)
	-nu*int1d(th,2,21,22,23)( (2*dx(u#x)*N.x+(dx(u#y)+dy(u#x))*N.y))
	)
	)
//EOM
	
macro Portance(u,symmetry)   
	(
	(1*(symmetry=="N")+2*(symmetry=="A"))
	*(
	int1d(th,2,21,22,23)(u#p*N.y)
	-nu*int1d(th,2,21,22,23)( (2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x))
	)
	)
//EOM

macro CalcLx(Lx,u)  /* mesure de la longueur de recirculation */
 { 		real ddx = 0.001;real Uav = -2e-10;real Uap=-1e-10;int ix;
			for(ix=1;ix<20000;ix++)
			{   
				Uap =u#x(0.5+ix*ddx,0);
				if(Uap*Uav<0){break;};
				Uav = Uap;	
			}
			real xav = 0.5+(ix-1)*ddx; 
			real xap = 0.5+ix*ddx;
			Lx = xav *(Uap)/(Uap-Uav) + xap *(-Uav)/(Uap-Uav);
 }	
//EOM  




macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
	fespace p1forff2m(th,P1);fespace p2forff2m(th,P2);    
    p1forff2m vort;
	vort=-dy(u#x)+dx(u#y); /* vorticity */
	p2forff2m psi,phi;
    solve Laplace(psi,phi, solver = CG) 
 	= int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi)) 
 	- int2d(th)(vort*phi) 
    + on(1,psi=y)+on(3,6,psi=y)+on(2,psi=0);  
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem " << endl;
    file << "datatype " << typeFlow << " datastoragemode Re"<< Pkstring << ".1 datadescriptors ux,uy,p,Re" << endl;
    file << "real* Re real* Fx " ; /* Declaration of metadata */
    file << "P1 vort P2 psi real iter "; /* Declaration of mesh-associated auxiliary data */
	string PostProcessBaseFlowDescription = " real Fy real Lx"; /* Declaration of scalar auxiliary data */ 
	file << PostProcessBaseFlowDescription << endl << endl ; 
    file << Re << endl;
    real DragMode = Trainee(u,symmetryBaseFlow);
	cout << "#    Drag force Fx =  " << DragMode << endl; 
    file << DragMode << endl ; 
	for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	for (int j=0;j<psi[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
	cout << "#### customisable output for WAKE OF A 2D BLUFF BODY : " << endl; 
    real LiftMode = Portance(u,symmetryBaseFlow);
	cout << "#    Lift force Fy =  " << LiftMode << endl; 
    file << LiftMode << endl ; 
    real Lx;
    CalcLx(Lx,u);
    cout << "#    Recirculation length Lx =  " << Lx << endl << endl; 
		file << Lx << endl;
	}
	};
//EOM
	

macro NormalizeMode(u)
{
complex norm =Portance(u,symmetry)/.5;
u#x[] = u#x[]/norm;
}
//EOM	
	

macro SFWriteMode(namefile,u,ev,shift,typeFlow,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1);fespace p2forff2m(th,P2);  
         p1forff2m<complex> vort1;  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "Eigenmode for a 2D-incompressible problem " << endl;
    	 file << "datatype " << typeFlow << " datastoragemode Cx" << Pkstring << " datadescriptors ux,uy,p" << endl;
    	 string descriptionFF;
    	 descriptionFF= "complex* lambda int* sym complex shift int iter P1c vort complex Fy complex Fx real AEnergy";
	     file << descriptionFF << endl << endl ; 
		 file << real(ev) << endl << imag(ev) << endl << sym << endl;
         file << real(shift) << endl << imag(shift) << endl << iter << endl << endl;
		 for (int j=0;j<vort1[].n ; j++) file << real(vort1[][j]) << endl << imag(vort1[][j]) << endl;
		 file << endl;
         complex LiftMode = Portance(u,symmetry); 
         complex DragMode = Trainee(u,symmetry);
         real AEnergyMode = sqrt(2*int2d(th)(abs(u#x)^2+abs(u#y)^2)); 
         file << real(LiftMode) << endl << imag(LiftMode) << endl;
         file << real(DragMode) << endl << imag(DragMode) << endl;
		 cout << "#### customisable output for a mode in the WAKE OF A 2D BLUFF BODY : " << endl;
         cout << "#   Fy = " << LiftMode << " exp( lambda t) + c.c. " << endl;
         cout << "#   Fx = " << DragMode << " exp( lambda t) + c.c. " << endl;  
		 cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
		 file << AEnergyMode << endl;
		 };
//EOM



// the next macro is to be redesigned and displaced in the HB solvers
macro SFWriteHBMode(namefile,u,ev,FourierOrder,symmetryHB,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1);fespace p2forff2m(th,P2);  
         p1forff2m<complex> vort1;  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "Eigenmode for a 2D-incompressible problem " << endl;
    	 file << "datatype HBmode datastoragemode CxP2P2P1.1 datadescriptors ux,uy,p,omega" << endl;
    	 string descriptionFF;
    	 descriptionFF= "real* Re complex* lambda int* HarmonicNumber int iter P1c vort complex Fy complex Fx real AEnergy";
	     file << descriptionFF << endl << endl ; 
		 file << Re  << endl << real(ev) << endl << imag(ev)  << endl << FourierOrder << endl << iter << endl << endl;
		 vort1=-dy(u#x)+dx(u#y);
		for (int j=0;j<vort1[].n ; j++) file << real(vort1[][j]) << endl << imag(vort1[][j]) << endl;
		file << endl;  
        complex LiftMode = Portance(u,symmetryHB); 
        complex DragMode = Trainee(u,symmetryHB);
        file << real(LiftMode) << endl << imag(LiftMode) << endl;
        file << real(DragMode) << endl << imag(DragMode) << endl;
        real AEnergyMode = sqrt(int2d(th)(abs(u#x)^2+abs(u#y)^2));  
        /* here factor 1 because 2 half domaines and time-average of cos^2 and sin^2 = 1/2. */ 
		cout << "#### customisable output for a HBMode in the WAKE OF A 2D BLUFF BODY : " << endl;
		cout << "#   Fy = " << real(LiftMode) << " * cos(" << FourierOrder << " omega t) + " 
                    << -imag(LiftMode) << " * sin( " << FourierOrder << " omega t)  "  << endl; 
        cout << "#   Fx = " << real(DragMode) << " * cos(" << FourierOrder << " omega t) + " 
                    << -imag(DragMode) << " * sin( " << FourierOrder << " omega t)  "  << endl; 
		cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
		file << AEnergyMode << endl << endl;
		};
//EOM	

macro SFWriteMesh(filename,TH,typemesh)
{
     ofstream fileFF(filename);
     fileFF << "### Data generated by Freefem++ ; " << endl;
     fileFF << "Mesh (generated by generic macro)" << endl;
     fileFF << "datatype Mesh meshtype 2D generationmode " << typemesh << endl;
     fileFF << "real* H P1 TriangleSize " << endl;
     fileFF << int1d(th,1)(1) << endl; /* this is the width if the numerical domain */ 
     fespace femp1N(TH,P1);
     femp1N delta = hTriangle;
     for (int j=0;j<delta[].n ; j++) fileFF << delta[][j] << endl;     
};       
//EOM

