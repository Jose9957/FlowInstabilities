//
//  PROGRAM Newton_2D.edp
//  computation of 2D base flow [ux,uy](x,y)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re
//      Omegax
//      symmetry ('S','A' or 'N')
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, return exit code 201.
//
//
// INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
// REwriten on october 2 2017 with macros.
// Cleaned in july 2019 for StabFem 3.0

		cout << "$$$$ ENTERING Newton_2D.edp " << endl << "$$" << endl; 
//		include "SF_Geom.edp"; // to be removed soon
		include "StabFem.idp";


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters		
//
	    
real Ra,Pr,Qmag,Raans,Prans;

	cout << " Enter Rayleigh Number >> ";
	cin >> Ra;
	cout << Ra << endl;

	cout << " Enter Prandtl Number  >> ";
	cin >> Pr;
	cout << Pr << endl;
	
	cout << " Enter Magnetic Number Qmag  >> ";
	cin >> Qmag;
	cout << Qmag << endl;
	
	

	string symmetryBaseFlow = "N";
//	cout << "$$ Enter symmetry property of base flow  ? ('N','S', or 'A') >> ";
//    cin >> symmetryBaseFlow;
//    cout << symmetryBaseFlow << endl;



//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//


		mesh th=readmesh(ffdatadir+"mesh.msh");
		
        fespace Xh(th,P2);       //f.e. space for veloecity components
		fespace Mh(th,P1);      //f.e space for pressure
		fespace XXMMh(th,[P2,P2,P1,P1]); // f.e. space for triplet [u,v,p]

		macro def(u)[u#x,u#y,u#p,u#T]//EOF

		XXMMh def(u);          ///////  -> unknown for the Navier-Stokes problem
		XXMMh def(v);          ///////  -> test function for Navier-Stokes
		XXMMh def(up);   	 ///////  -> buffer vector  to store previous iteration (Newton) 
		XXMMh def(du); 		 ///////  -> increment for the Newton iteration


// Baseflow
		int testCB;
		SFcheckfile("BaseFlow_guess.txt",testCB);
    	if (testCB<0)
		{
		SFwarning("No file BaseFlow_guess.txt : starting from arbitrary initial condition");
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your SF_Custom.idp
		macro DefaultGuessForNewton
		def(u) = [0,0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
		else
		{
		cout << "$$ Reading file BaseFlow_guess.txt" << endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[];
//		file >> Raans;
		cout << "$$ Rayleigh of guess field : " << Raans << endl; 
		};

		plot(uT,wait=1);


	cout << "$$ Starting Newton algorithm for Ra = " << Ra << endl;	
	


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//

//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your SF_Custom.idp file.
//
	
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO	
	
IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,u,v)
	           on(21,du#x=-u#x,du#y=-u#y,du#T = 1.-u#T) 
	         + on(22,du#x=-u#x,du#y=-u#y,du#T = 0.-u#T)
	         + on(2,du#x=-u#x,du#y=-u#y)
             + on(5,du#x=-u#x)    
//EOM
ENDIFMACRO


IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(5,6,2,21,22,23,psi=0);
//EOM
ENDIFMACRO     

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1);  
    p1forff2m vort;
	vort=-dy(u#x)+dx(u#y); /* vorticity */
	p1forff2m psi,test; 
	CalcPsi(psi,vort,test);
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-Boussinesq problem (using GENERIC MACRO)" << endl;
    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1P1.2 datadescriptors ux,uy,p,T,Ra,Pr,Qmag" << endl;
	file << "real* Ra real* Pr real* Qmag real HeatFlux real Umax P1 vort P1 psi real iter " << endl ;
	file << Ra << endl << Pr << endl << Qmag << endl;
	real HeatFlux = -int1d(th,21)(dy(u#T))/int1d(th,21)(1);	
	file << HeatFlux << endl;
	Mh normu = sqrt(abs(u#x)^2+abs(u#y)^2);
	real Umax = normu[].max+1e-12;
	file << Umax << endl << endl;
	cout << ">>> Heat flux for this base flow : " << HeatFlux << endl;
			for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
	};
	}
//EOM
ENDIFMACRO
	    





/////////////////////////////////////////////////////////////////////////////////
/////// macro to define some useful operators

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 

macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
            + ((ua#x*dx(ub#T)+ua#y*dy(ub#T))+(ub#x*dx(ua#T)+ub#y*dy(ua#T)))*v#T /* This is the convection of temperature */
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//



real eps = 1e-12;
// definition of linear system to be solved at each step of the iteration
problem NewtonIter(def(du),def(v)) =
    int2d(th)( 
			-2*Pr*(D(du):D(v))
			-(dx(duT)*dx(vT)+dy(duT)*dy(vT))
             + vp*div(du)
             + div(v)*dup
				-Conv(up,du,v)
				+Pr*Ra*duT*vy
				-Qmag*(dux*vx+duy*vy)
				+eps*dup*vp			
             )
             +
    int2d(th)(
    		-2*Pr*(D(up):D(v))
    		-(dx(upT)*dx(vT)+dy(upT)*dy(vT))
             + vp*div(up)
             + div(v)*upp
             -.5*Conv(up,up,v)
             +Pr*Ra*upT*vy
             -Qmag*(upx*vx+upy*vy)
             +eps*up*vp
             )
	+  BoundaryconditionsBaseFlow(du,up,v);     
    
//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//    
   
   
// parameters for Newton loop            
    real tolerance=2e-12;
    int Nitermax=30;
    real res=10;	
    int iter=0;

        
// Newton loop
        while((res>tolerance)&(res<50)&(iter<=Nitermax))
        {
	    upx[]=ux[];      
        NewtonIter ;          
        ux[] = ux[]+dux[];
		real enerl2=dux[].l2;
		res=sqrt(int2d(th)(dux^2+duy^2)/th.area);
	    cout << "$$ Iter = "<< iter+1 << "   Ra = " << Ra << " ; res = " << res << " ; res l2 = " << enerl2 << endl;
        iter++;
		plot(uT,wait=1);
	  } ;

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//    
   

// sortie des r?sultats 

		if((res>50)||(iter>Nitermax))
		{
			SFerror("$$ NEWTON ITERATION FAILED");
			cout << "$$ Leaving FreeFem++ with error code 201" << endl;
			exit(201);
		}
		else
		
		{

		plot(uT,wait=1);

		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << ux[]; 
		  file << endl  << Ra << endl  << Pr << endl << Qmag << endl;
		  }; 
          exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
         

          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver

    
		};
          
cout << "$$$$ SUCESSFULLY LEAVING Newton_2D_Boussinesq.edp "  << endl; 
