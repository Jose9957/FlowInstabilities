//
//  PROGRAM LinearForced2D.edp
//  computation of a linear harmonically forced problem for a single or multiple choices of omega
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	typecalc -> 'single', 'range', or 'array'
//	 	'single' -> omega (real) (in this case a structure field is produced)
//		'range' -> omegamin, omegastep, omegamax (real)
//		'array' -> user-defined range (complex) (N, omega1, sigma1, omega2, sigma2, ....)
//
//	INPUT FILES :
//		BaseFlow.txt		-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//
//  OUTPUT FILES :
//		Impedance.ff2m -> formatted file, structure defined in macro
//		Impedance_Chi##_Re###.txt 
//
// 	ERROR MANAGEMENT : 
//
//  First version : sometime around 2014 ; Redesigned and incorporated in the project in september 2018.


include "SF_Geom.edp";
include "StabFem.idp";

int NNN = 10000;	
string typecalc; 
int Nomega;
complex[int] omegaarray(NNN);
	
cout << "$$ ENTERING Function LinearForced2D_ALE.edp" << endl;
cout << "$$ Selection of parameters : " << endl;
cout << "$$ Enter type  (single, range, array)  >> " ;
cin >> typecalc;
cout << typecalc << endl;
if(typecalc=="single")
	{
		cout << "$$ Enter omega  >> " ;
		cin >> omegaarray(0)  ;
		cout <<  omegaarray(0) << endl;	
		Nomega = 1;
	}
	else if(typecalc=="range")
	{
		real omegamin,omegamax,omegastep;
		cout << "$$ Enter omegamin, omegastep,  omegamax  >> " ;
		cin >> omegamin >> omegastep >> omegamax ;
		cout <<  omegamin << " , " << omegastep << " , " << omegamax << endl;
		Nomega = (omegamax-omegamin)/omegastep+1;
		for(int kk=0;kk<Nomega;kk++){omegaarray(kk) = omegamin+kk*omegastep;};
	}
	else if(typecalc=="array")
	{
		real omegar,omegai;
		cout << "$$ Enter Number of omega values N >> " ;
		cin >> Nomega;
		cout << Nomega << endl;
		cout << "$$ Enter successively omega1, sigma1, omega2, sigma2, (...) omegaN, sigmaN  >> " ;
		for(int kk=0;kk<Nomega;kk++)
		{
			cin >> omegar >> omegai; 
			omegaarray(kk) = omegar+1i*omegai;
		};
		cout << endl << "$$ (successfully read " << Nomega << " complex values " << endl;
	}
	else
	{
		cout << " Error : typecalc = " << typecalc << " is not a valid value !" << endl;
		exit(10); 
	};


// NUMERICAL PARAMETERS
// Numerical parameters

string Normalize = getARGV("-Normalize","Y");
real AddedSTIFFNESS =getARGV("-AS",0.);

//int symm = getARGV("-Symmetry",0);
//string symmetryF;
//if (symm==1) {symmetryF="S";} else if (symm==-1){symmetryF="A";} else {symmetryF="N";};
//cout << "$$ Symmetry property   : " << symm << " ; " << symmetryF << endl;

string symmetryF=getARGV("-Symmetry","N");
cout << "$$ Symmetry property   : " << symmetryF << endl;

cout << endl << " Numerical parameters :" << endl;
cout << "Normalization : " << Normalize << endl;

	if ((Normalize!="V")&&(Normalize!="Y"))
	{
		cout << "Error : Normalization not recognized"<< endl;
		exit(1);
	};
	
	real TGV = 1e30;
	real TGVCL = 1e20;


	mesh th=readmesh(ffdatadir+"mesh.msh");
 	fespace p2xp2xp1(th,[P2,P2,P1]);
 	fespace p2(th,P2);
	fespace p1(th,P1);	
	p2xp2xp1 [Ubx,Uby,Ubp];
    p2xp2xp1<complex> [ux,uy,up],[vx,vy,vp];
    p2xp2xp1 [urr,uyr,pr],[uri,uyi,pii];
    
	int m=0; 
	real Re;
//	real epsilonPQ = 0*1e-20; // terme de desingularisation
	complex omega;

		int NdimBaseFlow;


		{
        ifstream file(ffdatadir+"BaseFlow.txt");
        file >> Ubx[];
   		file >> Re;
		}

      
	

//	{
//	ifstream cbin(ffdatadir+"BaseFlow.txt");
//	cbin >> uxp[];
//	cbin >> Re;
//	};
//	cout << " Lecture BaseFlow : Re = " << Re << endl;

	real nu=1/Re; // NB SFGeom parameters should be defined in SF_Geom.edp
	cout << "nu = " << nu << endl;
	
	complex Y,V,A; 
	


IFMACRO(!ForcedLinearStatisticsINIT)	
macro ForcedLinearStatisticsINIT(namefile)
{			
    ofstream fileTXT(namefile+".txt"); /* this is only to clean the file if exists */ 
    ofstream file(namefile+".ff2m");
    file << "### Data generated by Freefem++ ; " << endl;
    file << "Impedance of a 2D device (generic macro)" << endl;
	file << "datatype forcedlinear datastoragemode columns datadescriptors ind,omega_r,omega_i,Z_r,Z_i" << endl;
}
//EOM
ENDIFMACRO



IFMACRO(!Portance)
macro Portance(u,symmetry)   
	(
	(1*(symmetry=="N")+2*(symmetry=="A"))
	*(
	int1d(th,2,21,22,23)(u#p*N.y)
	-nu*int1d(th,2,21,22,23)( (2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x))
	)
	)
//EOM
ENDIFMACRO

macro PortanceALE(U,xi,symmetry)
	(
	(1*(symmetry=="N")+2*(symmetry=="A"))
	*(
	nu*int1d(th,2,21,22,23)(((Grad(U)*Grad(xi)+tGrad(xi)*tGrad(U))*[N.x,N.y])'*[0,1])
	)
	)
//EOM

IFMACRO(!AddedStiffness)
macro AddedStiffness(Ub,symmetryBF)   
	(
	(1*(symmetryBF=="N")+2*(symmetryBF=="S"))
	*(
	int1d(th,2,21,22,23)(dy(Ub#p)*N.y)
	-nu*int1d(th,2,21,22,23)( (2*dyy(Ub#y)*N.y+(dxy(Ub#y)+dyy(Ub#x))*N.x) )
	)
	)
//EOM
ENDIFMACRO

IFMACRO(!ForcedLinearStatistics)
macro ForcedLinearStatistics(namefile)
{
	complex Fy = Portance(u,symmetryF)+Y*PortanceALE(Ub,xi,symmetryF);
	complex Imp = -Fy/V; 
	/* NB : sign is because impedance is with force exerted on fluid ; see Sabino et al */
	ofstream fileforces(namefile+".txt",append);
	fileforces << ind << " " << real(omega) << " " << imag(omega) << " " << real(Imp) << " " << imag(Imp) << endl;		
}
//EOM	
ENDIFMACRO	




IFMACRO(!SFWriteForced)
macro SFWriteForced(namefile,u,ev)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
   		 complex reltoabs;
    	 p1forff2m<complex> uxa,uya,ppa,vort1;  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "FORCED LINEAR RESPONSE for a 2D incompressible problem " << endl;
    	 file << "datatype " << " ForcedFlow " << " datastoragemode CxP2P2P1 datadescriptors ux,uy,p" << endl;
	     file << "real* Re complex* Lambda complex* Fy complex Z complex Fyxi P1c vort " ;
	     file << " P1c uxa P1c uya P1c pa" << endl << endl ;
		 file << Re  << endl << real(ev) << endl << imag(ev) << endl << endl;
		 complex Fy = Portance(u,symmetryF);
		 complex Fyxi = Y*PortanceALE(Ub,xi,symmetryF);
		 complex ZZ = -(Fy+Fyxi)/V; /* see remark above */
		 cout << "#  Fy = " << Fy+Fyxi << " ;  Z = " << ZZ << endl;
		 file << real(Fy+Fyxi) << endl << imag(Fy+Fyxi) << endl;	
		 file << real(ZZ) << endl << imag(ZZ) << endl;	
		 file << real(Fyxi) << endl << imag(Fyxi) << endl; 
		 vort1=dy(u#x)-dx(u#y);
		for (int j=0;j<uxa[].n ; j++) file << real(vort1[][j]) << endl << imag(vort1[][j]) << endl;
		uxa=u#x-(xix*dx(Ubx)+xiy*dy(Ubx));
		uya=u#y-(xix*dx(Uby)+xiy*dy(Uby));
		ppa=u#p-(xix*dx(Ubp)+xiy*dy(Ubp));
		for (int j=0;j<uxa[].n ; j++) file << real(uxa[][j]) << endl << imag(uxa[][j]) << endl;
		for (int j=0;j<uxa[].n ; j++) file << real(uya[][j]) << endl << imag(uya[][j]) << endl;
		for (int j=0;j<uxa[].n ; j++) file << real(ppa[][j]) << endl << imag(ppa[][j]) << endl;
		};
//EOM	
ENDIFMACRO
	
	
	
string namefile = ffdatadir+"LinearForcedStatistics";
ForcedLinearStatisticsINIT(namefile);	


////// A FEW MACROS FOR DIFFERENTIAL OPERATORS	
	
	macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 
	macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
	macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor
	macro Grad(u) [[dx(u#x),dy(u#x)], [dx(u#y),dy(u#y)]]//EOM	
	macro tGrad(u) [[dx(u#x),dx(u#y)], [dy(u#x),dy(u#y)]]//EOM
	macro vect(u)   [u#x,u#y] //EOM
	
	real eps = 1e-20;
	



/// CONSTRUCTION OF ELEMENTARY ALE DISPLACEMENT FIELD

fespace XI(th,[P2,P2]);
XI<complex> [xix,xiy],[xitx,xity];
string MD = getARGV("-ALEOP","laplacian");

// Determination of mesh deformation field corresponding to static displacement of body (Y=1) 
problem Vxixi([xix,xiy],[xitx,xity]) = 
             int2d(th)(  (5*div(xi)*div(xit) + (D(xi):D(xit)))*(MD=="elasticity") )
	       + int2d(th)( (Grad(xi):Grad(xit))*(MD=="laplacian") )
	       + int2d(th)( (dx(xix)*dx(xitx)+dy(xix)*dy(xitx)+dx(xiy)*dx(xity)+dy(xiy)*dy(xity))*(MD=="laplacian2") )		 
	       + int2d(th)( ((Grad(xi):Grad(xit))+10*(xix*xitx+xiy*xity))*(MD=="relaxed") )		
           // BoundaryConditionsXi
           + on(2,21,22,23, xix=0,xiy=1) 
           + int1d(th,6)(xix*xitx*TGV)
           + int1d(th,1,4,3,13)(xix*xitx*TGV+xiy*xity*TGV)
	       ;
Vxixi;

plot([xix,xiy],value=1,wait=0);
plot(xix,value=1,wait=0,fill=1);
plot(xiy,value=1,wait=0,fill=1);


/// Definition of linear problem to be solved at each step

macro ALEcoupling(U,xi,v,Y) 
	(	
			-	  int2d(th)(Y*((((Grad(U)*Grad(xi))*vect(U))'*vect(v))
				+ nu*((Grad(U)*Grad(xi)+tGrad(xi)*tGrad(U) ):Grad(v))	
				+ 2.*nu*(D(U):(Grad(v)*Grad(xi)))								
				- U#p*(Grad(v):tGrad(xi))						
				+ v#p*(Grad(U):tGrad(xi))
		 	   ))
		+ int2d(th)(Y*(  ( ( Grad(U)*vect(U) )'*vect(v) )*div(xi)
				+2.*nu*(D(U):Grad(v))*div(xi)
				- U#p*div(v)*div(xi) 
				+ v#p*div(U)*div(xi) ) 
		 	   )		
	)
//EOM

macro ALEcouplingINST(U,xi,v,V) 
	(	
		/*	-int2d(th)(V*((Grad(U)*vect(v))'*vect(xi))) */
		-int2d(th)(V*(Grad(U)*vect(xi))'*vect(v))
	)
//EOM

	IFMACRO(!BoundaryConditionsForcedProblem)	
macro BoundaryConditionsForcedProblem(u,v)
/* 	  
  	  int1d(th,2,21,22,23)(TGVCL*(u#x*v#x+u#y*v#y))	
    + int1d(th,2,21,22,23)(-V*v#y*TGVCL*(formulation=="A"))
    + int1d(th,2,21,22,23)(-Y*(v#y*dy(Ubx)+v#x*dy(Ubx))*TGVCL*(Frame=="A"))
    + int1d(th,1,4)(TGVCL*(u#x*v#x+u#y*v#y))  
	+ int1d(th,1,4) (V*v#y*TGVCL*(formulation=="R"))	
	+ int1d(th,1,4)(Y*(v#y*dy(Ubx)+v#x*dy(Ubx))*TGVCL*(Frame=="R"))
*/	
        on(1,4,u#x=0)
      + on(1,4,u#y=0)
      + on(2,21,22,23,u#x=0)
      + on(2,21,22,23,u#y=V)
      + on(6,u#x=0)
	//EOM 
ENDIFMACRO

	problem ForcedLinear([ux,uy,up],[vx,vy,vp]) =
   int2d(th)( 
   			   2*nu*(D(u):D(v))
             + up*vp*(eps) 
             - up*div(v)
             + div(u)*vp
             - 1i*omega*(ux*vx+uy*vy)
             + Conv(u,Ub,v)
             )
    + ALEcoupling(Ub,xi,v,Y) 
    + ALEcouplingINST(Ub,xi,v,V)        
	+ BoundaryConditionsForcedProblem(u,v)
	; 
	



///////// Loop over omega



for(int ind = 0; ind<Nomega; ind++)
{
	omega  = omegaarray(ind);

	cout << "$$ Calcul d'un probleme lineaire force 2D ; Re    = " << Re << " ;  omega = " << omega << endl;	
		
	if (Normalize=="V")
	{
		V = 1;
		A = -1i*omega;
		Y = 1/(-1i*omega+1e-30);
	}
	else if (Normalize=="Y")
	{
		Y = 1;
		V = -1i*omega;
	 	A = -omega^2;
	};
	
	 
	real TGV = 1e30;
	real TGVCL = 1e20;

	ForcedLinear;
	ForcedLinearStatistics(namefile);
	
//	IFMACRO(FREEFEMPLOTS,YES)
	p1<complex> uxA = ux-Y*dy(Ubx);
	p1<complex> uyA = uy-Y*dy(Uby);
	plot(ux,cmm="Forced flow for omega = "+omega+" : ux rel",wait=1,fill=1,value=1);
	plot(uxA,cmm="Forced flow for omega = "+omega+" : ux abs",wait=1,fill=1,value=1);
	
	plot(uy,cmm="Forced flow for omega = "+omega+" : uy rel",wait=1,fill=1,value=1);
	plot(uyA,cmm="Forced flow for omega = "+omega+" : uy abs",wait=1,fill=1,value=1);
//	ENDIFMACRO
	
	
	if(Nomega==1)
	{
    ofstream file(ffdatadir+"ForcedFlow.txt");
  	file << ux[] ;	
   	file << endl << endl << imag(omega) << "   " << -real(omega)  << endl;
	SFWriteForced(ffdatadir+"ForcedFlow.ff2m",u,1i*omega)
	


	complex Fy = Portance(u,symmetryF)+Y*PortanceALE(Ub,xi,symmetryF);
	cout << "# Fy =  " << Fy << endl; 
	
	complex Fyu1 = Portance(u,symmetryF);
	cout << "# Fy_uale =  " << Fyu1 << endl; 
	

	complex FyALE = Y*PortanceALE(Ub,xi,symmetryF);
	cout << "# NB   Fy_xi =  " << FyALE << endl; 

	

	
	};

};
// end Loop



cout << "$$$$ LEAVING LoopImpedance.edp " << endl << "$$" << endl; 
	
	
