//
//  PROGRAM Stab_2D_Comp.edp
//	
//	Performs the linear stability analysis of a 2D compressible subsonic flow
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma, shift(Re,im) , Symmetry, Type, nev 
//
//   this solver will use Arnoldi
//
//	INPUT FILES :
//		BaseFlow.txt	-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//
//  	Eigenmode##.txt   (txt format for FreeFem)
//      Eigenmode##.ff2m  (ff2m format for stabfem)
//
// in all modes :
//		Spectrum.txt -> All computed Eigenvalues
//
// 	ERROR MANAGEMENT : 
//      if Arnoldi method fails, TODO: Not handled yet
//
// Updated in January 2020. J.S

///////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUDE FILES
include "StabFem.idp";


IFMACRO(!def) 
/* normally useless */
	macro def(i) [i,i2,i3,i4,i5]// EOM                         
	macro init(i)[i,i2,i3,i4,i5]// EOM                    
	macro defS(i) i// EOM                         
	macro initS(i) i// EOM   
ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters		
//

/////////////////////////////////////////////////////////////
// Physical parameters
real gamma=getARGV("-gamma",1.4); 
real Pr=getARGV("-Pr",0.7);
func Pk = [P2,P2,P1,P1,P1];  // finite element space for PETSc
real Re,Reans,Ma,Maans,Omegax,Omegaxans;
real nu;
string symmetry;
string iadjoint;
real shiftr, shifti;
complex shiftOP, sigma;
int nev, ncv; // number of eigenvalues, cardinal of Krylov Basis and number of eigenvalues computed
string modeEig;
string namefile, namefileMeth;

// INPUT  
cout << " Enter Reynolds :   " << endl; cin  >> Re;	nu=1.0/Re;
cout << " Enter Mach :   " << endl; cin  >> Ma;
cout << " Enter SHIFT (re,im) :   " << endl; cin  >> shiftr >> shifti;
cout << " Symmetry properties ?? (A, S  or N)" << endl; cin >> symmetry;
cout << " Direct (D), Adjoint (A), D&A+sensitivity (S) ?" << endl; cin >> iadjoint;
cout << " Enter nev ? (will use simple shift-invert if nev = 1)" << endl; cin >> nev;

complex shift = 1i*shifti+shiftr;

// OUTPUT
cout << " ### PARAMETERS SELECTED : " << endl;
cout << " Re = " << Re << endl;
cout << " Ma = " << Ma << endl;
cout << " Shift = " << shift << endl; 
cout << " Symmetry = " << symmetry << endl; 
cout << " Method = " << iadjoint << endl; 
cout << " gamma = " << gamma << endl;
cout << " Pr = " << Pr << endl;

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
// 

/////////////////////MESH//////////////////////////////////////////
mesh th;
th=readmesh(ffdatadir+"mesh.msh"); // global mesh read on rank 0
///////////////////////////////////////////////////////////////////

/////////////////////FE-SPACE//////////////////////////////////////////
fespace XXxxxH(th,[P2,P2,P1,P1,P1]); /// 
fespace XH(th,P2);             ////// f.e. space for vel.
fespace xh(th,P1);            ////// f.e. space for pressure

macro defU(u,p,T,rho)[u#x,u#y,p,T,rho]//EOF
macro defUU(u)[u#x,u#y,u#p,u#T,u#rho]//EOF
XXxxxH defUU(Ub);
XXxxxH<complex> defU(u,up,uT,urho);

//////////////////////////// INITIAL CONDITIONS ///////////////////////////////
int testCB;
SFcheckfile("BaseFlow.txt",testCB);
if (testCB==-1)
{
	if(mpirank==0) cout << "$$ No file BaseFlow.txt : starting from arbitrary initial condition" << endl;
	IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefied in your Macro_StabFem.idp
	macro DefaultGuessForNewton
		defUU(Ub) = [1.0,0.0,1.0,1.0,1.0]; //EOM
	ENDIFMACRO
	DefaultGuessForNewton;
} 
else
{
    ifstream fileGuess(ffdatadir + "BaseFlow.txt");
    fileGuess >> Ubx[];
    fileGuess >> Reans;
	fileGuess >> Maans;
	fileGuess >> Omegaxans;
	if(mpirank==0) cout << "$$ Re of guess field : " << Reans << endl; 
	if(mpirank==0) cout << "$$ Ma of guess field : " << Maans << endl; 
	if(mpirank==0) cout << "$$ Omegax of guess field : " << Omegaxans << endl; 
};

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//
//

IFMACRO(!SFWriteMode)
macro SFWriteMode(namefile,u,ev,shift,typeFlow,iter)
{
	ofstream file(namefile);
	fespace p1forff2m(th,P1); 
	p1forff2m xx,yy;
	xx=x;
	yy=y;
    p1forff2m<complex> ux1,uy1,pp1,vort1,rho1,T1,divergence;
	file << "### Data generated by Freefem++ ; " << endl;
	file << "Eigenmode for a 2D-compressible problem " << endl;
	file << "datatype " << typeFlow <<" datastoragemode CxP2P2P1P1P1.4 datadescriptors ux,uy,p,T,rho,Re,Ma,lambdar,lambdai" << endl;
	string descriptionFF="real* Re real* Ma complex* lambda complex shift int iter P1c vort P1c divergence "; 
	file << descriptionFF << endl << endl ; 
	file << Re  << endl << Ma << endl << real(ev) << " " << imag(ev) << " " << real(shift) << " " << imag(shift) << " " << iter << endl << endl;
	vort1=dy(u#x)-dx(u#y); 
	divergence=dx(u#x)+dy(u#y); 	
	for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
    for (int j=0;j<ux1[].n ; j++) file << real(divergence[][j]) << " " << imag(divergence[][j]) << endl;
	};
//EOM	
ENDIFMACRO


IFMACRO(!NormalizeMode)
macro NormalizeMode(u)
	{
		real NORM = sqrt(int2d(th)(abs(u#x)^2+abs(u#y)^2));
		u#x[] = u#x[]/NORM;
	}
//EOM
ENDIFMACRO


// END Added From SLEPC
///////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// MARCRO ///////////////////////////  
macro div(u) ((dx(u#x)+dy(u#y)))   //EOM
macro ugradf(u,f) ((u#x*dx(f)+u#y*dy(f)))    //
macro termnonlinear(u,v,w) ((w#x*(u#x*dx(v#x)+u#y*dy(v#x))+w#y*(u#x*dx(v#y)+u#y*dy(v#y)))) //
macro Grad(u) [[dx(u#x),dx(u#y)],[dy(u#x),dy(u#y)]]//EOM
macro Strain(u)[[dx(u#x),0.5*(dx(u#y)+dy(u#x))],[0.5*(dx(u#y)+dy(u#x)),dy(u#y)]]//EOM
macro gradgrad(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM
///////////////////////////////////////////////////////////////////////////////////////////////
///////////  Load baseflow   ////////////////////////////////////////////////////

func real AmpSponge(real M, real xinf, real xsup, real yinfsup)
  
{
  if(M>0)
    return abs(1.+1./M)*(x>xsup)*(alpha*(x-xsup))+abs(1.-1./M)*(x<xinf)*(alpha*(xinf-x))+abs(1./M)*(abs(y)>yinfsup)*(alpha*(abs(y)-yinfsup));
  else
    return 0.0;
}

XH AMPFORCE=AmpSponge(Ma,xinfm,xinfv,yinf);       
/////////////////////////////////////////////////////////////////////////////////
//////// varf for generalized eigenvalue problem: 

////////////////////////////////////////////////////////////////////////////////////

varf jacobian(defUU(du),defUU(us))=-intN(th)
			  (
			  usrho*(durho*div(Ub)+Ubrho*div(du)+ugradf(Ub,durho)+ugradf(du,Ubrho)) 
			  //mass equation
			  -dup/(gamma*Ma^2)*div(us)+2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))
			  +Ubrho*termnonlinear(du,Ub,us)+durho*termnonlinear(Ub,Ub,us)+Ubrho*termnonlinear(Ub,du,us)
			  //momentum
			  +usT*(durho*ugradf(Ub,UbT)+Ubrho*ugradf(Ub,duT)+Ubrho*ugradf(du,UbT)
			     +(gamma-1)*(div(Ub)*dup + div(du)*Ubp)
			     -gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(du):Strain(Ub))+(Strain(Ub):Strain(du)))
			     -2.0/3.0*(2.0*div(Ub)*div(du))))
			  +gamma/(Pr*Re)*gradgrad(duT,usT)
			  // energy
			   +usp*(dup-(durho*UbT+Ubrho*duT))
			  // shift
			  +shift*(usrho*durho+Ubrho*duy*usy+Ubrho*dux*usx+usT*Ubrho*duT)
			  )
			  -intN(th)(AMPFORCE*(usy*duy+usx*dux+usT*duT+usrho*durho))
			  +BoundaryconditionsStability(du,us,symmetry);

varf b(defUU(du),defUU(us))=intN(th)((usrho*durho+Ubrho*duy*usy+Ubrho*dux*usx+usT*Ubrho*duT));

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : ARNOLDI SOLVER / SLEPC
//    
	matrix<complex> OP,B;
    B= b(XXxxxH,XXxxxH);  

if(iadjoint=="D")
	{ OP=jacobian(XXxxxH,XXxxxH); shiftOP = shift; modeEig = "Eigenmode";}
else if(iadjoint=="A")
	{ OP=jacobian(XXxxxH,XXxxxH); OP = OP'; shiftOP = conj(shift); modeEig = "EigenmodeA";}
else if(iadjoint=="S"||iadjoint=="cS"||iadjoint=="E") 
	{ SFerror("$$ WARNING : type 'S'  and 'E' no longer supported ! please use SF_Sensitivity"); };

int k;
complex[int] ev(nev); // Eigenvalues
complex[int,int] EigenVEC(OP.n,nev);


SFEVSOLVE(k,nev,OP,B,shiftOP,ev,EigenVEC); // Warning : in this macro OP is A - shift B !

int Nmodes = min(k,nev); // nb. de vecteurs propres Ã  post-traiter
XXxxxH<complex> [int] [eux,euy,ep,eT,erho](Nmodes); // Eigenvectors
for (int i=0; i<Nmodes; i++)
{
	eux[i][] = EigenVEC(:,i);
};

//
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//    

namefile=ffdatadir+"Spectrum.txt";
ofstream fileVP1(namefile); 
for (int i=0;i<Nmodes;i++)
{
	if (iadjoint == "A")
	{
		ev[i] = conj(ev[i]); eux[i][] = eux[i][];
	}
     fileVP1 << real(ev[i]) << " " << imag(ev[i]) << endl;
     cout << " Eigenvalue : " << i+1 << "  : " << ev[i] << endl;
	 namefile=ffdatadir+"Eigenmode"+(i+1);
	 // Normalize the mode
	 ux[] = eux[i][];
	 NormalizeMode(u);
	 cout << "Normalizing eigenmode " << i << endl;
	 cout << "Writing eigenmode in file " << namefile << endl;
	 ofstream fileMode(namefile+".txt");
		 fileMode.precision(16);
   		 fileMode.scientific;
		 fileMode << ux[]; 
		 fileMode << endl << endl << Re << endl << Ma << endl << endl << real(ev[i]) << "   " << imag(ev[i])  << endl;
  	  SFWriteMode(namefile+".ff2m",u,ev[i],shiftOP,modeEig,1); 	  
};
cout << "$$ --- Stability solver has finished --- $$" << endl;

//
//
//
//////////////////////////////////////////////////////////////////////////////////




















//
