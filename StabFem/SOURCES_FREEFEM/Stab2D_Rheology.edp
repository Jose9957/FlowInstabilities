//
//  PROGRAM Stab_2D.edp
//	
//	Performs the linear stability analysis of a 2D flow
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re , shift(Re,im) , Symmetry, Type, nev 
//
//   this solver will use either Arnoldi (if nev>1) or simple Shift-invert (if nev=1)
//
//	INPUT FILES :
//		BaseFlow.txt	-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//	single-mode calculation :
//		Eigenmode.txt   (txt format for FreeFem)
//      Eigenmode.ff2m  (ff2m format for stabfem)
// 		EigenmodeA.txt  ADJOINT  (txt format for FreeFem)
//      EigenmodeA.ff2m ADJOINT  (ff2m format for stabfem)
//      Sensitivity.txt 
//		Sensitivity.ff2m
//
// multiple-mode calculation :
//  	Eigenmode##.txt   (txt format for FreeFem)
//      Eigenmode##.ff2m  (ff2m format for stabfem)
//
// in all modes :
//		Spectrum.txt -> All computed Eigenvalues
//
// 
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, Eigenmode.txt is not generated and "iter" parameter in Eigenmode.ff2m is -1.
//

cout << "$$$$ ENTERING Stab2D_Rheology.edp " << endl << "$$" << endl;    

include "StabFem.idp";

//////////////////////////////////////////////////////////////////////////////
//////////////////----->             MACROS         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////
//
// Note : this solver requires three macros BoundaryConditionsStability, SFWriteMode, NormalizeMode.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your StabFem.idp file.
//

IFMACRO(!BoundaryconditionsStability)
macro BoundaryconditionsStability(u,v,symmetry)
	           on(1,ux#=0,u#y=0.0) 		/* label 1 = inlet */
             + on(2,u#x=0.0,u#y=0.0) 	/* label 2 = wall */
             							/* Label 3 is outlet : No-stress as a result of integration by parts, nothing to write here ! */
             + on(4,u#y=0.0)  			/* Label 4 is 'slip' or 'symmetry' condition on a horizontal boundary */
             + on(5,u#x=0.0)  			/* Label 5 is 'slip' or 'symmetry' condition on a vertical boundary */
             + int1d(th,6)(u#x*v#x*1e30*(symmetry=="A")+u#y*v#y*1e30*(symmetry=="S"))      
             							/* Label 6 is a symmmetry axis */
             							/* NB label 7 -> slip on a curved, nondeformable surface ; label 8 -> curved, deformable surface ; label 9 -> inner surface */  
//EOM
ENDIFMACRO

IFMACRO(!SFWriteMode)
macro SFWriteMode(namefile,u,ev,shift,typeFlow,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
		 p1forff2m xx,yy; xx=x;yy=y;
    	 p1forff2m<complex> ux1,uy1,pp1,vort1;  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "Eigenmode for a 2D-incompressible problem " << endl;
    	 file << "datatype Eigenmode datastoragemode CxP2P2P1.2 " << endl;
    	 string descriptionFF="real Re complex lambda complex shift int iter P1c ux P1c uy P1c p P1c vort"; 
    	 file << descriptionFF << endl << endl ; 
		 file << Re  << endl << real(ev) << endl << imag(ev) << endl << real(shift) << endl << imag(shift) << endl << iter << endl << endl;
   		 ux1=u#x;uy1=u#y;pp1=u#p;
		 vort1=dy(u#x)-dx(u#y);		
		for (int j=0;j<ux1[].n ; j++) file << real(ux1[][j]) << endl << imag(ux1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(uy1[][j]) << endl << imag(uy1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(pp1[][j]) << endl << imag(pp1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << endl << imag(vort1[][j]) << endl;
		};
//EOM
ENDIFMACRO	

IFMACRO(!NormalizeMode)
macro NormalizeMode(u)
{
real NORM = int2d(th)(abs(u#x)^2+abs(u#y)^2);
u#x[] = u#x[]/NORM;
}
//EOM
ENDIFMACRO



//////////////////////////////////////////////////////////////////////////////
//////////////////----->             parameters         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////



	real Re;                  
	cout << "$$ Enter Reynolds                     >>   "; 
	cin  >> Re;
	cout << Re << endl;
	real shiftr,shifti;	
	cout << "$$ Enter SHIFT (re,im)                 >>  " ; 
	cin  >> shiftr >> shifti;
	cout << shiftr << " " << shifti << endl;
	complex shift = 1i*shifti+shiftr;
	string symmetry;
	cout << "$$ Symmetry properties ?? (A, S or N).  >> " ;
	cin >> symmetry;
	cout << symmetry << endl;
	string iadjoint; // 0 for direct ; 1 for adjoint
	cout << "$$ Direct (D), Adjoint (A), D&A+sensitivity (S) >> " ;
	cin >> iadjoint;	
	cout << iadjoint << endl;
	int nev;
    cout << "$$ Enter nev ? (will use simple shift-invert if nev = 1) >> " ;
    cin >> nev ;
    cout << nev << endl;

	
	cout << "$$ ### PARAMETERS SELECTED : " << endl;
	cout << "$$ Re = " << Re<< endl;
	cout << "$$ shift = " << shift << endl;
	
		if (symmetry =="S") {cout << "$$ Symmetric modes" << endl;}
		else if (symmetry =="A") {cout << "$$ Antiymmetric modes" << endl;}	
		else if (symmetry =="N") {cout << "$$ No symmetry axis" << endl;}
		;	
	
		if (iadjoint =="D") {cout << "$$ DIRECT PROBLEM" << endl;}
		else if (iadjoint =="A") {cout << "$$ ADJOINT PROBLEM (discrete)" << endl;}
		else if (iadjoint =="S"||iadjoint =="E") {cout << "$$ DIRECT+ADJOINT (discrete) PROBLEM INCLUDING SENSITIVITY/Endogeneity" << endl;}
		else {cout << "$$ ERROR WHEN SELECTING PROBLEM TYPE" << endl;}
		;
	
	cout << "$$ nev = " << nev << endl;
	
	

//////////////////////////////////////////////////////////////////////////////
//////////////////----->             Reading input files         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////


mesh th=readmesh(ffdatadir+"mesh.msh");                    ///// Read mesh

fespace Xh(th,P2);             ////// f.e. space for vel.
fespace Mh(th,P1);            ////// f.e. space for pressure
fespace XXMh(th,[P2,P2,P1]); ////// f.e. space for triplet [u,v,p]
XXMh<complex> [ux,uy,up];                 ///////  -> unknown for the Navier-Stokes problem
XXMh [vx,vy,q];                 ///////  -> test for Navier-Stokes (should be defined as complex ???)
XXMh [Ubx,Uby,Pb];          ///////  -> Base Flow



real ReB,e,Cu,nRheo;
{
ifstream cbin(ffdatadir+"BaseFlow.txt");
cbin >> Ubx[] >> ReB >> e >> Cu >> nRheo;
}
if(Re!= ReB)
{ 
cout << "Warning : Re != ReB, is that really what you mean ???" << endl;
} 


/////////////////////////////////////////////////////////////////////////////////
////////    ---> varf for generalized eigenvalue problem: 		<--- //////////
////////////////////////////////////////////////////////////////////////////////////

real nu=1.0/Re;   // TO BE MODIFIED WITH SFGeomLenghtScale and SFGeomVelocityScale ??

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 
macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor

macro defTen(u) ( sqrt(2*(D(u):D(u)))  ) // EOM

macro muTen(u,CuNumb,n)  (  ( 1.0 + (CuNumb*defTen(u))^2.0 )^((n-1.0)*0.5)  ) // EOM

macro muTenLin(du,u,CuNumb,n) (  2*((n-1)*CuNumb^2*( 1.0 + (CuNumb*defTen(u))^2.0 )^((n-3.0)*0.5) )*(D(u):D(du))  ) // EOM
real eps = 1e-12; // desingularisation term for matrix B, useful with some solvers


varf   LNSE ([ux,uy,up],[vx,vy,q]) =
   int2d(th)( 

   			-2*nu*( (muTen(Ub,Cu,nRheo)*D(u):D(v)) + (muTenLin(u,Ub,Cu,nRheo)*D(Ub):D(v)) )
             + up*q*(eps) 
             + q*div(u)
             + div(v)*up
			 - Conv(u,Ub,v)
             )
 + int2d(th)( -shift*(ux*vx+uy*vy) )
 + BoundaryconditionsStability(u,v,symmetry);

// TO BE VALIDATED 
varf   LNSEadjointDiscrete ([ux,uy,up],[vx,vy,q]) =
   int2d(th)( 
   			-2*nu*( (muTen(Ub,Cu,nRheo)*D(u):D(v)) + (muTenLin(u,Ub,Cu,nRheo)*D(Ub):D(v)) )
             + up*q*(eps) 
             + up*div(v)
             + div(u)*q
             - Conv(v,Ub,u)
             )
 + int2d(th)( -conj(shift)*(ux*vx+uy*vy) ) // warning that shift/eigenvalues of adjoint are complex conjugates of direct !
 + BoundaryconditionsStability(u,v,symmetry); 


////// BUILD B-MATRIX 
	varf b([ux,uy,up],[vx,vy,q]) = int2d(th)( (ux*vx+uy*vy) );
		matrix<complex> B= b(XXMh,XXMh,solver=CG);  //////// see freefem++doc.pdf for the solver 

matrix<complex> OP,OPA;
complex shiftOP,shiftOPA;



////////////////////////////////////////////////////////////////////////////////////
////////    ---> 1. Solution in ARPACK MODE  (nev>1).   			<--- ///////////
////////////////////////////////////////////////////////////////////////////////////

if(nev>1)
{

////// BUILD OP-MATRIX=A-lambda*B 
if(iadjoint=="D")
	{ OP=LNSE(XXMh,XXMh,solver=sparsesolver); shiftOP = shift; }
else if(iadjoint=="A")
	{ 
		// Discrete adjoint
	    shiftOP = conj(shift); 
		OP=LNSE(XXMh,XXMh);
		OP = OP';
		shiftOP = shift;
		set(OP,solver=sparsesolver);  //// factorize matrix
	}
		// Continous Adjoint OP=LNSEadjointDiscrete(XXMh,XXMh,solver=sparsesolver); shiftOP = conj(shift); }
else if(iadjoint=="S"||iadjoint=="cS"||iadjoint=="E") 
	{ cout << "$$ WARNING : in this program option S will work only for nev=1" << endl; }
;

complex[int] ev(nev);                     ////// vector to store eigenvalues
XXMh<complex> [int] [eux,euy,eup](nev);   ////// vector to store EIGENVECTORS 


///////////////////// CALL TO ARPACK++ 
int ncv = 4*nev;   ///// Krylov Basis
int k=EigenValue(OP,B,sigma=shiftOP,value=ev,vector=eux,tol=1e-6,maxit=0,ncv=ncv);    //Arpack call
if(iadjoint=="A") { ev = conj(ev); } ;


//// POSTPROCESSING

	string namefile;
    namefile=ffdatadir+"Spectrum.txt";
    ofstream fileVP1(namefile); 
	
	for (int i=0;i<nev;i++)
	{
       fileVP1 << real(ev[i]) << " " << imag(ev[i]) << " " << Re << " " << 0 << " " << real(shift) << " " << imag(shift) << endl;
       	cout << "$$ Valeur propre : " << i+1 << "  : " << ev[i] << endl;

 		 if(iadjoint=="D"){namefile=ffdatadir+"Eigenmode"+(i+1);}
 		 else{namefile=ffdatadir+"EigenmodeA"+(i+1);};
 		 ux[] = eux[i][];
 		 NormalizeMode(u); 
 		  {
 		  ofstream fileMode(namefile+".txt");
 		  fileMode << ux[]; 
 		  fileMode << endl << endl << real(ev[i]) << endl << imag(ev[i])  << endl;
 		  }
 		 cout << "$$ Writing eigenmode in file " << namefile << endl;
 		 SFWriteMode(namefile+".ff2m",u,ev[i],shift,"EigenModeD",1);	 // MACRO DEFINED in StabFem_Macros.edp
 		 
 	};
}




////////////////////////////////////////////////////////////////////////////////////
////////    ---> 2. Solution in SHIFT-INVERT MODE (nev = 1) 		<--- ///////////
////////////////////////////////////////////////////////////////////////////////////


else

/// SIMPLE SHIFT-INVERT IF ONLY ONE MODE IS RESQUESTED
{
XXMh<complex> [ux0,uy0,p0],[uxdirect,uydirect,pdirect],[uxadjoint,uyadjoint,padjoint]; 
complex lambdadirect;
	
int testCB = exec("ls WORK/Eigenmode_guess.txt");
    	if (testCB!=0)
		{
		cout << "$$ No file Eigenmode_guess.txt : strarting from arbitrary initial condition" << endl;
		[ux0,uy0,p0] = [1,0,0];
		} 
		else
		{
		cout << "$$ Starting shift/invert from mode in file Eigenmode_guess.txt" << endl;
		ifstream cbin(ffdatadir+"Eigenmode_guess.txt");
		cbin >> ux0[];
		};


// selection of the computation to be performed : direct, adjoint or both
		
int directadjointA,directadjointB;
if(iadjoint=="D")
	{
	directadjointA = 1; directadjointB=1;
	cout << "$$ Shift-invert algorithm for DIRECT problem" << endl;
	}
else if(iadjoint=="A")
	{
	directadjointA = 2; directadjointB=2;
	cout << "$$ Shift-invert algorithm for ADJOINT problem" << endl;
	}
else if(iadjoint=="S"||iadjoint=="E")
	{
	directadjointA = 1; directadjointB=2;
	cout << "$$ Shift-invert algorithm for BOTH DIRECT AND ADJOINT(discrete) problem" << endl;
	}
;	
	

// LOOP TO SELECT WHICH COMPUTATION WILL BE DONE 
	for(int directadjoint=directadjointA;directadjoint<directadjointB+1;directadjoint++)	
	{

	if(directadjoint==1)
	{
		cout << "$$ Constructing operator for DIRECT problem ..." << endl;
		OP=LNSE(XXMh,XXMh,solver=sparsesolver);
		shiftOP = shift;
		cout << "$$ Solving DIRECT problem ..." << endl;
	}
	else if(directadjoint==2)
	{
		cout << "$$ Constructing operator for ADJOINT(discrete) problem ..." << endl;
		// Discrete adjoint
	    shiftOP = conj(shift); 
		OP=LNSE(XXMh,XXMh);
		OP = OP';
		shiftOP = shift;
		// Continous adjoint
		//OP=LNSEadjointDiscrete(XXMh,XXMh,solver=sparsesolver);
		//shiftOP = conj(shift);
		cout << "$$ Solving ADJOINT problem ..." << endl;
	}
	;

	int itmax = 50;
	complex lambda0 = 1e6;
	real err = 1e6;
	real errmax=1e-6;
	complex lambda;
	
	varf brhs([ux,uy,p],[vx,vy,q]) = int2d(th)( (ux0*vx+uy0*vy) );
	set(OP,solver=sparsesolver);  //// factorize matrix
	
	/// ITERATION LOOP
	int iter;
	for (iter=0; ((err>errmax)&&(iter<itmax)); iter++)
	{
    	complex[int] rhs= brhs(0,XXMh);  //////// see freefem++doc.pdf for the solver 
		complex[int] w = OP^-1*rhs;
		ux[] = w;
		complex XnXn1 = int2d(th)(ux0*ux+uy0*uy);
		complex Xn1Xn1 =  int2d(th)(ux*ux+uy*uy);
		complex GG = Xn1Xn1/XnXn1;
		// at each step the inverse shifted eigenval. is approximated by <X_{n+1}, Y> / <X_n, Y>
		//      ( the choice Y = X_{n+1} is convenient but we could choose something else )
		lambda = shiftOP+1/GG;
		err = abs(lambda-lambda0);
		cout << "$$ Iteration " << iter+1 << " : " << endl;	
		cout << "$$ Estimated eigenvalue lambda = " << lambda << endl;	
		ux0[] = 1/sqrt(abs(Xn1Xn1))*ux[];
		lambda0 = lambda;
	};
	/// END ITERATION LOOP	
	if(directadjoint==2||directadjoint==0){lambda=conj(lambda);};
 	// renormalization 
	NormalizeMode(u);
	
	string namefile,namefileFF,descriptionFF,typeDA; 
	if(iter<itmax)
	
	// post-processing if iteration was successful
	{	
		real lambdar = real(lambda) ; real lambdai = imag(lambda);
    	if(directadjoint==1)
    	{
    		ofstream fileVP(ffdatadir+"Spectrum.txt");
    		fileVP << lambdar << " " << lambdai << " " << Re <<  " " << real(shift) << " " << imag(shift) << endl;
    		namefile=ffdatadir+"Eigenmode.txt";
    		namefileFF=ffdatadir+"Eigenmode.ff2m";
    		typeDA = "D";
    		uxdirect[]=ux[];
    		lambdadirect = lambda;
    	};
    	
    	if(directadjoint==2)
    	{
    		ofstream fileVP(ffdatadir+"Spectrum.txt");
           	fileVP << lambdar << " " << lambdai << " " << Re << " " << real(shift) << " " << imag(shift) << endl;
    		namefile=ffdatadir+"EigenmodeA.txt";
    		namefileFF=ffdatadir+"EigenmodeA.ff2m";	
    		typeDA = "A";
    		uxadjoint[]=ux[];
    	};
    
    // write outpout in .txt format (for freefem)
    {
    ofstream file(namefile);
  	file << ux[] ;	
   	file << endl << endl << lambdar << "   " << lambdai  << endl;
    }

    // write output in .dff.2m format (for StabFem)
	SFWriteMode(namefileFF,u,lambda,shift,"EigenMode"+typeDA,iter);	 // MACRO DEFINED in StabFem_Macros.edp
	
	} // end of post processing of simple shift-invert case
else // case iteration failed
{
	cout << "$$ ERROR : shift-invert iteration failed ; shift is probably wrong" << endl;
	namefileFF=ffdatadir+"Eigenmode.ff2m";	
	SFWriteMode(namefileFF,u,lambda,shift,"EigenModeD",-1);	 // MACRO DEFINED in StabFem_Macros.edp

};

if (testCB==0)
		{
		exec("rm Eigenmode_guess.txt");// to be sure this file is not reused unless explicitly requested
		};


}; //end of loop for direct/adjoint/selection

if(iadjoint=="S"||iadjoint=="E")
//
{
cout << "$$ Computation of sensitivity after direct and adjoint" << endl;

//	cout << "$$STAT" << uxdirect(2.5,.5) << "$$ " << uxadjoint(2.5,.5) << "$$ " << uydirect(2.5,.5) << "$$ " << uyadjoint(2.5,.5) << endl ;



	
	// Sensitivity
	fespace p2(th,P2);fespace p1(th,P1);
	p2 sensitivity;
	sensitivity = sqrt(abs(uxadjoint)^2+abs(uyadjoint)^2) * sqrt(abs(uxdirect)^2+abs(uydirect)^2);
	real norm = sensitivity[].max;
	sensitivity=1/norm*sensitivity;
	
	
	string namefile,namefileFF;
   	p1 xx,yy,sensitivityP1;
	xx=x;
	yy=y;
    sensitivityP1 = sensitivity;
    
    
    	// Endogeneity
	p2<complex> Endogeneity;
// first method : leads to  wrong and noisy results... what's wrong ? maybe bad idea to multiply by matrix.
//	XXMh<complex> [Opux,Opuy,Opup],[Bux,Buy,Bup];
//    Bux[] = B*uxdirect[];
//	OP=LNSE(XXMh,XXMh,solver=sparsesolver);
//	Opux[]  = OP*uxdirect[];
//	Opux[] += shift*Bux[]; // because the operator did contain the shift
//	Endogeneity = (conj(uxadjoint)*Opux+conj(uyadjoint)*Opuy+conj(padjoint)*Opup);
//	complex normalization = int2d(th)(conj(uxadjoint)*uxdirect+conj(uyadjoint)*uydirect);
//	Endogeneity = 1/normalization*Endogeneity;
//	cout << " 6 " << endl; 	

// second method
	Endogeneity = (conj(uxadjoint)*uxdirect+conj(uyadjoint)*uydirect);
	complex normalization = int2d(th)(conj(uxadjoint)*uxdirect+conj(uyadjoint)*uydirect);
	Endogeneity = lambdadirect/normalization*Endogeneity;

//	plot(Endogeneity,wait=1);
	complex sigmacheck = int2d(th)(Endogeneity);
	cout << "sigma based on Endogeneity : " << sigmacheck << endl;
    p1<complex> EndogeneityP1 = Endogeneity;
    
    // Writing SENSITIVITY to files :
    namefile=ffdatadir+"Sensitivity.txt";   
    namefileFF=ffdatadir+"Sensitivity.ff2m";
    {
         ofstream fileFF(namefileFF);
         fileFF << "### Data generated by Freefem++ ; " << endl;
         fileFF << "Sensitivity (wavemaker) for a 2D-incompressible problem" << endl;
    	 fileFF << "datatype Sensitivity datastoragemode ReP2.0" << endl; // if the field for adapt is endogeneity
	     fileFF << "P1 sensitivity P1c endogeneity" << endl << endl ;
		 for (int j=0;j<sensitivityP1[].n ; j++) fileFF << sensitivityP1[][j] << endl;
		 for (int j=0;j<sensitivityP1[].n ; j++) fileFF << real(EndogeneityP1[][j]) << endl << imag(EndogeneityP1[][j]) << endl;
     };
	{
    	ofstream file(namefile);
		file << sensitivity[] ;	
    } 





// Writing ENDOGENEITY to files :
	namefile=ffdatadir+"Endogeneity.txt";   
    namefileFF=ffdatadir+"Endogeneity.ff2m";

    {
         ofstream fileFF(namefileFF);
         fileFF << "### Data generated by Freefem++ ; " << endl;
         fileFF << "Endogeneity for a 2D-incompressible problem" << endl;
    	 fileFF << "datatype Endogeneity datastoragemode CxP2.0" << endl; // if the field for adapt is endogeneity
	     fileFF << "P1 sensitivity P1c endogeneity" << endl << endl ;
		 for (int j=0;j<sensitivityP1[].n ; j++) fileFF << sensitivityP1[][j] << endl;
		 for (int j=0;j<sensitivityP1[].n ; j++) fileFF << real(EndogeneityP1[][j]) << endl << imag(EndogeneityP1[][j]) << endl;
     };
	{
    	ofstream file(namefile);
		file << Endogeneity[] ;	
    } 



}; // end of selection of mutliple mode (krylov) / single mode (simple shift-invert)



};
cout << "$$$$ SUCCESSFULLY LEAVING Stab2D.edp " << endl ;

