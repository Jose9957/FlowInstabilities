///
// PROGRAM StabAxi_FreeSurface_Viscous.edp
// STILL TO BE RATIONALIZED A LOT !!!


//  Computation of the eigenvalues and eigenvectors for oscillations of a static meniscus (GENERAL PROGRAM)
// ----------------------------------------
// the problem is viscous : 


// previous comment : inviscid potential
// u = grad (phi) 
// PROBLEM : find $\omega$ and $[phi,eta]$  such that
// 	$$ \Delta \phi = 0 $$ inside the domain
// 	$$ \lambda \phi = - \gamma (-(K0a^2+K0b^2) \eta - \partial^2 \eta / \partial s^2 + m^2/r^2 \eta $$ on the free surface
// 	$$ \lambda \eta = grad \phi \dot n $$ on the free surface 
// 
//-----------------------------------------

// Remarque : phi et eta sont definis comme des champs P1 sur le volume, meme si eta n'a de sens qu'à la surface


include "StabFem.idp"
include "Macros_Lineic.idp"

verbosity=0;

// constantes physiques 
//real g=0;                 // Gravity field
real gamma=1;	  // Surface Tension
real R=1;
real dpdz;
real nu;
real GAMMABAR;
string typestart,typeend;

try
{
ifstream file(ffdatadir+"BaseFlow.txt"); // here this is not a base flow but the parameters
file >> gamma >> dpdz >> GAMMABAR;
cout << "$$$ successfully read BF file containing physical parameters " << endl;
cout << "$$$ Surface tension gamma = " << gamma<< endl;
cout << "$$$ gravity rho g = " << dpdz<< endl;
cout << "$$$ circulation Gamma/(2 pi) = " << GAMMABAR << endl; 
}
catch(...)
{ cout << "WARNING : DID NOT FIND A FILE BaseFlow.txt. " << endl 
       << " Make sure to provide physical parameters as optional arguments (-gamma gamma -dpdz dpdz -GAMMA GAMMA)" <<  endl;
       gamma = 1; dpdz = 1; GAMMABAR = 0; /* new default values */
};
cout << "%% TENSION DE SURFACE gamma : ";
gamma =  getARGV("-gamma",gamma);
cout << gamma << endl;
cout << "%% PARAMETRE DE GRAVITE dp/dz = rho g : ";
dpdz = getARGV("-dpdz",dpdz);
cout << dpdz << endl;
cout << "%% CIRCULATION GAMMA : ";
GAMMABAR= getARGV("-GAMMA",GAMMABAR);
cout << GAMMABAR << endl;    
cout << "%% VISCOSITE NU  : " ;
nu=getARGV("-nu",1e-12);
cout << nu << endl;



// Parametres du calcul
int m;  // Nombre d'onde

cout << "%% typestart (pined, axis, plane, freeH, freeV) : ";
typestart = getARGV("-typestart","pined");
cout << typestart << endl;

cout << "%% typeend (pined, axis, plane) : ";
typeend = getARGV("-typeend","pined");
cout << typeend << endl;

cout << "%% Nombre d'onde m ?";
m = getARGV("-m",1);
cout << m << endl;

int nev;
cout << "%% Nombre de modes a calculer : " ;
nev = getARGV("-nev",10);
cout << nev << endl;

complex shift;
real shiftr, shifti;
cout << "%% Shift (real and imaginary part) : " ;
shiftr = getARGV("-shift_r",0.);
shifti = getARGV("-shift_i",0.);
shift = shiftr+1i*shifti;
cout << shift << endl << endl;
	
	
IFMACRO(!SFWriteMode)		
macro SFWriteMode(namefile,MODE,ev)
  {	
   	fespace P1forfile(th,P1);
    fespace P1linforfile(thlin,P1);
    P1linforfile<complex> Etaforfile,K1forfile;
    Etaforfile=MODE#eta;
    K1forfile=MODE#k1;
   	{
	ofstream file(namefile);
	file << "### Data generated by Freefem++ ; " << endl;
    file << "Eigenmode of a free-surface problem (VISCOUS)" << endl;
    file << "datatype Eigenmode datastoragemode CxP1bP1bP1bP1P1P1 datadescriptors uz,ur,uphi,p" << endl;
	file << "complex* lambda int* m P1surfc eta P1surfc K1" << endl << endl ;
	file << real(ev) <<  endl << imag(ev) << endl << m << endl << endl; 
	int Nsurface = Etaforfile[].n;
		for(int ksurf=0;ksurf<Nsurface;ksurf++) 
	     { file << real(Etaforfile[](ksurf))<< endl << imag(Etaforfile[](ksurf)) << endl; 
   	     };
	file << endl;
		for(int ksurf=0;ksurf<Nsurface;ksurf++) 
	     { file << real(K1forfile[](ksurf))<< endl << imag(K1forfile[](ksurf)) << endl; 
   	     };
	file << endl;
	
   };
  }
//EOM	
ENDIFMACRO


// Parametres du calcul

cout << "==> Calcul des valeurs propres pour m = " << m << endl;


int Nval = nev;  // nb. de valeurs propres à calculer
int Nmodes = Nval; // nb. de vecteurs propres à post-traiter
int ncv = 4*nev;   ///// Krylov Basis





////////////////////////////////////////////////////////////////
//
// MAILLAGE ET GEOMETRIE INITIAUX
//
////////////////////////////////////////////////////////////////


mesh th=readmesh(ffdatadir+"mesh.msh");
int[int] lab = [7];
meshL thlin = extract(th,refedge = lab);
fespace Vhlin(thlin,P1);

Vhlin xsurf,ysurf,S0,alphasurf,N0x,N0y,K0a,K0b;
// CALL THE MACRO
CalcGeomLin(thlin,xsurf,ysurf,S0,alphasurf,N0x,N0y,K0a,K0b,th,7)

//meshL Thlin = thlin;
//CheckGeom

fespace P1bP1bP1bP1P1P1(th,[P1b,P1b,P1b,P1,P1,P1]);
fespace PP1(th,P1);

P1bP1bP1bP1P1P1<complex> [uz,ur,uphi,up,ueta,uk1],[vz,vr,vphi,vp,veta,vk1];


//real shift = 1e-12;  // value of the shift
real RegEta = 1e-8;


macro div(im,u) (dy(u#z)+dx(u#r)+u#r/x+im/x*u#phi)// macro for divergence 
//macro Grad(im,u) [
//			[dy(u#z), dx(u#z),  im/x*u#z ], 
//			[dy(u#r), dx(u#r),  im/x*u#r-u#phi/x],
//			[dy(u#phi),dx(u#phi), im/x*u#phi+u#r/x ]
//			] // macro for vecocity gradient tensor
macro D(im,u) [	
				[dy(u#z), 				.5*(dx(u#z)+dy(u#r)),  .5*(im/x*u#z+dy(u#phi)) ], 
				[.5*(dx(u#z)+dy(u#r)), 	dx(u#r),				.5*(im/x*u#r-u#phi/x+dx(u#phi))],
				[.5*(im/x*u#z+dy(u#phi)),  .5*(im/x*u#r-u#phi/x+dx(u#phi)), im/x*u#phi+u#r/x]
			   ] // macro for rate-of-deformation tensor

//macro Ds(a) (Tl.x*dx(a)+Tl.y*dy(a)) //EOM
macro Ds(a) (N.y*dx(a)-N.x*dy(a)) //EOM

//macro Conv(ima,ua,imb,ub,v) ( 
//              (Grad(ima,ua)*[ub#x,ub#r,ub#phi] + Grad(imb,ub)*[ua#x,ua#r,ua#phi])'*[v#x,v#r,v#phi]
//              			) // macro for mutual convection operator



// Warning boundary labelling :
// 2 surface, 1 axis, 5 plates.
// should be changed to 8, 6, 2.

// CONSTRUCTION DES MATRICES

macro nr() N0x // 
macro nz() N0y //


varf a([uz,ur,uphi,up,ueta,uk1],[vz,vr,vphi,vp,veta,vk1]) = 
 	int2d(th)(
 	         ( 
   			 - 2*nu*(D(1i*m,u):D(-1i*m,v))
             + up*div(-1i*m,v)
             + div(1i*m,u)*vp
             )*x
             )   	
	+ int1d(th,7)(gamma*uk1*(vz*nz+vr*nr)*x)  // dynamic BC
	+ int1d(th,7)(-vz*dpdz*ueta*nz*x)// gravity
	+ int1d(th,7)(veta*(uz*nz+ur*nr)*x) // kinematic BC
	+ int1d(th,7)((uk1*vk1+(Ds(ueta))*(Ds(vk1))-(K0a^2+K0b^2)*ueta*vk1+m^2/x^2*vk1*ueta
	             //-1e-5*((Ds(uk1))*(Ds(vk1))-(K0a^2+K0b^2)*uk1*vk1+m^2/x^2*vk1*uk1) // test
	             ) *x) // def of k1
	+ int2d(th)( -shift*(uz*vz+ur*vr+uphi*vphi)*x ) // shift volume
	+ int1d(th,7)(-shift*ueta*veta*x) // shift surface
	+ int2d(th)(1e-8*(ueta*veta+uk1*vk1)*x )
	+ int1d(th,2,25)(1e15*ueta*veta*((typestart=="pined")||(typeend=="pined"))) // pinned contact lines
	+ int1d(th,6)(uz*vz*1e15*(abs(m)>0)+(ur*vr+uphi*vphi)*1e15*(abs(m)!=1))
	+ int1d(th,6)(1e15*(uk1*vk1)*(abs(m)>0)) //axis 
//	+ on(5,55,ur=0,uz=0,uphi=0) // plates
	+ int1d(th,2,25)(1e15*(ur*vr+uz*vz+uphi*vphi))
;

varf b([uz,ur,uphi,up,ueta,uk1],[vz,vr,vphi,vp,veta,vk1]) =
      int2d(th)((uz*vz+ur*vr+uphi*vphi)*x )
    + int1d(th,7)(ueta*veta*x)
;


////////////////////////////////////////////////////
//
//  RESOLUTION DU PB AUX VALEURS PROPRES
//
//  Important warning : here the computed eigenvalues correspond to omega = lambda/i !
//  
/////////////////////////////////////////////////////


matrix<complex> OP= a(P1bP1bP1bP1P1P1,P1bP1bP1bP1P1P1,solver=sparsesolver,tgv=1e15); 
matrix<complex> B= b(P1bP1bP1bP1P1P1,P1bP1bP1bP1P1P1,solver=CG); 

int k;
complex[int] ev(nev); // to store nev eigein values
complex[int,int] EigenVEC(B.n,nev);

cout << "Dimensions A, B : "<<  OP.m << " x " << OP.n << " and  " <<  B.m << " x " << B.n << endl; 

SFEVSOLVE(k,nev,OP,B,shift,ev,EigenVEC);

Nmodes = min(k,nev); // nb. de vecteurs propres à post-traiter



//int nev=Nval;  // number of computed eigen valeu close to sigma
//complex[int] ev(Nval); // to store nev eigein values
//P1bP1bP1bP1P1P1<complex>[int] [eVuz,eVur,eVuphi,eVp,eVeta,eVK1](Nval);   // to store nev eigen vectors
//int k=EigenValue(OP,B,sigma=shift,value=ev,vector=eVuz,tol=1e-8,maxit=0,ncv=ncv);  




////////////////////////////////////////////////////
//
//    POST TRAITEMENT
//
///////////////////////////////////////////////////




cout << " ### VP Calculees :" << endl;

//real[int]  eev(Nval);
ofstream EV(ffdatadir+"Spectrum.txt");
EV.scientific;
P1bP1bP1bP1P1P1<complex> [MODEz,MODEr,MODEphi,MODEp,MODEeta,MODEk1];

for (int i=0;i<Nmodes;i++)
  {
    cout << " VP numero " <<  i << " : " << real(ev[i]) << "+i" << imag(ev[i]) <<  endl;
    EV << real(ev[i]) << "  " << imag(ev[i]) << " " <<  "   " << m  
    << endl; 

// Normalisation of the modes
        ueta[] = EigenVEC(:,i);
        complex norm;
        {
        PP1<complex> uetaTEMP=ueta;
        real[int] Xx = uetaTEMP[].re;
        real[int] Yy = uetaTEMP[].im;
        real[int] etaRAD  = Xx.*Xx;
                  etaRAD += Yy.*Yy;
        etaRAD = sqrt(etaRAD);
        int Imax = etaRAD.imax;
        norm =  uetaTEMP[][Imax];
      // if(norm ==0){ cout << "WARNING  : dected norm = 0 !" << endl; norm =1; };
        }
		ueta[] = 1/norm*ueta[];


  
// Post-traitement MODES
  if (i<k)
     {	
   	  ofstream FileTXT(ffdatadir+"Eigenmode"+(i+1)+".txt");
   	  FileTXT << ueta[];
   	  FileTXT << endl << endl;
   	  FileTXT << real(ev[i]) << " " << imag(ev[i]) << endl;
   	  MODEz[] = ueta[];
     SFWriteMode(ffdatadir+"Eigenmode"+(i+1)+".ff2m",MODE,ev[i]);

IFMACRO(FREEFEMPLOTS,YES)   
//      plot(eVur[i],cmm="mode numero"+i+" : ur", wait=1); 
//      plot(eVuz[i],cmm="mode numero"+i+" : uz", wait=1); 
//      plot(eVuphi[i],cmm="mode numero"+i+" : uphi", wait=1);	
//      plot(eVeta[i],cmm="mode numero"+i+" : eta", wait=1); 	
//      plot(eVK1[i],cmm="mode numero"+i+" : k1", wait=1); 	
ENDIFMACRO

     };
  };	
	
// HACK for compatibility
if(nev==1)
{ 
  exec("cp "+ffdatadir+"Eigenmode0.txt "+ffdatadir+"Eigenmode.txt");
  exec("cp "+ffdatadir+"Eigenmode0.ff2m "+ffdatadir+"Eigenmode.ff2m");
};




