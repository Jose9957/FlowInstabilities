//
//  PROGRAM Newton_Axi_Comp_Sponge.edp
//  Computation of axisymmetric compressible base flow [uz,ur,p,T,rho](z,r); in the code uz \equiv ux and ur \equiv uy
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Restructured 30/12/2020 | 
// Updated by Javier Sierra.

//////////////////////////////////////////////////////////////////////////////////
//
//		0 : Headers (Include/load & global macros)		
//


load "MUMPS" // Load MUMPS solver (alternatives PARDISO, SuperLU)
load "PETSc" // Load PETSc (real)
macro dimension() 2// EOM            // 2D or 3D useful for intN and similar macros
include "macro_ddm.idp" // Include macros for the partitioning of the mesh
macro def(i) [i,i#B,i#C,i#D,i#E]// EOM    
macro init(i)[i,i,i,i,i]// EOM         
macro DESACTIVATESLEPC() // EOM
include "StabFem.idp";
macro mpicout() if(mpirank==0) cout //EOF // Useful for outputs in the terminal
include "getARGV.idp" // Arguments instead of pipeline

/////////////////////////////////////////////////////////////////////////////////

mpiComm comm(mpiCommWorld, 0, 0);

int mpicommSize = mpiSize(mpiCommWorld);
int mpirank = mpiRank(mpiCommWorld);
int status; 

mpicout << "MPI Comm size = " << mpicommSize << endl;
mpicout << "MPI rank in Comm = " << mpiRank(comm) << endl;

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		1 : Parallel related macros		
//


/* Definition of Local mesh (without overlapping) */

IFMACRO(!LocalMeshNonOverlapped)
macro LocalMeshNonOverlapped(thLocalOverlapped,thLocalNonOverlapped,partUnity,PkFEM,restrictIdx)
{

	int[int] n2o;
	NewMacro thN2O()n2o EndMacro
    if(mpirank == 0)
        partitionerSeq(partUnity[], thLocalOverlapped, mpisize); 
    partitionerPar(partUnity[], thLocalOverlapped, mpiCommWorld, size);
    NewMacro ThName#UserPartitioning() partUnity[] EndMacro
    buildDmesh(thLocalOverlapped)
    restrictIdx = restrict(XXxxxH, XXxxxHG, n2o);
    thLocalNonOverlapped = trunc(thLocalOverlapped, abs(partUnity - mpirank) < 1e-1);
    partUnity = abs(partUnity - mpirank) < 1e-1 ? 1 : 0;
    createMat(th, A, PkFEM);
}
//EOM
ENDIFMACRO


/*
IFMACRO(!LocalMeshNonOverlapped)
macro LocalMeshNonOverlapped(thLocalOverlapped,thLocalNonOverlapped,partUnity,PkFEM,Ddist,interArray,sSplit)
{
    if(mpirank == 0)
        partitionerSeq(partUnity[], thLocalOverlapped, mpisize); 
    partitionerPar(partUnity[], thLocalOverlapped, mpiCommWorld, size);
    buildWithPartitioning(thLocalOverlapped, partUnity[], sSplit, interArray, Ddist, PkFEM, mpiCommWorld);
    partUnity = partUnity; 
    thLocalNonOverlapped = trunc(thLocalOverlapped, abs(partUnity - mpirank) < 1e-1);
    partUnity = abs(partUnity - mpirank) < 1e-1 ? 1 : 0;
}
//EOM
ENDIFMACRO
*/
/* Macro to perfom a reduction to rank == 0 of arithmetic (real or complex) Pk FEM fields */
IFMACRO(!SFReduceFespace)
macro SFReduceFespace(fieldth,fieldGlobthG,arithmetic)
{
	XXxxxHG<arithmetic> defU(fieldLocthG);
	XXxxxH<arithmetic> defU(fieldLocthL);
	XH partP2 = part;
	Xh partP1 = part;
	/* Restrict to non overlapping domain */
	defU(fieldLocthL) = [fieldth#x*partP2,fieldth#y*partP2,fieldth#p*partP1,fieldth#T*partP1,fieldth#rho*partP1]; /* Global variable (interpolate) */
	fieldLocthG#x[](R) = fieldLocthL#x[];
	/* Reduce(sum) on proc == 0 */
	mpiReduce(fieldLocthG#x[], fieldGlobthG#x[], processor(0, comm), mpiSUM); 
	mpiReduce(fieldLocthG#y[], fieldGlobthG#y[], processor(0, comm), mpiSUM);
	mpiReduce(fieldLocthG#p[], fieldGlobthG#p[], processor(0, comm), mpiSUM);
	mpiReduce(fieldLocthG#T[], fieldGlobthG#T[], processor(0, comm), mpiSUM);
	mpiReduce(fieldLocthG#rho[], fieldGlobthG#rho[], processor(0, comm), mpiSUM);
}//EOM
ENDIFMACRO


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		2 : Definition of parameters		
//


/* Physical parameters */
real Re,Reans,Ma,Maans;
real gamma=getARGV("-gamma",1.4); 
real Pr=getARGV("-Pr",0.71); 
real STemperature=getARGV("-STemperature",0.40417353102690834); // The Sutherland temperature: 110.4/273.15 for air
real nu;
/* Newton solver parameters */
real tolNewton=getARGV("-tolNewton",1e-7); // tolerance of newton loop
int imaxNewton=getARGV("-imaxNewton",40); // Max number of Newton iterations
real maxtolNewton = getARGV("-maxtolNewton",50.0); // Maximum tolerance for divergence criterion
int viscosityTemperature = getARGV("-viscosityTemperature",1); // Dynamic viscosity dependence on temperature (0-off,1-on)



real L2Norm=1; // L2Norm of the relevant quantity used as a tolerance-convergent monitor
int iNewton=0; // Iterations of Newton method

string 	sparamsDirect = "-pc_type lu -pc_factor_mat_solver_type mumps ";

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		3 : Defintion of FEM spaces (lecture of mesh)		
//


func Pk = [P2, P2, P1, P1, P1];
meshN th, thG, thNo;
if(mpirank==0)
  th=readmesh(ffdatadir+"mesh.msh"); /* global mesh read on rank 0 */
broadcast(processor(0, mpiCommWorld), th);     // global mesh broadcasted to all ranks
thG=th; /* Global mesh */

/* Definition of FEspaces */
fespace XH(th,P2);
fespace XHG(th,P2);
fespace XHNo(thNo,P2);

fespace Xh(th,P1);
fespace XhG(th,P1);
fespace XhNo(thNo,P1);

fespace Ph(th, P0);
fespace PhG(thG, P0);
fespace PhNo(thNo, P0);

fespace XXxxxH(th,Pk);   //   Local mesh (overlapped) : pres P1 + vel 2x P2 + temp P1 + dens P1
fespace XXxxxHG(thG,Pk); //   Global mesh: pres P1 + vel 2x P2 + temp P1 + dens P1
fespace XXxxxHNo(thNo,Pk); // Local mesh (without overlapping): pres P1 + vel 2x P2 + temp P1 + dens P1

/* Definition of Field definition macros */

macro defU(u)[u#x,u#y,u#p,u#T,u#rho]//EOF  

/* Restriction */ 

int[int][int] intersection; /* local-to-neighbors renumbering */
real[int] DDD; /* partition of unity */
int s = getARGV("-meshSplit",1);; /* refinement factor */
Ph part;
int[int] R;

Mat A;
LocalMeshNonOverlapped(th,thNo,part,Pk,R)


/* Create thNo mesh: Local mesh (without overlapping) -- Another option use Dmesh */
//LocalMeshNonOverlapped(th,thNo,part,Pk,DDD,intersection,s)

/* Definition of Vector fields */
XXxxxH defU(du); // Update solution field
XXxxxHG defU(UbG); // Global solution field
XXxxxH defU(Ub);  // Local (overlapped) solution field 


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		4a : Customizable macros for the variational formulation	
//
//

/* Customizable definition of the Reynolds number -- dynamic viscosity (it should be mu, however nu as in the incompressible) */
IFMACRO(!SFReCustom)
macro SFReCustom nu=1./Re; //EOM
ENDIFMACRO

/* Provides access to the ReNumber in case of use for Boundary Conditions */
IFMACRO(!ReNumber)
macro ReNumber() Re // EOM For BC
ENDIFMACRO

/* Provides access to the MachNumber in case of use for Boundary Conditions */
IFMACRO(!MachNumber)
macro MachNumber() Ma // EOM For BC
ENDIFMACRO

/* Useful for boundary conditions */

/* Streamwise initial velocity */
IFMACRO(!Uin)
macro Uin(x,y) 0.0 //EOM
ENDIFMACRO	

/* Crosswise initial velocity */
IFMACRO(!Vin)
macro Vin(x,y) 0. //EOM
ENDIFMACRO	

/* initial density */
IFMACRO(!rhoin)
macro rhoin(x,y) 1. //EOM
ENDIFMACRO	

/* initial Temperature */
IFMACRO(!Tin)
macro Tin(x,y) 1. //EOM
ENDIFMACRO	

/* initial Temperature */
IFMACRO(!Pin)
macro Pin(x,y) 0. //EOM
ENDIFMACRO	

func real SutherlandLaw(real mu0, real S, real T)
{
	// T_ref = 1, therefore S = S_dim/T_ref
	real muViscosity = mu0*(T)^(3/2)*(1.0+S)/(T+S);
	return muViscosity;
}

func real DSutherlandLawDT(real mu0, real S, real T)
{
	// T_ref = 1, therefore S = S_dim/T_ref
	real dmudT = ((mu0/2)*(1+S)*(T+3*S)/(T+S)^2)*sqrt(T);
	return dmudT;
}

func real funcmuT (real mu0, real S, real T)
{
	real muViscosity;

	if(viscosityTemperature == 1)
	{
		muViscosity = SutherlandLaw(mu0, S, T);
	}
	else
	{
		muViscosity = mu0;
	}

	return muViscosity;
}

func real funcDmuDT (real mu0, real S, real T)
{
	real DmuViscosityDT;

	if(viscosityTemperature == 1)
	{
		DmuViscosityDT = DSutherlandLawDT(mu0, S, T);
	}
	else
	{
		DmuViscosityDT = 0.0;
	}

	return DmuViscosityDT;
}

/* Definition of macros for variational formulations */ 

/* Jacobian of the system of coordinates */

IFMACRO(!JJJ)
macro JJJ() y //EOM
ENDIFMACRO

/* Differential forms */

macro div(u) ((dx(u#x)+dy(u#y)+(u#y)/y)) // EOM
macro ugradf(u,f) ((u#x*dx(f)+u#y*dy(f))) // EOM
macro termnonlinear(u,v,w) ((w#x*(u#x*dx(v#x)+u#y*dy(v#x))+w#y*(u#x*dx(v#y)+u#y*dy(v#y)))) // EOM
macro Grad(u) [[dx(u#x),dx(u#y),u#x-u#x],[dy(u#x),dy(u#y),u#x-u#x],[u#x-u#x,u#x-u#x,u#y/y]] // EOM
macro Strain(u)[[dx(u#x),0.5*(dx(u#y)+dy(u#x)),u#x-u#x],[0.5*(dx(u#y)+dy(u#x)),dy(u#y),u#x-u#x],[u#x-u#x,u#x-u#x,u#y/y]] // EOM
macro gradgrad(u,v)(dx(u)*dx(v)+dy(u)*dy(v)) // EOM

/* Navier Stokes Fourier equations -- Linear forms */
IFMACRO(!muTemperatureNL)
macro muTemperatureNL(u) ( funcmuT(1/Re,STemperature,u#T) ) // EOM 
ENDIFMACRO

IFMACRO(!muTemperatureLIN)
macro muTemperatureLIN(U,du) ( funcDmuDT(1/Re,STemperature,U#T)*du#T ) // EOM 
ENDIFMACRO

IFMACRO(!ContinuityResidualNS)
macro ContinuityResidualNS(u,v) ( v#rho*( u#rho*div(u)+ugradf(u,u#rho) ) ) // EOM
ENDIFMACRO

IFMACRO(!MomemtumEquationNS)
macro MomemtumEquationNS(u,v) ( u#rho*termnonlinear(u,u,v) - u#p*div(v)
+  muTemperatureNL(u)*( 2.0*(Strain(u):Grad(v))-2.0/(3.0)*(div(u)*div(v)) ) ) // EOM
ENDIFMACRO

IFMACRO(!EnergyEquationNS)
macro EnergyEquationNS(u,v) ( v#T*(u#rho*ugradf(u,u#T)+(gamma-1)*u#T*u#rho*div(u)
-gamma*(gamma-1.0)*Ma^2*muTemperatureNL(u)*(2.0*((Strain(u):Strain(u)))-2.0/3.0*(div(u)*div(u))))
+gamma*muTemperatureNL(u)/(Pr)*gradgrad(u#T,v#T) ) // EOM
ENDIFMACRO

IFMACRO(!StateEquationNS)
macro StateEquationNS(u,v) ( v#p*(1.0 + gamma*Ma^2*u#p-(u#rho*u#T)) ) // EOM
ENDIFMACRO

IFMACRO(!ResidualNS)
macro ResidualEquationNS(u,v) ( JJJ*(ContinuityResidualNS(u,v) + MomemtumEquationNS(u,v) + EnergyEquationNS(u,v) + StateEquationNS(u,v)) ) // EOM
ENDIFMACRO

/* End of Navier Stokes Fourier equations */

/* Navier Stokes Fourier derivative (jacobian) -- bilinear forms */

IFMACRO(!ContinuityResidualLNS)
macro ContinuityResidualLNS(U,u,v) ( v#rho*(u#rho*div(U)+U#rho*div(u)+ugradf(U,u#rho)+ugradf(u,U#rho)) ) // EOM
ENDIFMACRO

IFMACRO(!MomemtumEquationLNS)
macro MomemtumEquationLNS(U,u,v) ( U#rho*termnonlinear(u,U,v)+u#rho*termnonlinear(U,U,v)+U#rho*termnonlinear(U,u,v)
-u#p*div(v)+2.0*muTemperatureNL(U)*( (Strain(u):Grad(v))-2.0/(3.0)*(div(u)*div(v)) )
+ 2.0*muTemperatureLIN(U,u)*( (Strain(U):Grad(v))-2.0/(3.0)*(div(U)*div(v)) ) ) // EOM
ENDIFMACRO

IFMACRO(!EnergyEquationLNS)
macro EnergyEquationLNS(U,u,v) ( v#T*(u#rho*ugradf(U,U#T)+U#rho*ugradf(U,u#T)+U#rho*ugradf(u,U#T)
+(gamma-1)*(div(U)*(u#rho*U#T+U#rho*u#T) +U#rho*U#T*div(u))
-gamma*(gamma-1.0)*Ma^2*muTemperatureNL(U)*(2.0*((Strain(u):Strain(U))+(Strain(U):Strain(u)))-2.0/3.0*(2.0*div(U)*div(u)))
-gamma*(gamma-1.0)*Ma^2*muTemperatureLIN(U,u)*(2.0*((Strain(U):Strain(U)))-2.0/3.0*(div(U)*div(U)))  ) 
+gamma*muTemperatureNL(U)/(Pr)*gradgrad(u#T,v#T) + gamma*muTemperatureLIN(U,u)/(Pr)*gradgrad(U#T,v#T) )  // EOM
ENDIFMACRO

IFMACRO(!StateEquationLNS)
macro StateEquationLNS(U,u,v) ( v#p*(gamma*Ma^2*u#p-(u#rho*U#T+U#rho*u#T)) ) // EOM
ENDIFMACRO

IFMACRO(!OperatorLNS)
macro OperatorLNS(U,u,v) ( JJJ*(ContinuityResidualLNS(U,u,v) + MomemtumEquationLNS(U,u,v) + EnergyEquationLNS(U,u,v) + StateEquationLNS(U,u,v)) ) // EOM
ENDIFMACRO

/* End of Navier Stokes Fourier (jacobian) -- bilinear forms */

/* Boundary conditions -- generic */ 

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(U,u,v)
	           on(1,u#x=Uin(x,y)-U#x,u#y=Vin(x,y)-U#y,u#rho=rhoin(x,y)-U#rho,u#T=Tin(x,y)-U#T)
	         + on(3,u#x=Uin(x,y)-U#x,u#y=Vin(x,y)-U#y,u#rho=rhoin(x,y)-U#rho,u#T=Tin(x,y)-U#T)  
             + on(2,u#x=0.0-U#x,u#y=0.0-U#y)
      		 + on(6,u#y=0.0-U#y) 
//EOM
ENDIFMACRO

/* End of Boundary conditions -- generic */ 

macro LiftExchange(nu,u,symm)
{
	LiftLoc = LiftCompute(th,nu,u,symm);
	mpiAllReduce(LiftLoc, LiftGlob, mpiCommWorld, mpiSUM);
} // EOM

macro DragExchange(nu,u,symm)
{
	DragLoc = DragCompute(th,nu,u,symm);
	mpiAllReduce(DragLoc, DragGlob, mpiCommWorld, mpiSUM);
} // EOM

macro Lift(nu,u,symm) LiftGlob // EOM
macro Drag(nu,u,symm) DragGlob // EOM


//////////////////////////////////////////////////////////////////////////////////
//
//		4b : Customizable macros for input/output	
//
//

/* Reading of parameters */
IFMACRO(!SFParameters)
macro SFParameters()
Re=getARGV("-Re",50.0);
mpicout << " --> Re = " << Re << endl;
Ma=getARGV("-Ma",0.01);
mpicout << " --> Ma = " << Ma << endl;
SFReCustom; // Customizable Reynolds number definition
// EOM
ENDIFMACRO

IFMACRO(!SFWriteBaseFlowParallel)
macro SFWriteBaseFlowParallel(filename,u,typeFlow,iter)
	{
		ofstream file(filename);
	   	{
			file << "### Data generated by Freefem++ ; " << endl;
		    file << typeFlow << " for a axisymmetric-compressible problem " << endl;
		    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1P1P1.2 datadescriptors ux,uy,p,T,rho,Re,Ma" << endl;
			file << "real* Re real* Ma real iter " << endl << endl ; 
			file << Re << endl;	
		    file << Ma << endl;
			file << iter << endl;
		}
	}; 
// EOM
ENDIFMACRO

/* if your want something else this macro may be redefUined in your Macro_StabFem.idp */
IFMACRO(!DefaultGuessForNewton) 
macro DefaultGuessForNewton() defU(UbG) = [Uin(x,y),Vin(x,y),Pin(x,y),Tin(x,y),rhoin(x,y)]; //EOM
ENDIFMACRO


IFMACRO(!SFReadBaseFlow)
macro SFReadBaseFlow()
if(mpirank==0)
{
	int testCB = exec("ls "+ffdatadir+"/BaseFlow_guess.txt");
	if (testCB!=0)
	{
		mpicout << "$$ No file BaseFlow_guess.txt : starting from arbitrary initial condition" << endl;
		DefaultGuessForNewton;
	} 
	else
	{
	    mpicout << "$$ Reading file BaseFlow_guess.txt" << endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
		file >> UbGx[];
		file >> Reans;
		file >> Maans;
		mpicout << "$$ Re of guess field : " << Reans << endl; 
		mpicout << "$$ Ma of guess field : " << Maans << endl; 
	};
}
broadcast(processor(0,comm),UbGx[]); /* broadcast the full initial meanflow */
defU(Ub) = defU(UbG); /* Restriction to the mpirank^{th} domain */
//EOM
ENDIFMACRO

IFMACRO(!SFPostProcess)
macro SFPostProcess(u,filename,iter)
	SFReduceFespace(u,UbG,real); /* Restrict & Reduce on proc == 0 */
	if(mpirank==0)
	{
		ofstream file(ffdatadir+filename+".txt");
		file << UbGx[]; 
		file << endl << Re << endl << endl << Ma << endl << endl;
		SFWriteBaseFlowParallel(ffdatadir+filename+".ff2m",UbG,"BaseFlow",iter);
	};
// EOM	
ENDIFMACRO


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		5 : Reading files and parameters
//


SFParameters; // Read basic parameters
SFReadBaseFlow; // Read base flow


//
//
//
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//		6 : Construction of variational operators
//

varf vLNS(defU(du),defU(us))=intN(th)( OperatorLNS(Ub,du,us) ) + BoundaryconditionsBaseFlow(du,Ub,us);
varf vNS(defU(du),defU(us))=-intN(th)( ResidualEquationNS(Ub,us) ) + BoundaryconditionsBaseFlow(du,Ub,us);

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		7 : Resolution of the non-linear problem
//

while((L2Norm>tolNewton)&(iNewton<=imaxNewton))
{
  real timeI=mpiWtime();

  /* Assemble Linear operator in PETSc indexing */
  matrix mLNS = vLNS(XXxxxH,XXxxxH,tgv=-1);
  Mat<real> MLNS(A,mLNS);
  //Mat<real> MLNS(mLNS,intersection,DDD);
  timeI=mpiWtime()-timeI;
  mpicout<<"Linear operator assembled in "<< timeI << " s "<<endl;  

  /* Assemble RHS in PETSc indexing */
  real[int] RHS;
  {
  	  timeI=mpiWtime();
  	  real[int] ffRHS = vNS(0,XXxxxH,tgv=-1);
  	  changeNumbering(MLNS, ffRHS, RHS);
  	  timeI=mpiWtime()-timeI;
  	  mpicout<<"Residual assembled in "<< timeI << " s "<<endl;  

  }

  /* Update solution vector and Newton update in PETSc and fespace indexing */
  {

  	timeI=mpiWtime();
	real[int] dSolution(RHS.n); // Update of the Newton iteration
	set(MLNS, sparams=sparamsDirect);
	KSPSolve(MLNS,RHS,dSolution);
  	timeI=mpiWtime()-timeI;
  	mpicout<<"Linear system solved in "<< timeI << " s "<<endl;  

 	real[int] solPETSc;
  	changeNumbering(MLNS, Ubx[], solPETSc); /* Solution in PETSc indexing */ 
 	solPETSc = solPETSc + dSolution; /* Updated solution in PETSc indexing */
  	changeNumbering(MLNS, Ubx[], solPETSc, inverse = true, exchange = true); /* Updated solution in fespace indexing */ 
  	changeNumbering(MLNS, dux[], dSolution, inverse = true, exchange = true); /* Update of the solution in fespace indexing */ 
  }

  /* Norm of the meanflow */
  {
		real UbL2G; 
		real UbL2 = int2d(thNo)( JJJ*(Ubx*Ubx + Uby*Uby) );
		mpiAllReduce(UbL2, UbL2G, comm, mpiSUM);

		real dUbL2G; 
		real dUbL2 = int2d(thNo)( JJJ*(dux*dux + duy*duy) );
		mpiAllReduce(dUbL2, dUbL2G, comm, mpiSUM);
		L2Norm = dUbL2G;

		mpicout << " --- iteration " << iNewton << " --- " << endl;
		mpicout << " --- Monitor of the solution  --- " << endl;

		mpicout << " || U ||_{L^2} " << UbL2G  << endl;
		mpicout << " || dU ||_{L^2} " << dUbL2G  << endl;
  }

  iNewton++;	    

}// end of NEWTON LOOP

mpicout << " -------------------------------------------------------- "<< endl;	
mpicout << " Newton iteration ok!"<< endl;

if((L2Norm>maxtolNewton)||(iNewton>=imaxNewton))
{
	mpicout << "--- NEWTON ITERATION FAILED ---" << endl;
	mpicout << "--- Leaving FreeFem++ with error code 201 ----" << endl;
	exit(201);
}


//
//
//
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//		8 : Post-Process
//


SFPostProcess(Ub,"BaseFlow",iNewton);


//
//
//
//////////////////////////////////////////////////////////////////////////////////






