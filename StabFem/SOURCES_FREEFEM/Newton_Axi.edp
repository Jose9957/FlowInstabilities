//
//  PROGRAM Newton_Axi.edp
//  computation of an axisymmetric base flow [ux,uy](x,y)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
// REwriten on october 2 2017 with macros.

	cout << "$$$$ ENTERING Newton_Axi.edp " << endl << "$$" << endl; 

	include "StabFem.idp"

	cout << "$$$$ ENTERING Newton_Axi.edp " << endl << "$$" << endl; 



// READ MESH and declare FEspaces
    
		mesh th=readmesh(ffdatadir+"mesh.msh");

		
////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : selection of parameters		
//
				
		
	real Re;
	real Reans,lecture;

 	// Main physical parameters using standart input 
	cout << "$$ Entrer le Nombre de Reynolds :" << endl;
    Re=getARGV("-Re",1.);    
    cout << "$$ Newton pour Re = " << Re << endl;	
    real nu = 1/Re;
       

    // Customizable physical parameters using macro (if needed define this macro in you SF_Custom.idp)
    IFMACRO(SFInputParametersNewton)
	SFInputParametersNewton;	
	ENDIFMACRO
    
    // Numerical parameters using getARGV
  
    real tolerance=getARGV("-tolerance",2e-12);
    int Nitermax=getARGV("-Nitermax",30);
    string IBPViscous = getARGV("-IBPViscous","D"); // either "D" or "Grad"
    int DEBUG = getARGV("-DEBUG",0);

    cout << "$$ NUMERICAL PARAMETERS (handled by getARGV or default ) " << endl;
    // cout << "$$ Fespace used : " << Pkstring << endl; // to be verified
    cout << "$$ tolerance for Newton = " << tolerance << endl;
    cout << "$$ Nitermax = " << Nitermax << endl;
    cout << "$$ Integration by parts of viscous term (D or Grad) : " << IBPViscous << endl;
    cout << "$$ DEBUG MODE : " << DEBUG << endl;
     
	   
    // If Nu is something else than 1/Re define a macro CUSTOMnu in your  .idp file
    IFMACRO(CUSTOMnu)
    nu = CUSTOMnu;
    ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//

		
        fespace Xh(th,P2);       //f.e. space for veloecity components
		fespace Mh(th,P1);      //f.e space for pressure
		fespace XXMh(th,[P2,P2,P1]); // f.e. space for triplet [u,v,p]
		fespace XXXMh(th,[P2,P2,P2,P1]); // f.e. space for triplet [u,v,p]
		XXMh [ux,ur,up];          ///////  -> unknown for the Navier-Stokes problem
		XXMh [vx,vr,vp];          ///////  -> test function for Navier-Stokes
		XXMh [upx,upr,upp];   	 ///////  -> buffer vector  to store previous iteration (Newton) 
		XXMh [dux,dur,dup]; 		 ///////  -> increment for the Newton iteration
		XXXMh [u3cx,u3cr,u3cphi,u3cp];

// READ BASEFLOW

		int NdimUVP = ux[].n;
    	int NdimUVWP = u3cx[].n;
   		int NdimBaseFlow;
		SFcheckfile("BaseFlow_guess.txt",NdimBaseFlow)	
    	if (NdimBaseFlow<0)
		{
		SFwarning("No file BaseFlow_guess.txt : starting from arbitrary initial condition");
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
		macro DefaultGuessForNewton
		[ux,ur,up] = [0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
	else if(NdimBaseFlow == NdimUVP) 
		{
                cout << "$$Ndim = " << NdimUVP << " : reading UVP baseflow " << endl;
                ifstream file(ffdatadir+"BaseFlow_guess.txt");
                file >> ux[];
                file >> Reans;
                }
        else if(NdimBaseFlow == NdimUVWP) 
        {
        cout << "$$Ndim = " << NdimUVWP << " : reading UVWP baseflow ; skipping W component" << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> u3cx[];
        [ux,ur,up] = [u3cx,u3cr,u3cp]; 
		file >> Reans;
        }
        else 
        {
        SFerror("Wrong dimension For BaseFlow_guess.txt file");
        exit(7);
        };
        cout << "$$ Reynolds for initial condition : " << Reans << endl; 

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//

// A. Boundary conditions 
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO
IFMACRO(!Vinlet)
macro Vinlet() 0. //EOM
ENDIFMACRO
IFMACRO(!Winlet)
macro Winlet() 0. //EOM
ENDIFMACRO

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,up,v)
	           on(1,du#r=Vinlet-up#r,du#x=Uinlet-up#x)
             + on(2,21,22,23,du#x=0.0,du#r=0.0)
             + on(5,du#x=0.0)+on(4,51,du#r=0) /* ??? */
             + on(6,du#r=0.0)      
//EOM
ENDIFMACRO

// B. Post-processing
IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)(1/y*(dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(6,21,22,23,psi=0)
					         + on(1,4,2,psi=y^2/2);
//EOM
ENDIFMACRO      
	    
IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
	fespace p1forff2m(th,P1);  
    p1forff2m vort,psi,test; 
	vort=-dy(u#x)+dx(u#r);
	CalcPsi(psi,vort,test)  
	ofstream file(filename);
   	{
   	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for an axisymmetric incompressible problem" << endl;
    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1.1 datadescriptors ux,ur,p,Re" << endl;
    file << "real* Re P1 vort P1 psi real iter " ; 
	string PostProcessBaseFlowDescription = " " ; 
	file << PostProcessBaseFlowDescription << endl << endl ; 
	file << Re << endl;	
	for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	for (int j=0;j<psi[].n ; j++)  file << psi[][j]  << endl;
	file << iter << endl << endl;
 	}
	};
//EOM
ENDIFMACRO

// C. Differential operators
                         
// macro to define some useful operators

macro div(u) (dx(u#x)+dy(u#r)+u#r/y)// macro for divergence 
macro Grad(u) [[dx(u#x), dy(u#x),  u#x-u#x ], [dx(u#r), dy(u#r), u#x-u#x],[u#x-u#x,u#x-u#x,u#r/y ]] // macro for rate-of-deformation tensor
macro D(u) [[dx(u#x), .5*(dx(u#r)+dy(u#x)),  u#x-u#x ], [.5*(dx(u#r)+dy(u#x)), dy(u#r),u#x-u#x],[u#x-u#x,u#x-u#x,u#r/y ]] // macro for rate-of-deformation tensor

macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#r*dy(ub#x))+(ub#x*dx(ua#x)+ub#r*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#r)+ua#r*dy(ub#r))+(ub#x*dx(ua#r)+ub#r*dy(ua#r)))*v#r 
                    ) // macro for mutual convection operator
real eps = 1e-12;

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//

// linearized system
problem NewtonIter([dux,dur,dup],[vx,vr,vp]) =
    int2d(th)( 
			(
             -2*nu*(D(du):D(v))*(IBPViscous=="D")-nu*(Grad(v):Grad(du))*(IBPViscous=="Grad")
			//-2*nu*(D(du):D(v))
             + vp*div(du)
             + div(v)*dup
				-Conv(up,du,v)
                +eps*dup*vp
		     )*y
              )
             +
    int2d(th)(
		  (
            -2*nu*(D(up):D(v))*(IBPViscous=="D")-nu*(Grad(v):Grad(up))*(IBPViscous=="Grad")
    		//-2*nu*(D(up):D(v))
             + vp*div(up)
             + div(v)*upp
             -.5*Conv(up,up,v)
          )*y
              )
	+  BoundaryconditionsBaseFlow(du,up,v);     
    
  
//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//  
    
// parameters for Newton loop            

    real ener=10;	
    int iter=0;
    
// Newton loop
        while((ener>tolerance)&(ener<50)&(iter<=Nitermax))
        {
	    upx[]=ux[];        ////// Uold=U    
        NewtonIter ;           //// update of current solution u1=u1-w
//        IFMACRO(FREEFEMPLOTS,YES)
        plot(dux,fill=1,wait=0,value=1,cmm="dux");
        plot(dur,fill=1,wait=0,value=1,cmm="duy");
//        ENDIFMACRO
        ux[] = ux[]+dux[];
		real enerl2=dux[].l2;
		ener=sqrt(int2d(th)(dux^2+dur^2)/th.area);
	    cout << "$$ iter = "<< iter+1 << "   Re = " << Re << " res = " << ener << " ; res l2 = " << enerl2 << endl;
        iter++;

        if (DEBUG==1)
		{
			ofstream file(ffdatadir+"DEBUG/U_Iter"+FixedFormatInt(iter,6)+".txt"); 		    
			file << ux[]; 
		    SFWriteBaseFlow(ffdatadir+"DEBUG/U_Iter"+FixedFormatInt(iter,6)+".ff2m",u,"Iteration",iter);
		    ofstream file2(ffdatadir+"DEBUG/DU_Iter"+FixedFormatInt(iter,6)+".txt"); 		    
			file2 << dux[]; 
		    SFWriteBaseFlow(ffdatadir+"DEBUG/DU_Iter"+FixedFormatInt(iter,6)+".ff2m",u,"DUIteration",iter);
		 }; 

	  } ;


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : Post-processing 
//

// sortie des résultats 

    {   ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		 file << ux[]; 
		 file << endl <<  Re << endl;
	}; 
		  
          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); 
          // file in .ff2ml format for StabFem driver
             
if((ener>50)||(iter>Nitermax))
		{
			cout << "$$ NEWTON ITERATION FAILED" << endl;
			cout << "$$ Leaving FreeFem++ with error code 201" << endl;
			exit(201);
		}
else    
        {  
            cout << "$$$$ SUCESSFULLY LEAVING Newton_Axi.edp " << endl ;
        };
