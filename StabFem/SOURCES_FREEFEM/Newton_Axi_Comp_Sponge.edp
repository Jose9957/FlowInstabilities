//
//  PROGRAM Newton_2D_Comp.edp
//  computation of 2D compessible base flow [ux,uy,p,T,rho](x,y)
//  Sponge version
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Incorporated by David Fabre from a code of Flavio
// Updated by Javier Sierra.

///////////////////////////////////////////////////////////////////////////////////////////////
// INPUT PARAMETERS FROM USER
real Re,Reans,Ma,Maans;

cout << " Enter Reynolds Number ?' " << endl;
cin >> Re;
cout << " Enter Mach Number ?' " << endl;
cin >> Ma;
cout << endl << " >>> Re = " << Re << "    ;  Mach = " << Ma  << endl;
macro MachNumber() Ma // EOM For BC

///////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUDE FILES
load "MUMPS"
include "StabFem.idp";
real ts;
//////////////////////////////////////////////////////////////////////////////////////////////
// Physical parameters
real gamma=1.4; 
real Pr=0.7;
real nu;
IFMACRO(!SFReCustom)
macro SFReCustom nu=1./Re; //EOM
ENDIFMACRO
SFReCustom
///////////////////////////////////////////////////////////////////////////////////////////////
mesh th=readmesh(ffdatadir+"mesh.msh");
//////////////////////////////////////////////////////////////////////////////////////////////
real TOLLERANCENewton=2e-8;  /// tollerance of newton loop
int NITERATIONNEWTLOOP=40;  //////////////  Max number of ITERATIONs --> Newton loop
real TOLLERANCEDiv = 20.0; // Tolerance to reset initial condition due to divergence of the Newton method.
real ener=1;
///////////////////////////////////////////////////////////////////////////////////////////////
fespace XH2(th,P2);
fespace XXxxxH(th,[P2,P2,P1,P1,P1]); ///   pres P1 + vel 2x P2 + temp P1 + dens P1
///////////////////////////////////////////////////////////////////////////////////////////////
macro defU(u,p,T,rho)[u#x,u#y,p,T,rho]//EOF
macro defUU(u)[u#x,u#y,u#p,u#T,u#rho]//EOF  
XXxxxH defUU(du);
XXxxxH defUU(Ub);
///////////////////////////////////////////////////////////////////////////////////////////////
IFMACRO(!Uin)
macro Uin() 0.0 //EOM
ENDIFMACRO	

IFMACRO(!Vin)
macro Vin() 0. //EOM
ENDIFMACRO	
XXxxxH defU(Urif,Prif,Trif,Rhorif)=[Uin,0.0,0.0,1.0,1.0];
///////////////////////////////////////////////////////////////////////////////////////////////
XH2 AMPFORCE;

IFMACRO(!SFSPONGE)
macro SFSPONGE()
	func real AmpSponge(real M, real xinf, real xsup, real yinfsup)  
	{
	  if(M>0)
	    return abs(1.+1./M)*(x>xsup)*(alpha*(x-xsup))+abs(1.-1./M)*(x<xinf)*(alpha*(xinf-x))+abs(1./M)*(abs(y)>yinfsup)*(alpha*(abs(y)-yinfsup));
	  else
	    return 0.0;
	}
	AMPFORCE=AmpSponge(Ma,xinfm,xinfv,yinf);

//EOM
ENDIFMACRO
// Define Sponge function and field
SFSPONGE

IFMACRO(!JJJ)
macro JJJ() y //EOM
ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//
//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your SF_Custom.idp file.
//
	


IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,Ub,us)
	           on(1,du#x=Uin-Ub#x,du#y=Vinlet(y)-Ub#y,du#rho=1.-Ub#rho,duT=1.-Ub#T)
	         + on(3,du#x=Uinlet(y)-Ub#x,du#y=0.0-Ub#y,du#rho=1.-Ub#rho,duT=1.-Ub#T)  
             + on(2,21,du#x=0.0-Ub#x,du#y=0.0-Ub#y)
      		 + on(6,du#y=-Ub#y) 
//EOM
ENDIFMACRO

IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,rho,test)
      solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(rho*vort*test)
					         + on(6,2,21,22,23,psi=0)
					         + on(1,3,psi=y);
//EOM
ENDIFMACRO     

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
		fespace p1forff2m(th,P1);  
	    p1forff2m vort,divergence;
		vort=dy(u#x)-dx(u#y); /* vorticity */
	    divergence=dx(u#x)+dy(u#y); 
		ofstream file(filename);
	   	{
		file << "### Data generated by Freefem++ ; " << endl;
	    file << typeFlow << " for a 2D-compressible problem " << endl;
	    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1P1P1.2 datadescriptors ux,uy,p,T,rho,Re,Ma" << endl;
		file << "real* Re real* Ma P1 vort P1 div real iter " << endl << endl ; 
		file << Re << endl;	
	    file << Ma << endl;
				for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	            for (int j=0;j<vort[].n ; j++) file << divergence[][j] << endl;
				file << iter << endl;
		}
	}; 
// EOM
ENDIFMACRO

///////////////////////////////////////////////////////////////////////////////////////////////
int testCB = exec("ls "+ffdatadir+"/BaseFlow_guess.txt");
if (testCB!=0)
{
	if(mpirank==0) cout << "$$ No file BaseFlow_guess.txt : starting from arbitrary initial condition" << endl;
	IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefUined in your Macro_StabFem.idp
	macro DefaultGuessForNewton
		defUU(Ub) = [Uin,0.0,0.0,1.0,1.0]; //EOM
	ENDIFMACRO
	DefaultGuessForNewton;
} 
else
{
    cout << "$$ Reading file BaseFlow_guess.txt" << endl;
	ifstream file(ffdatadir+"BaseFlow_guess.txt");
	file >> Ubx[];
	file >> Reans;
	file >> Maans;
	cout << "$$ Re of guess field : " << Reans << endl; 
	cout << "$$ Ma of guess field : " << Maans << endl; 
};
///////////////////////////////////////////////////////////////////////////////////////////////
macro div(u) ((dx(u#x)+dy(u#y)+(u#y)/y))   //EOM
macro ugradf(u,f) ((u#x*dx(f)+u#y*dy(f)))    //
macro termnonlinear(u,v,w) ((w#x*(u#x*dx(v#x)+u#y*dy(v#x))+w#y*(u#x*dx(v#y)+u#y*dy(v#y)))) //
macro Grad(u) [[dx(u#x),dx(u#y),u#x-u#x],[dy(u#x),dy(u#y),u#x-u#x],[u#x-u#x,u#x-u#x,u#y/y]]//EOM
macro Strain(u)[[dx(u#x),0.5*(dx(u#y)+dy(u#x)),u#x-u#x],[0.5*(dx(u#y)+dy(u#x)),dy(u#y),u#x-u#x],[u#x-u#x,u#x-u#x,u#y/y]]//EOM
macro gradgrad(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

varf jacobian(defUU(du),defUU(us))=int2d(th)
										(JJJ*(
										usrho*(durho*div(Ub)+Ubrho*div(du)+ugradf(Ub,durho)+ugradf(du,Ubrho)) 
								       //mass equation
								       -dup*div(us)+2.0*nu*(Strain(du):Grad(us))-2.0*nu/(3.0)*(div(du)*div(us))
								       +Ubrho*termnonlinear(du,Ub,us)+durho*termnonlinear(Ub,Ub,us)+Ubrho*termnonlinear(Ub,du,us)
								       //momentum
								  		+usT*(durho*ugradf(Ub,UbT)+Ubrho*ugradf(Ub,duT)+Ubrho*ugradf(du,UbT)+(gamma-1)*(div(Ub)*(durho*UbT+Ubrho*duT) 
								  		+ Ubrho*UbT*div(du))-gamma*(gamma-1.0)*Ma^2*nu*(2.0*((Strain(du):Strain(Ub))+(Strain(Ub):Strain(du)))
								  		-2.0/3.0*(2.0*div(Ub)*div(du))))+gamma*nu/(Pr)*gradgrad(duT,usT)
								       // energy
								       +usp*(gamma*Ma^2*dup-(durho*UbT+Ubrho*duT))
								  		))
								  		//+int2d(th)(JJJ*AMPFORCE*(usy*duy+usx*dux+usT*duT+usrho*durho))
  										+BoundaryconditionsBaseFlow(du,Ub,us);


varf vNs(defUU(du),defUU(us))=-int2d(th)(JJJ*(
								usrho*(Ubrho*div(Ub)+ugradf(Ub,Ubrho))
							   //mass equation
							   -Ubp*div(us)+2.0*nu*(Strain(Ub):Grad(us))
							   -2.0*nu/(3.0)*(div(Ub)*div(us))+Ubrho*termnonlinear(Ub,Ub,us)
							   //momentum
								+usT*(Ubrho*ugradf(Ub,UbT)+(gamma-1)*UbT*Ubrho*div(Ub)
								   -gamma*(gamma-1.0)*Ma^2*nu*(2.0*((Strain(Ub):Strain(Ub)))-2.0/3.0*(div(Ub)*div(Ub))))
								   +gamma*nu/(Pr)*gradgrad(UbT,usT)
							   // energy
							   +usp*(1.0 + gamma*Ma^2*Ubp-(Ubrho*UbT))
							   ))
							   //-int2d(th)(JJJ*AMPFORCE*(usy*(Uby-Urify)+usx*(Ubx-Urifx)+usT*(UbT-Trif)+usrho*(Ubrho-Rhorif)))
  							   +BoundaryconditionsBaseFlow(du,Ub,us);

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

int i=0;
while((ener>TOLLERANCENewton)&(i<=NITERATIONNEWTLOOP))
{
  ts=clock();
  matrix Newt=jacobian(XXxxxH,XXxxxH);
  cout<<"Matrix formed in "<<clock()-ts<<" s"<<endl;  
  real[int] rhs= vNs(0,XXxxxH);
  set(Newt,solver=sparsesolver,tgv=-1);
  dux[] =  (Newt^-1*rhs);
  ener=sqrt(int2d(th)(JJJ*(abs(duy)^2+abs(dux)^2))); 
  cout << "iter "<<i<<" | sqrt(int2d(th)(dux^2+duy^2)) = " << ener << endl;
  Ubx[]+=dux[];
  i++;	    

}// end of NEWTON LOOP
 	  
cout << " -------------------------------------------------------- "<< endl;	
cout << " Newton iteration ok!"<< endl;

////// OUTPUT FOR STABFEM  
if((ener>50)||(i>=NITERATIONNEWTLOOP))
{
	cout << "$$ NEWTON ITERATION FAILED" << endl;
	cout << "$$ Leaving FreeFem++ with error code 201" << endl;
	exit(201);
}

XXxxxH [ux,uy,up,uT,urho] = defUU(Ub);
{
  {
	  ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
	  file << ux[]; 
	  file << endl << endl << Re << endl << Ma << endl << endl;
	  exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
  }; 
  SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",i); // file in .ff2ml format for StabFem driver
};
///////////////////////////////////////////////////////////////////////////////////////////////








