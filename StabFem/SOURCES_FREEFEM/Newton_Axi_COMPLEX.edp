//
//
//  PROGRAM Newton_Axi_COMPLEX.edp
//  computation of an axisymmetric base flow [ux,uy](x,y)
//
//  This program is similar to Newton_Axi.edp but uses the COMPLEX MAPPING technique and therefore
//  requires the base flow to be defined as complex. 
//
//  The parameters of the complex mapping (ParamMap###) are defined in a file "Param_Mapping.edp" 
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
//  First version : sometime around 2014 ; Redesigned and incorporated in the project in september 2018.




cout << "$$$$ ENTERING Newton_Axi_COMPLEX.edp " << endl << "$$" << endl; 

include "SF_Geom.edp";
include "StabFem.idp";
include "Param_Mapping.edp";

cout << "$$" << endl << "$$ USING COMPLEX MAPPING ; gamma = " << ParamMapGC << endl << "$$" << endl ;

//	int Nprof =6;
	
	real Uhole =1; // mean velocity across the hole
	
	//real Uinlet = (SFGeomRhole/SFGeomRcav)^2;
	
	real Re;
	real Reans,lecture;


cout << "###################################" << endl;
cout << endl << "       Newton_Axi.edp        " << endl; 
cout << endl << "###################################" << endl << endl;
	
	cout << " Entrer le Nombre de Reynolds :" << endl;

    cin >> Re;
    cout <<"***************************  "<< Re << endl;
    

    cout << " Parametres du mapping Lm,LA,LC,gc,yA,yB lus dans le fichier Param_Mapping.edp : " << endl; 
    cout << "Lm,LA,LC,gc,yA,yB : " << ParamMapLm  <<  " " << ParamMapLA  << " " << ParamMapLC << " " << ParamMapGC << " " << ParamMapyA << " " << ParamMapyB << endl;

	mesh th=readmesh(ffdatadir+"mesh.msh");
        fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        femp2xfemp2xfemp1<complex> [uxguess,urguess,pguess];
	
	
//	cout << "Mesh : meshall.msh" << endl;
    cout << "Mesh information : number of vertices    " << th.nv <<  endl;
	cout << "                   dimension of matrices " << uxguess[].n << endl << endl;
	
	fespace p1(th,P1);
	p1 yy,xx;
	xx = real(Xphys(x,y,ParamMap));
	real xxmaxR = xx[].max;
	xx = imag(Xphys(x,y,ParamMap));
	real xxmaxI = xx[].max;
	yy = Rphys(x,y,ParamMap);
	real ymax = yy[].max;
	
	cout << " dimensions du domaine :  ( " 
	<< xxmaxR << " + i " << xxmaxI << " ) x " << ymax << endl;
	
	
	int testCB = exec("ls "+ffdatadir+"BaseFlow_guess.txt");
    	if (testCB!=0)
		{
		cout << "$$ No file BaseFlow_guess.txt : strarting from arbitrary initial condition" << endl;
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
		macro DefaultGuessForNewton
		[uxguess,urguess,pguess] = [0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
		else
		{
		cout << "$$ Reading file BaseFlow_guess.txt" << endl;
		 ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> uxguess[];
		file >> Reans;
		cout << "$$ Re of guess field : " << Reans << endl; 
		};

//	{
//	cout << "$$ reading UVP baseflow " << endl;
//    ifstream file(ffdatadir+"BaseFlow_guess.txt");
//    file >> uxguess[];
//	file >> Reans;
//	}
	
//	femp1<complex> GG;
//	GG  = Hx(x,ParamMap);
	
//cout << " .5 .75 .9" << endl << GG(.1,0) << " " << GG(10,0) << " " << GG(14,0) << endl;



	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl; 
	
//		{ofstream log("log.txt",aupend);
//			log <<  "-------------------------"	<<endl;		
//			log <<  "Re = " << Re			<<endl;	
//			log <<  "CI = " << Reans		<<endl;		
//			log <<  "Nmat of the mesh = " << uxguess[].n	<<endl;}


        femp2xfemp2xfemp1<complex> [ux,ur,up]=[uxguess+0*1i,urguess+0*1i,pguess+0*1i];
	femp2xfemp2xfemp1<complex> [dux,dur,dup],[vz,vr,q];
	
   real nu = 1/Re;  
    // If Nu is something else than 1/Re define a macro CUSTOMnu in your Macros_StabFem.idp file
    IFMACRO(CUSTOMnu)
    nu = CUSTOMnu;
    ENDIFMACRO
    
        
	real epsilon=1e-6;
        real residuNewton=1e-10;
        int Nitermax=40;

        real res,ener=1.;



	
		int i=0;
         while((ener>residuNewton)&(i<=Nitermax))
        {
	    if (i==Nitermax-1) {break;
				cout<<"!!! "+Nitermax+"th iteration, the newton method will not converge !!!"<< endl;	}
			  
	solve NS([dux,dur,dup],[vz,vr,q])=
	// gradient
	int2d(th)(
        (  Rphys(x,y,ParamMap)*vz*(ux*dX(dux)+dux*dX(ux)+ur*dY(dux)+dur*dY(ux) )
         + Rphys(x,y,ParamMap)*vr*(ux*dX(dur)+dux*dX(ur)+ur*dY(dur)+dur*dY(ur) )	
         + nu*(Rphys(x,y,ParamMap)*dX(dux)*dX(vz)+Rphys(x,y,ParamMap)*dY(dux)*dY(vz)  
	     + Rphys(x,y,ParamMap)*dX(dur)*dX(vr)+Rphys(x,y,ParamMap)*dY(dur)*dY(vr)+1/Rphys(x,y,ParamMap)*dur*vr  )
	     - dup*(Rphys(x,y,ParamMap)*dX(vz)+vr+Rphys(x,y,ParamMap)*dY(vr))
	     + q*(Rphys(x,y,ParamMap)*dX(dux)+dur+Rphys(x,y,ParamMap)*dY(dur))
        )*JJ
	)
	

	// second membre
 	+ int2d(th)(
         (	Rphys(x,y,ParamMap)*(   vr*ur*dY(ur)+vr*ux*dX(ur)
	     	+ vz*ur*dY(ux)+vz*ux*dX(ux)  )
			+ nu*(Rphys(x,y,ParamMap)*dX(ux)*dX(vz)+Rphys(x,y,ParamMap)*dY(ux)*dY(vz)  
	      	+ Rphys(x,y,ParamMap)*dX(ur)*dX(vr)+Rphys(x,y,ParamMap)*dY(ur)*dY(vr)+1/Rphys(x,y,ParamMap)*ur*vr  )
        	- up*(Rphys(x,y,ParamMap)*dX(vz)+vr+Rphys(x,y,ParamMap)*dY(vr))
        + q*(Rphys(x,y,ParamMap)*dX(ux)+ur+Rphys(x,y,ParamMap)*dY(ur)) 
        )*JJ
        )
  	+  BoundaryconditionsBaseFlow(du,up,v);   
	
	
	

		  ener=sqrt(int2d(th)(abs(dur)^2+abs(dux)^2)/th.area);
		  
		  cout << " res = " << ener << endl;
	//		{ofstream log("log.txt",aupend);
	//		log <<  " res = " << ener 	<<endl;}	
			
				
                ur[]+=dur[];
        i++;
	
	if((i>10)&&(ener>1))
	{
	cout << " ATTENTION : DIVERGENCE PROBABLE" << endl;
	
	femp2xfemp2xfemp1 [realur,realux,realup] = [real(ur),real(ux),real(up)];
	femp2xfemp2xfemp1 [realuxguess,realurguess,realpguess] = [real(uxguess),real(urguess),real(pguess)];
	IFMACRO(FREEFEMPLOTS,YES)
	plot(realur,realuxguess,value=1,wait=true);
	plot(realux,realurguess,value=1,wait=true);
	plot(realup,realpguess,value=1,wait=true);
	ENDIFMACRO
	}
	
	}
		
// sortie des rÃ©sultats 

		if((ener>50)||(i>Nitermax))
		{
			cout << "$$ NEWTON ITERATION FAILED" << endl;
			cout << "$$ Leaving FreeFem++ with error code 201" << endl;
			exit(201);
		}
		else
		{
		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << ux[]; 
		  file << endl << endl << Re << endl;
		  }; 
 //         exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
          SFWriteBaseFlowCOMPLEX(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",i); // file in .ff2ml format for StabFem driver
   		};


SFWriteMesh(ffdatadir+"mesh.ff2m",th);
// this one is necessary here to reconstruct the "Mapping.ff2" file

          
cout << "$$$$ SUCESSFULLY LEAVING Newton_Axi_COMPLEX.edp " << endl ; 

//
