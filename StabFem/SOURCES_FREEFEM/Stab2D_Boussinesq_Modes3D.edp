//
//  PROGRAM Stab2D_Boussinesq_Modes3D.edp
//	
//	Performs the linear stability (3D) analysis of a 2D flow 
//  This solver is for the Boussinesq case 
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	k, shift(Re,im) , Type, nev 
//
//   this solver will use either Arnoldi (if nev>1) or simple Shift-invert (if nev=1)
//
//	INPUT FILES :
//		BaseFlow.txt	-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//	single-mode calculation :
//		Eigenmode.txt   (txt format for FreeFem)
//      Eigenmode.ff2m  (ff2m format for stabfem)
// 		EigenmodeA.txt  ADJOINT  (txt format for FreeFem)
//      EigenmodeA.ff2m ADJOINT  (ff2m format for stabfem)
//      Sensitivity.txt 
//		Sensitivity.ff2m
//
// multiple-mode calculation :
//  	Eigenmode##.txt   (txt format for FreeFem)
//      Eigenmode##.ff2m  (ff2m format for stabfem)
//
// in all modes :
//		Spectrum.txt -> All computed Eigenvalues
//
// 
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, Eigenmode.txt is not generated and "iter" parameter in Eigenmode.ff2m is -1.
//

  
include "SF_Geom.edp";
include "StabFem.idp";

//////////////////////////////////////////////////////////////////////////////
//////////////////----->             parameters         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////



	                
	real shiftr,shifti;	
	real k;
	cout << " Enter k ? " << endl;
	cin >> k;
	cout << " Enter SHIFT (re,im) :   " << endl; 
	cin  >> shiftr >> shifti;
	complex shift = 1i*shifti+shiftr;
	string iadjoint; // 0 for direct ; 1 for adjoint
	cout << " Direct (D), Adjoint (A), or both+sensitivity (S) ?" << endl;
	cin >> iadjoint;	
	int nev;
    cout << " Enter nev ? (will use simple shift-invert if nev = 1)" << endl;
    cin >> nev ;
	int ncv = 4*nev;   ///// Krylov Basis



	
	cout << " ### PARAMETERS SELECTED : " << endl;
	cout << " shift = " << shift << endl;
	cout << " k = " << k << endl;
		
	if (iadjoint =="D") {cout << " DIRECT PROBLEM" << endl;}
		else if (iadjoint =="A") {cout << " ADJOINT PROBLEM" << endl;}
		else if (iadjoint =="S") {cout << " DIRECT+ADJOINT PROBLEM INCLUDING SENSITIVITY" << endl;}
		else {cout << " ERROR WHEN SELECTING PROBLEM TYPE" << endl;};
	
	cout << " nev = " << nev << endl;
	

mesh th=readmesh(ffdatadir+"mesh.msh");                    ///// Read mesh


fespace Xh(th,P2);             ////// f.e. space for vel.
fespace Mh(th,P1);            ////// f.e. space for pressure
fespace XXMMh(th,[P2,P2,P1,P1]); ////// f.e. space for [u,v,T,p]
fespace XXXMMh(th,[P2,P2,P2,P1,P1]); ////// f.e. space for triplet [u,v,w,T,p]
macro def(u)[u#x,u#y,u#z,u#p,u#T]//EOF
XXXMMh<complex> def(u);       ///////  -> unknown for the Navier-Stokes problem
XXXMMh<complex> def(v);        ///////  -> test for Navier-Stokes
XXXMMh def(Ub);          ///////  -> Base Flow


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
///////////  Load baseflow   ////////////////////////////////////////////////////
real Ra,Pr,Qmag;  
{
ifstream cbin(ffdatadir+"BaseFlow.txt");
XXMMh [Ubbx,Ubby,Ubbp,UbbT]; 
cbin >> Ubbx[];
cbin >> Ra ;
cbin >> Pr ; 
cbin >> Qmag;
def(Ub) =[Ubbx,Ubby,0,Ubbp,UbbT]; 
}

cout << "$$" << endl;
cout << "$$ Successfully read base flow " << endl;
cout << "$$ Ra = "<< Ra << " ; Pr = "<< Pr << " ; Qmag = "<< Qmag << endl;
cout << "$$" << endl;



IFMACRO(!SFWriteMode3D)
macro SFWriteMode3D(namefile,u,k,ev,shift,typeFlow,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
    	 p1forff2m<complex> vort1;  
    	 file << "### Data generated by Freefem++ ; " << endl;		 
 		 file << "3D Eigenmode for a 2D-Bousinesq problem (using GENERIC MACRO)" << endl;
 		 file << "datatype " << typeFlow << " datastoragemode CxP2P2P2P1P1 datadescriptors ux,uy,uz,p,T" << endl;
    	 string descriptionFF;
    	 descriptionFF="real* k complex* eigenvalue real* Ra real* Pr real* Qmag complex shift int iter P1c vort real AEnergy"; 
	     file << descriptionFF << endl << endl ; 
		 file << k << endl  << real(ev) << endl << imag(ev) << endl;
		 file << Ra  << endl << Pr << endl << Qmag << endl;
		 file << real(shift) << endl << imag(shift) << endl << iter << endl << endl;
 		vort1=-dy(u#x)+dx(u#y);
		for (int j=0;j<vort1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
		cout << "#### customisable output (standart case) : " << endl; 
		real AEnergyMode = sqrt(int2d(th)(abs(u#x)^2+abs(u#y)^2)); 
		cout << "#   Energy-Amplitude = " << AEnergyMode << endl;
		file << AEnergyMode << endl;
		};
//EOM	
ENDIFMACRO

IFMACRO(!SFWriteMode2D)
macro SFWriteMode2D(namefile,u,k,ev,shift,typeFlow,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
    	 p1forff2m<complex> vort1;  
    	 file << "### Data generated by Freefem++ ; " << endl;		 
 		 file << "2D Eigenmode for a 2D-Bousinesq problem (using GENERIC MACRO)" << endl;
 		 file << "datatype " << typeFlow << " datastoragemode CxP2P2P1P1 datadescriptors ux,uy,p,T" << endl;
    	 string descriptionFF;
    	 descriptionFF="real* k complex* eigenvalue real* Ra real* Pr real* Qmag complex shift int iter P1c vort real AEnergy"; 
	     file << descriptionFF << endl << endl ; 
	     file << k << endl  << real(ev) << endl << imag(ev) << endl;
		 file << Ra  << endl << Pr << endl << Qmag << endl;
		 file << real(shift) << endl << imag(shift) << endl << iter << endl << endl;
 		 vort1=-dy(u#x)+dx(u#y);
		 for (int j=0;j<vort1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
		cout << "#### customisable output (standart case) : " << endl; 
		real AEnergyMode = sqrt(int2d(th)(abs(u#x)^2+abs(u#y)^2+abs(u#z)^2)); 
		cout << "#   Energy-Amplitude = " << AEnergyMode << endl;
		file << AEnergyMode << endl;
		};
//EOM	
ENDIFMACRO

IFMACRO(!NormalizeMode)
macro NormalizeMode(u)
{
Mh normu = sqrt(abs(u#x)^2+abs(u#y)^2+abs(u#z)^2);
real NORM = normu[].max+1e-12;
u#x[] = u#x[]/NORM;
}
//EOM
ENDIFMACRO

IFMACRO(!BoundaryconditionsStability3D)
macro BoundaryconditionsStability3D(u,v,symmetry)
	on(21,u#x=0., u#y=0., u#z = 0., u#T = 0.) 
  + on(22,u#x=0., u#y=0., u#z = 0., u#T = 0.) 
  + on(5,u#x=0.)    
  + on(2,u#x=0., u#y=0., u#z = 0.)
//EOM
ENDIFMACRO




macro div(ik,u) (dx(u#x)+dy(u#y)+ik*u#z)
//EOM 

macro Grad(ik,u) [
			[dx(u#x), dy(u#x),  ik*u#x ], 
			[dx(u#y), dy(u#y),  ik*u#y ],
			[dx(u#z), dy(u#z),  ik*u#z ]
			]
//

macro Conv(ika,ua,ikb,ub,v)  
            (
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y
            + ((ub#x*dx(ua#z)+ub#y*dy(ua#z)))*v#z
            + ((ua#x*dx(ub#T)+ua#y*dy(ub#T))+(ub#x*dx(ua#T)+ub#y*dy(ua#T)))*v#T 
            ) 
// macro for mutual convection operator
            
            
macro D(ik,u) [	
				[dx(u#x), 				.5*(dx(u#y)+dy(u#x)),  .5*(ik*u#x+dx(u#z)) ], 
				[.5*(dx(u#y)+dy(u#x)), 	dy(u#y),				.5*(ik*u#y+dy(u#z))],
				[.5*(ik*u#x+dx(u#z)),  .5*(ik*u#y+dy(u#z)), ik*u#z]
				] 
//EOM macro for rate-of-deformation tensor



/////////////////////////////////////////////////////////////////////////////////
//////// varf for generalized eigenvalue problem: 

////////////////////////////////////////////////////////////////////////////////////
//real eps = 1e-12; // desingularisation term for matrix B, useful with some solvers

varf   LNSE (def(u),def(v)) =
   int2d(th)( 
   			-2*Pr*(D(1i*k,u):D(-1i*k,v))
   			-(dx(uT)*dx(vT)+dy(uT)*dy(vT)) 
             + up*div(-1i*k,v)
             + div(1i*k,u)*vp
             - Conv(1i*k,u,0,Ub,v)
             + Pr*Ra*uT*vy
             - Qmag*(ux*vx+uy*vy)
             )        
 + int2d(th)( -shift*(ux*vx+uy*vy+uz*vz+uT*vT) )
 + BoundaryconditionsStability3D(u,v,symmetry)
 ;




varf   LNSEadjoint (def(u),def(v)) =
   int2d(th)( 
   			-2*Pr*(D(1i*k,u):D(-1i*k,v))
   			-(dx(uT)*dx(vT)+dy(uT)*dy(vT))
           //  + up*vp*(eps) 
             + up*div(-1i*k,v)
             + div(1i*k,u)*vp
             - Conv(1i*k,v,0,Ub,u)
             + Pr*Ra*vT*uy
             - Qmag*(ux*vx+uy*vy)
             )
 + int2d(th)( -conj(shift)*(ux*vx+uy*vy+uz*vz+uT*vT) ) // warning that shift/eigenvalues of adjoint are complex conjugates of direct !
 + BoundaryconditionsStability3D(u,v,symmetry); 




////// BUILD B-MATRIX //////////////////////////////////////////////////////////////
	varf b(def(u),def(v)) = int2d(th)( (ux*vx+uy*vy+uz*vz+uT*vT) );
		matrix<complex> B= b(XXXMMh,XXXMMh,solver=CG);  //////// see freefem++doc.pdf for the solver 
////////////////////////////////////////////////////////////////////////////////////

matrix<complex> OP,OPA;
complex shiftOP,shiftOPA;

if(nev>1)
/// SOLUTION AND POSTPROCESSING FOR NEV>1 (built-in eigenvalue solver)

{
////// BUILD OP-MATRIX=A-lambda*B /////////////////////////////////
if(iadjoint=="D")
{ OP=LNSE(XXXMMh,XXXMMh,solver=sparsesolver); shiftOP = shift; }
else if(iadjoint=="A")
{ OP=LNSEadjoint(XXXMMh,XXXMMh,solver=sparsesolver); shiftOP = conj(shift); }
else if(iadjoint=="S") { cout << " WARNING : in this program option S will work only for nev=1" << endl; exit(-1);};

////////////////////////////////////////////////////////////////////////////////////


complex[int] ev(nev);                     ////// vector to store eigenvalues
XXXMMh<complex> [int] [eux,euy,euz,euT,eup](nev);   ////// vector to store EIGENVECTORS 

///////////////////// CALL TO ARPACK++ ////////////////////////////////// //////////
int kkkk=EigenValue(OP,B,sigma=shiftOP,value=ev,vector=eux,tol=1e-6,maxit=0,ncv=ncv);    //Arpack call
if(iadjoint=="A") { ev = conj(ev); } ;
////////////////////////////////////////////////////////////////////////////////////

	string namefile;
    namefile=ffdatadir+"Spectrum.txt";
    ofstream fileVP1(namefile); 
	
	for (int i=0;i<nev;i++)
	{
       fileVP1 << real(ev[i]) << " " << imag(ev[i]) << " " << Ra << " " << 0 << " " << real(shift) << " " << imag(shift) << endl;
       cout << " valeur propre : " << i+1 << "  : " << ev[i] << endl;
   		if(iadjoint=="D"){namefile=ffdatadir+"Eigenmode"+(i+1);}
 		else{namefile=ffdatadir+"EigenmodeA"+(i+1);};
 		ux[] = eux[i][]; 
 		NormalizeMode(u);
 		if(k!=0)
 		{ 
 		  ofstream fileMode(namefile+".txt");
 		  fileMode << ux[]; 
 		  fileMode << endl << endl << Ra << endl << endl << real(ev[i]) 
 		  		   << endl << imag(ev[i])  << endl;
 		 cout << "Writing 3D eigenmode in file " << namefile << endl;
 		 SFWriteMode3D(namefile+".ff2m",u,k,ev[i],shift,"EigenModeD",1);
 		}
 		else
 		{ 
 		  ofstream fileMode(namefile+".txt");
 		  XXMMh<complex> [u2x,u2y,u2p,u2T];
 		  [u2x,u2y,u2p,u2T] = [ux,uy,up,uT]; 
  	      fileMode << u2x[] ;	
 		  fileMode << endl << endl << Ra << endl << endl << real(ev[i]) 
 		  		   << endl << imag(ev[i])  << endl;
 		 cout << "Writing 2D eigenmode in file " << namefile << endl;
 		 SFWriteMode2D(namefile+".ff2m",u,k,ev[i],shift,"EigenModeD",1);
 		};  
 		 	 		
 		 
 		 
 		  
 	};
	cout << "it's done" << endl;
}

////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

else

/// SIMPLE SHIFT-INVERT IF ONLY ONE MODE IS RESQUESTED
{
XXXMMh<complex> [ux0,uy0,uz0,T0,p0],[uxdirect,uydirect,uzdirect,Tdirect,pdirect],[uxadjoint,uyadjoint,uzadjoint,Tadjoint,padjoint]; 

int testCB = exec("ls "+ffdatadir+"Eigenmode_guess.txt");
    	if (testCB!=0)
		{
		cout << "no file Eigenmode_guess.txt : strarting from arbitrary initial condition" << endl;
		[ux0,uy0,uz0,T0,p0] = [1,0,0,0,0];
		} 
		else
		{
		cout << "starting shift/invert from mode in file Eigenmode_guess.txt" << endl;
		ifstream cbin(ffdatadir+"Eigenmode_guess.txt");
		cbin >> ux0[];
		};


// selection of the computation to be performed : direct, adjoint or both
		
int directadjointA,directadjointB;
if(iadjoint=="D")
	{
	directadjointA = 1; directadjointB=1;
	cout << "Shift-invert algorithm for DIRECT problem" << endl;
	}
else if(iadjoint=="A")
	{
	directadjointA = 2; directadjointB=2;
	cout << "Shift-invert algorithm for ADJOINT problem" << endl;
	}
else if(iadjoint=="S")
	{
	directadjointA = 1; directadjointB=2;
	cout << "Shift-invert algorithm for BOTH DIRECT AND ADJOINT problem" << endl;
	};
	

// LOOP TO SELECT WHICH COMPUTATION WILL BE DONE 
	for(int directadjoint=directadjointA;directadjoint<directadjointB+1;directadjoint++)	
	{

	if(directadjoint==1)
	{
		cout << " Constructing operator for DIRECT problem ..." << endl;
		OP=LNSE(XXXMMh,XXXMMh,solver=sparsesolver);
		shiftOP = shift;
		cout << " solving DIRECT problem ..." << endl;
	}
	else if(directadjoint==2)
	{
		cout << " Constructing operator for ADJOINT problem ..." << endl;
		OP=LNSEadjoint(XXXMMh,XXXMMh,solver=sparsesolver);
		shiftOP = conj(shift);
		cout << "solving ADJOINT problem ..." << endl;
	};


	int itmax = 150;
	complex lambda0 = 1e6;
	real err = 1e6;
	real errmax=1e-6;
	complex lambda;
	
	varf brhs([ux,uy,uz,uT,up],[vx,vy,vz,vT,vp]) = int2d(th)( (ux0*vx+uy0*vy+uz0*vz+T0*vT) );
	set(OP,solver=sparsesolver);  //// factorize matrix
	
	/// ITERATION LOOP
	int iter;
	for (iter=0; ((err>errmax)&&(iter<itmax)); iter++)
	{
		//	complex[int] rhs = B*ux0[];
    	complex[int] rhs= brhs(0,XXXMMh);  //////// see freefem++doc.pdf for the solver 
		complex[int] w = OP^-1*rhs;
		ux[] = w;
	
		complex XnXn1 = int2d(th)(ux0*ux+uy0*uy+uz0*uz);
		complex Xn1Xn1 =  int2d(th)(ux*ux+uy*uy+uz*uz);
		complex GG = Xn1Xn1/XnXn1;
		// at each step the inverse shifted eigenval. is approximated by <X_{n+1}, Y> / <X_n, Y>
		//      ( the choice Y = X_{n+1} is convenient but we could choose something else )
		lambda = shiftOP+1/GG;
		err = abs(lambda-lambda0);
		cout << " iteration " << iter+1 << " : " << endl;	
		//	cout << " GG = " << GG << endl;
		//	cout << " XnXn = " << XnXn << endl;
		cout << " estimated eigenvalue lambda = " << lambda << endl;	
	
		ux0[] = 1/sqrt(abs(Xn1Xn1))*ux[];
		lambda0 = lambda;
	};
	/// END ITERATION LOOP	
	
	if(directadjoint==2){lambda=conj(lambda);};
 	// renormalization by MAXIMUM
 	Xh NormU = sqrt(abs(ux)^2+abs(uy)^2);
	ux[] = 1/NormU[].max*ux[];
	
	
	string namefile,namefileFF,descriptionFF,typeDA; 
	if(iter<itmax)
	
	// post-processing if iteration was successful
	{	
		real lambdar = real(lambda) ; real lambdai = imag(lambda);
    	if(directadjoint==1)
    	{
    		ofstream fileVP(ffdatadir+"Spectrum.txt");
    		fileVP << lambdar << " " << lambdai << " " << Ra <<  " " << real(shift) << " " << imag(shift) << endl;
    		namefile=ffdatadir+"Eigenmode.txt";
    		namefileFF=ffdatadir+"Eigenmode.ff2m";
    		typeDA = "D";
    		uxdirect[]=ux[];
    	};
    	
    	if(directadjoint==2)
    	{
    		ofstream fileVP(ffdatadir+"Spectrum.txt");
           	fileVP << lambdar << " " << lambdai << " " << Ra << " " << real(shift) << " " << imag(shift) << endl;
    		namefile=ffdatadir+"EigenmodeA.txt";
    		namefileFF=ffdatadir+"EigenmodeA.ff2m";	
    		typeDA = "A";
    		uxadjoint[]=ux[];
    	};
    
    // write outpout in .txt format (for freefem)
  if(k!=0)
  {
    ofstream file(namefile);
    NormalizeMode(u);
  	file << ux[] ;	
   	file << endl << endl << Ra << endl << Pr << endl
   	<< endl << lambdar << "   " << lambdai  << endl;
	SFWriteMode3D(namefileFF,u,k,lambda,shift,"EigenMode"+typeDA,iter);	 
  }
    else
  {
    ofstream file(namefile);
    XXMMh<complex> [u2x,u2y,u2p,u2T] = [ux,uy,up,uT]; 
  	file << u2x[] ;	
   	file << endl << endl << Ra << endl << Pr << endl
   	<< endl << lambdar << "   " << lambdai  << endl;
	SFWriteMode2D(namefileFF,u,k,lambda,shift,"EigenMode"+typeDA,iter);	 
  };	
	} // end of post processing of simple shift-invert case
else // case iteration failed
{
	cout << "$$ SHIFT-INVERT ITERATION FAILED" << endl;
	cout << "$$ Leaving FreeFem++ with error code 202" << endl;
	exit(202);
};

if (testCB==0)
		{
		exec("rm Eigenmode_guess.txt");// to be sure this file is not reused unless explicitly requested
		};


}; //end of loop for direct/adjoint/selection

if(iadjoint=="S")
//
{
cout << "Computation of sensitivity after direct and adjoint" << endl;

//	cout << "STAT" << uxdirect(2.5,.5) << " " << uxadjoint(2.5,.5) << " " << uydirect(2.5,.5) << " " << uyadjoint(2.5,.5) << endl ;

	fespace p2(th,P2);fespace p1(th,P1);
	p2 sensitivity = sqrt(abs(uxadjoint)^2+abs(uyadjoint)^2) * sqrt(abs(uxdirect)^2+abs(uydirect)^2);
	// at this stage [ux,uy,p] is the last computed, namely the adjoint eigenmode
	real norm = sensitivity[].max;
	sensitivity=1/norm*sensitivity;
		
	string namefile,namefileFF;
    namefile=ffdatadir+"Sensitivity.txt";
    {
    ofstream file(namefile);
  	file << sensitivity[] ;	
    }    
    namefileFF=ffdatadir+"Sensitivity.ff2m";
	p1 xx,yy,sensitivityP1;
	xx=x;
	yy=y;
    sensitivityP1 = sensitivity;
         {
         ofstream fileFF(namefileFF);
         fileFF << "### Data generated by Freefem++ ; " << endl;
         fileFF << "Sensitivity" << endl;
    	 fileFF << "Format :" << endl;
	     fileFF << "real* Ra  P1 sensitivity" << endl << endl ;
		 fileFF << Ra << endl ; //<< real(lambda) << endl << imag(lambdai) << endl;
		 for (int j=0;j<sensitivityP1[].n ; j++) fileFF << sensitivityP1[][j] << endl;
         };



}; // end of selection of mutliple mode (krylov) / single mode (simple shift-invert)



};

