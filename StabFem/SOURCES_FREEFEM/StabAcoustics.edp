//
//  PROGRAM Eigenvalue_Acoustics.edp
//  computation of a eigenvalue problem of linear acoustics problem for a single or multiple choices of omega
//
//	This solver uses the complex mapping ; 
//  The parameters of the complex mapping (ParamMap###) are defined in a file "Param_Mapping.edp" 
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	typecalc -> 'single', 'range', or 'array'
//	 	'single' -> omega (real) (in this case a structure field is produced)
//		'range' -> omegamin, omegastep, omegamax (real)
//		'array' -> user-defined range (complex) (N, omega1, sigma1, omega2, sigma2, ....)
//
//	INPUT FILES :
//		BaseFlow.txt		-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//
//  OUTPUT FILES :
//		Impedance.ff2m -> formatted file, structure defined in macro
//		Impedance_Chi##_Re###.txt 
//
// 	ERROR MANAGEMENT : 
//
//  First version : sometime around 2014 ; Redesigned and incorporated in the project in september 2018.

cout << "$$$$ ENTERING StabAcoustics.edp " << endl << "$$" << endl; 

cout << " TO BE DDEBUGGED SOMEDAY !" << endl;

include "StabFem.idp";

IFMACRO(!JJ)
macro JJ 1 //EOM
ENDIFMACRO

IFMACRO(!Dx)
macro Dx(a) dx(a) //EOM
ENDIFMACRO

IFMACRO(!Xphys)
macro Xphys(x,y,a) x //EOM
ENDIFMACRO

IFMACRO(!Dy)
macro Dy(a) dy(a) //EOM
ENDIFMACRO



int NNN = 10000;	
string typecalc; 
int nev;
complex shift;
real shiftr, shifti;
complex[int] omegaarray(NNN);
string boundaryCondition;
	
cout << "$$ ENTERING Function LinearForcedAcoustic.edp" << endl;
cout << "$$ Selection of parameters : " << endl;

cout << "Enter the type of boundary condition (SOMMERFELD,CM,PML) : " << endl;
cin >> boundaryCondition; 

cout << "Introduce the real part of the shift : " << endl;
cin >> shiftr; 

cout << "Introduce the imaginary part of the shift : " << endl;
cin >> shifti; 

shift = shiftr+1i*shifti;

cout << "Introduce the number of eigenvalues to compute : " << endl;
cin >> nev; 


mesh th= readmesh(ffdatadir+"mesh.msh");

real rho = 1;
real c = 1;
real Sin = int1d(th,1)(2*pi*x); // surface d'entr??e
//real Z0 = rho*c/Sin;// impedance carateristique du tuyau

complex Qin ;
//real k; // nombre d'onde k=omega*c0
		    
fespace VH(th,P2);
fespace VH2(th,[P2,P2]);

VH<complex> f0,f,fk,f1,fk1,ftrace;
VH fr,fi,ft,fabs;
    


IFMACRO(!SFWriteForced)
macro SFWriteForced(namefile,f,ev)
         {
         ofstream file(namefile);
         fespace p1forff2m(th,P1); 
         p1forff2m xx,yy;
         xx=x;
         yy=y;
         complex KK = ev/1i;
         p1forff2m<complex> phi = f;
         file << "### Data generated by Freefem++ ; " << endl;
         file << "FORCED LINEAR RESPONSE for an axisymmetric acoustic problem" << endl;
         file << "datatype " << "ForcedFlow" << " datastoragemode CxP2 " << endl;
         string descriptionFF;
         descriptionFF="complex Lambda P1c phi complex Z "; 
         file << descriptionFF << endl << endl ; 
         file << real(ev) << endl << imag(ev) << endl << endl;
         for (int j=0;j<phi[].n ; j++) file << real(phi[][j]) << endl << imag(phi[][j]) << endl;        
         complex Rate = 2*pi*int1d(th,1)(dy(f)*y);
         complex Force = 2*pi*int1d(th,1)(y*1i*k*f);
         complex pin = Force/(2*pi*int1d(th,1)(y)); 
         complex ZZ = (pin/Rate);
         file << real(ZZ) << endl << imag(ZZ) << endl;  
         }
//EOM   
ENDIFMACRO

IFMACRO(!NormalizeMode)
macro NormalizeMode(u)
{
real NORM = int2d(th)(abs(u));
u[] = u[]/NORM;
}
//EOM
ENDIFMACRO

IFMACRO(!SFWriteMode)
macro SFWriteMode(namefile,f,k,shift,iter)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
		 p1forff2m xx,yy;
		 xx=x;
		 yy=y;
    	p1forff2m<complex> phiC,pC,uzC,urC;
        phiC = f; 
        pC = 1i*k*f;
        uzC = dy(f);
        urC = dx(f);	 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "AcousticField" << endl;
    	 file << "Format :" << endl;
    	 string descriptionFF;
    	 descriptionFF="complex k complex shift int iter P1c Phi P1c p P1c uz P1c ur"; 
	     file << descriptionFF << endl << endl ; 
		 file << real(k) << endl << imag(k) << endl << real(shift) << endl << imag(shift) << endl << iter << endl << endl;
		for (int j=0;j<phiC[].n ; j++) 
            {  file << real(phiC[][j]) << endl << imag(phiC[][j]) << endl; };
        for (int j=0;j<phiC[].n ; j++) 
            {  file << real(pC[][j]) << endl << imag(pC[][j]) << endl; };
        for (int j=0;j<phiC[].n ; j++) 
            {  file << real(uzC[][j]) << endl << imag(uzC[][j]) << endl; };
        for (int j=0;j<phiC[].n ; j++) 
            {  file << real(urC[][j]) << endl << imag(urC[][j]) << endl; };
		file << endl;
		file << endl;
        } 
//EOM	
//EOM
ENDIFMACRO	

int isshift=1; 
IFMACRO(EIGENSOLVER,SLEPC)
if(nev>1) {isshift=0;}; // WARNING the shift should be incorporated in the operator for simple shift-invert and Arpack, but not when using SLEPc !
ENDIFMACRO

varf   HelmholtzSOMMERFELD([f1,f2],[fa1,fa2]) =
     int2d(th)( (-(dx(f1)*dx(fa1)+dy(f1)*dy(fa1)))*2*pi*x ) // - grad (phi) * grad(phi1) dV 
   + int2d(th)(  f2*fa2*2*pi*x ) // - grad (phi) * grad(phi1) dV 
   + int1d(th,3)((-1i*f2-f1/sqrt(x^2+y^2))*fa1*2*pi*x) // condition de sortie de Sommerfeld (a utiliser pour les tuyaux)
   + int2d(th)( isshift*shift*(-f2*fa1)*2*pi*x )
   + int2d(th)( isshift*shift*(f1*fa2)*2*pi*x )
	  ;

varf   HelmholtzCM(f,f1) =
     int2d(th)( JJ*(-(Dx(f)*Dx(f1)+Dy(f)*Dy(f1)))*2*pi*Xphys(x,y,ParamMap) ) // - grad (phi) * grad(phi1) dV 
   + int2d(th)( isshift*shift^2*(f*f1)*2*pi*Xphys(x,y,ParamMap)*JJ )
	  ;

////// BUILD B-MATRIX 
varf b([f1,f2],[fa1,fa2]) = int2d(th)( (f2*fa1 - f1*fa2 )*2*pi*x  );
varf bCM(f,f1) = int2d(th)( -(f*f1)*2*pi*Xphys(x,y,ParamMap)*JJ );





matrix<complex> OP,OPA,B;
complex shiftOP,shiftOPA;



////////////////////////////////////////////////////////////////////////////////////
////////    ---> 1. Solution in ARPACK MODE  (nev>1).   			<--- ///////////
////////////////////////////////////////////////////////////////////////////////////

if(nev>1)
{

////// BUILD OP-MATRIX=A-lambda*B 
complex[int] ev(nev);        ////// vector to store eigenvalues
VH2<complex> [int] [efS,efSk](nev);   ////// vector to store EIGENVECTORS of SOMMERFELD
VH<complex> [int] ef(nev);   ////// vector to store EIGENVECTORS of CM

if (boundaryCondition == "SOMMERFELD")
{
	OP=HelmholtzSOMMERFELD(VH2,VH2);
	B= b(VH2,VH2);  //////// see freefem++doc.pdf for the solver 
	// Shift
	shiftOP = shift;
}
else if (boundaryCondition == "CM")
{
	OP=HelmholtzCM(VH,VH);
	B= bCM(VH,VH);  //////// see freefem++doc.pdf for the solver 
	// Shift 
	shiftOP = shift^2;
}
else
{
	cout << "No boundary condition implemented with this name. End of program." << endl;
}

cout << "shiftOP : " << shiftOP << endl;



///////////////////// CALL TO ARPACK++ 
int ncv = 4*nev;   ///// Krylov Basis

IFMACRO(EIGENSOLVER,ARPACK)
set(OP,solver=sparsesolver);  //// factorize matrix
set(B,solver=CG);  //// factorize matrix
if(boundaryCondition=="CM")
	k=EigenValue(OP,B,sigma=shiftOP,value=ev,vector=ef,tol=1e-6,maxit=0,ncv=ncv);    //Arpack call
else
	k=EigenValue(OP,B,sigma=shiftOP,value=ev,vector=efS,tol=1e-6,maxit=0,ncv=ncv);    //Arpack call
ENDIFMACRO
////////////////////////////////////////////////////////////////////////////////////


///////////////////// OR CALL TO SLEPC ////////////////////////////////// //////////

IFMACRO(EIGENSOLVER,SLEPC)
	cout << "SOLVING EIGENVALUE PROBLEM WITH SLEPC" << endl;
	/***************************************/
	/*      Build distributed matrices     */
	/***************************************/
	int[int] arrayIntersection;                 // Rank of neighborings subdomains
    int[int][int] restrictionIntersection(0);   // Local-to-neighbors renumbering
    real[int] D1(OP.n);
    D1.resize(OP.n);
    D1 = 1;
	Mat<complex> DistA(OP, arrayIntersection, restrictionIntersection, D1, clean = true);
	Mat<complex> DistB(DistA, B, clean = true);

	string ssparams =            /* Parameters for the distributed EigenValue solver */
	  " -eps_nev " + nev       + /* Number of eigenvalues */
	  " -eps_type krylovschur" +
	  /*" -eps_interval -0.2,0.05" + */
	  " -eps_target " + shiftOP +
	  /*" -eps_harmonic " + */
	  " -st_type cayley "     +
	  /*" -st_type cayley_antishift "     +
	  " -st_pc_type cholesky " +
	  " -st_pc_factor_mat_solver_type superlu_dist " +
	  " -st_ksp_type preonly " +
	  " -mat_superlu_dist_rowperm NATURAL " +*/
	  " -st_pc_type lu "       +
	  " -st_pc_factor_mat_solver_package mumps" +
	  " -eps_view"             +
	  " -eps_gen_non_hermitian"      /* The problem is generalized non hermitian */
	;


	/* ///////////////////// CALL TO SLEPC /////////////////////////////////////////////////// */
	if(boundaryCondition=="CM")
	{
		int k = EPSSolve
		(DistA,              /* matrix OP = A ??? sigma*B */
		 DistB,              
		 vectors = ef, /* Array to store the FEM-EigenFunctions*/
		 values  = ev, /* Array to store the EigenValues */
		 sparams = ssparams  /* Parameters for the distributed EigenValue solver */
		);
		k=min(k,nev); /* some time the number of converged eigen value can be greater than Nev; */
	}
	else
	{
		int k = EPSSolve
		(DistA,              /* matrix OP = A ??? sigma*B */
		 DistB,              
		 vectors = efS, /* Array to store the FEM-EigenFunctions*/
		 values  = ev, /* Array to store the EigenValues */
		 sparams = ssparams  /* Parameters for the distributed EigenValue solver */
		);
		k=min(k,nev); /* some time the number of converged eigen value can be greater than Nev; */
	}

	
ENDIFMACRO


//// POSTPROCESSING

	string namefile;
    namefile=ffdatadir+"Spectrum.txt";
    ofstream fileVP1(namefile); 
	
	for (int i=0;i<nev;i++)
	{
	   // If CM computed value is omega^2/c_0^2 so let's sqrt otherwise is omega/c_0
	   if(boundaryCondition=="CM") ev[i] = sqrt(ev[i]);
       fileVP1 << real(ev[i]) << " " << imag(ev[i])  << " " << " " << real(shift) << " " << imag(shift) << endl;
        cout << "$$ Valeur propre : " << i+1 << "  : " << ev[i] << endl;

 		 {namefile=ffdatadir+"Eigenmode"+(i+1);}
 		 if(boundaryCondition=="CM") f = ef[i];
 		 else f = efS[i];
 		 	
 		  {
 		  ofstream fileMode(namefile+".txt");
 		  fileMode << f[]; 
 		  fileMode << endl << endl << real(ev[i]) << endl << imag(ev[i])  << endl;
 		  }
 		 cout << "$$ Writing eigenmode in file " << namefile << endl;
 		 SFWriteMode(namefile+".ff2m",f,ev[i],shift,1);
 		IFMACRO(FREEFEMPLOTS,YES)
		plot(f,cmm="Structure of forced flow for k = "+k,wait=1,fill=1);
		ENDIFMACRO
 		 
 	};
}


////////////////////////////////////////////////////////////////////////////////////
////////    ---> 2. Solution in SHIFT-INVERT MODE (nev = 1) 		<--- ///////////
////////////////////////////////////////////////////////////////////////////////////


else

/// SIMPLE SHIFT-INVERT IF ONLY ONE MODE IS RESQUESTED
{
		
	int testCB = exec("ls "+ffdatadir+"/Eigenmode_guess.txt");
	varf brhs(f,f1) = int2d(th)( -(f0*f1) );
	if (testCB!=0)
	{
		cout << "$$ No file Eigenmode_guess.txt : strarting from arbitrary initial condition" << endl;
		f0 = 0.01;
	} 
	else
	{
		cout << "$$ Starting shift/invert from mode in file Eigenmode_guess.txt" << endl;
		ifstream cbin(ffdatadir+"Eigenmode_guess.txt");
		cbin >> f0[];
	};

	if (boundaryCondition == "SOMMERFELD")
	{
		OP=HelmholtzSOMMERFELD(VH,VH,solver=sparsesolver);
		varf brhs(f,f1) = int2d(th)( -(f0*f1) );
	}
	else if (boundaryCondition == "CM")
	{
		OP=HelmholtzCM(VH,VH,solver=sparsesolver);
		varf brhs(f,f1) = int2d(th)( -(f0*f1)*JJ );
	}
	else
	{
		cout << "No boundary condition implemented with this name. End of program." << endl;
	}

	shiftOP = shift;
	int itmax = 50;
	complex lambda0 = 1e6;
	real err = 1e6;
	real errmax=1e-6;
	complex lambda;
	
	

	set(OP,solver=sparsesolver);  //// factorize matrix
	
	/// ITERATION LOOP
	int iter;
	for (iter=0; ((err>errmax)&&(iter<itmax)); iter++)
	{
    	complex[int] rhs= brhs(0,VH);  //////// see freefem++doc.pdf for the solver 
		complex[int] w  = OP^-1*rhs;
		f[] = w;
		complex XnXn1 = int2d(th)(f0*f);
		complex Xn1Xn1 =  int2d(th)(f*f);
		complex GG = Xn1Xn1/XnXn1;
		// at each step the inverse shifted eigenval. is approximated by <X_{n+1}, Y> / <X_n, Y>
		//      ( the choice Y = X_{n+1} is convenient but we could choose something else )
		lambda = shiftOP+1/GG;
		err = abs(lambda-lambda0);
		cout << "$$ Iteration " << iter+1 << " : " << endl;	
		cout << "$$ Estimated eigenvalue lambda = " << lambda << endl;	
		f0[] = 1/sqrt(abs(Xn1Xn1))*f[];
		lambda0 = lambda;
	};
	/// END ITERATION LOOP	
 	// renormalization 
	NormalizeMode(f);
	
	string namefile,namefileFF,descriptionFF,typeDA; 
	if(iter<itmax)
	
	// post-processing if iteration was successful
	{	
		real lambdar = real(lambda) ; real lambdai = imag(lambda);
		ofstream fileVP(ffdatadir+"Spectrum.txt");
		fileVP << lambdar << " " << lambdai <<  " " << real(shift) << " " << imag(shift) << endl;
		namefile=ffdatadir+"Eigenmode.txt";
		namefileFF=ffdatadir+"Eigenmode.ff2m";
		typeDA = "D";
    // write outpout in .txt format (for freefem)
    {
	    ofstream file(namefile);
	  	file << f[] ;	
	   	file << endl << endl << lambdar << "   " << lambdai  << endl;
    }

    // write output in .dff.2m format (for StabFem)
	SFWriteMode(namefileFF,f,lambda,shift,iter);	 // MACRO DEFINED in StabFem_Macros.edp
	
	} // end of post processing of simple shift-invert case
	else // case iteration failed
	{
	cout << "$$ SHIFT-INVERT ITERATION FAILED" << endl;
	cout << "$$ Leaving FreeFem++ with error code 202" << endl;
	exit(202);
	};

	if (testCB==0)
	{
		exec("rm Eigenmode_guess.txt");// to be sure this file is not reused unless explicitly requested
	};

}; // end of selection of mutliple mode (krylov) / single mode (simple shift-invert)

// end Loop



cout << "$$$$ LEAVING LoopImpedance.edp " << endl << "$$" << endl; 
	
	
