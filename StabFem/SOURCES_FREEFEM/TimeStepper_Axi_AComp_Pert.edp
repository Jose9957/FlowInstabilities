//
//	Time-stepper for axisymmetric Navier-Stokes equations 
//
// Program recovered from B. Fry's version Init_Axi_BirdCall.edp (which originates from older version by DF)


// INCLUDES

include "StabFem.idp";
//////////////////////////////////////////////////////////////////////////////////

macro Jac() 2*pi*y // EOM

IFMACRO(!SFWriteDNSField)	
macro SFWriteDNSField(filename,u,up,typeFlow,iter,tps)
{
	fespace p1forff2m(th,P1);  
    p1forff2m vort,testfunction;
	solve CalcVort(vort,testfunction)
		= int2d(th)(vort*testfunction) - int2d(th)(testfunction*(dx(u#y)-dy(u#x)));
	ofstream file(filename);
   	{
		file << "### Data generated by Freefem++ ; " << endl;
    	file << "DNS Snapshot for a 2D-incompressible problem " << endl;
    	file << "datatype DNSField datastoragemode ReP2P2P1 " << endl;
		file << "real* Re real* t int* it P1 vort" << endl ; 
		file << Re << endl;
    	file << tps << endl;
		file << iter << endl;
		for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
		};
}
//EOM
ENDIFMACRO		
		
IFMACRO(!DNSTimeStatisticsINIT)
macro DNSTimeStatisticsINIT(namefile)
{
    ofstream fileforces(namefile+".txt");
    ofstream file(namefile+".ff2m");
    file << "### Data generated by Freefem++ ; " << endl;
    file << "DNS Time-series of a 2D-incompressible problem " << endl;
    file << "datatype TimeStatistics datastoragemode columns datadescriptors t,Energy,Qcav,Pcav,cfl,iter" << endl;
}
//EOM
ENDIFMACRO

IFMACRO(!DNSTimeStatistics)
macro DNSTimeStatistics(namefile,uDNS,t,iter)
{		
	fespace p1forff2m(th,P1); 
	real Energie = int2d(th)((uDNS#x)^2+uDNS#y^2);
	p1forff2m  cfl=sqrt(uDNS#x^2+uDNS#y^2)*dt/hTriangle; 
	real cflmax = cfl[].max;		
	real Fx = int1d(th,2)(Jac*u#p*N.x)-nu*int1d(th,2)( Jac*(2*dx(u#x)*N.x+(dx(u#y)+dy(u#x))*N.y));
	real Fy = int1d(th,2)(Jac*u#p*N.y)-nu*int1d(th,2)( Jac*(2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x));
	ofstream fileforces(namefile+".txt",append);
	fileforces << tps << " " << Fx << " " << Fy << " " << Energie  << " " << cflmax << " " << iter << endl;
}
//EOM	
ENDIFMACRO

IFMACRO(!MESHCavity)
macro MESHCavity()
{
border cavityUP(t=Xdown +Rdown*cos(Tmaxdown),Xup + Rup*cos(Tmaxup) +Thick){x=t;y=Rcav;label=21;};
mesh th2 = buildmesh (cavityUP(Ninit*(Xdown +Rdown*cos(Tmaxdown)-Xup-Rup*cos(Tmaxup)-Thick),fixedborder =true ,nbvx=1e5);
mesh sh = emptymesh (th2); 
fespace XRh (sh,[P1b, P1b]);
} // EOM
ENDIFMACRO


/*=============================================
=            Physical constants              =
=============================================*/

real Re,Reans,nu,gamma,coeffComp;
real dt,tps;

/*=============================================
=            Solver parameters               =
=============================================*/

real alpha0,alpha1,alpha2,alpha3;
real beta0,beta1,beta2;
real Pcav,Pcavp,Qcav,Qcavp; // Model of the cavity
real Pin,Pinp,Qin,Qinp; // Model of the inflow impedance
real Pout,Poutp,Qout,Qoutp,Qoutpp,DQout,DQoutp,DQoutpp; // Model of the radiation at the outflow
real Ma,Vcav,Vin,Xccav,Xcin;
int rep,itmax,iout,iviewcfl=1.0,istat,iwrite;


real Pcavi, Qcavi; // Previous states in the inner iteration;
real outerFlux,outerArea,outerUy;
real Scavity;
real Vcavity;
real Uycav;
real bcactive;

/*=============================================
=            MESH AND FEM SPACES             =
=============================================*/

mesh th=readmesh(ffdatadir+"mesh.msh");
fespace XH2(th,P2);
fespace XH(th,P1);
fespace XXxH(th,[P2,P2,P1]);

macro Nx() (-N.x) //EOM
macro Ny() (-N.y) //EOM

IFMACRO(!PinCavity)
macro PinCavity() Pcav //EOM
ENDIFMACRO

IFMACRO(!Pinlet)
macro Pinlet() Pin //EOM
ENDIFMACRO

IFMACRO(!Poutlet)
macro Poutlet() Pout //EOM
ENDIFMACRO

IFMACRO(!UyinCavity)
macro UyinCavity() (Qcav/SResonator)*(N.x+N.y) //EOM
ENDIFMACRO



IFMACRO(!Uinlet)
macro Uinlet  Rhole^2/Rin^2  // EOM
// EOM
ENDIFMACRO

IFMACRO(!Vinlet)
macro Vinlet  0.0  // EOM
// EOM
ENDIFMACRO

IFMACRO(!hResonator)
macro hResonator int1d(th,21)(1.0)
// EOM
ENDIFMACRO

IFMACRO(!SResonator)
macro SResonator int1d(th,21)(Jac)
// EOM
ENDIFMACRO

IFMACRO(!hResonatorIN)
macro hResonatorIN() (int1d(th,1)(1.0)+int1d(th,11)(1.0))
// EOM
ENDIFMACRO

IFMACRO(!hLength)
macro hLength(val) (int1d(th,val)(1.0))
// EOM
ENDIFMACRO

IFMACRO(!hSurface)
macro hSurface(val) (int1d(th,val)(Jac))
// EOM
ENDIFMACRO

IFMACRO(!SLength)
macro SLength(val) (hSurface(val)/hLength(val))
// EOM
ENDIFMACRO

IFMACRO(!SResonatorIN)
macro SResonatorIN() (int1d(th,1)(Jac)+int1d(th,11)(Jac))
// EOM
ENDIFMACRO

IFMACRO(!hResonatorOUT)
macro hResonatorOUT() (int1d(th,3)(1.0)+int1d(th,31)(1.0))
// EOM
ENDIFMACRO

IFMACRO(!SResonatorOUT)
macro SResonatorOUT() (int1d(th,3)(Jac)+int1d(th,31)(Jac))
// EOM
ENDIFMACRO



IFMACRO(!FlowRate)
macro FlowRate(valbnd,u) (int1d(th,valbnd)(Jac*(u#x*Nx+u#y*Ny)))
// EOM
ENDIFMACRO
/*=============================================
=            INPUT/OUTPUT                    =
=============================================*/

cout << "###" << endl <<  "### GENERIC TIME STEPPER for a 2D INCOMPRESSIBLE FLOW " << endl << "###" << endl;
cout << "### Uzawa method with Cahouet preconditionners " << endl << "###" << endl;
cout << "### Code written by J. Sierra & D. Fabre " << endl << "###" << endl << endl;
cout << "Enter Re >> ";
cin >> Re;			
cout << Re << endl;
cout << "Enter initial instant : (0 means start from base flow or base flow + eigemode) >> " ;
cin >> rep;	
cout << rep << endl;
cout << "Enter itmax >> ";
cin >> itmax;
cout << itmax << endl;	
cout << "Enter dt >> ";
cin >> dt;	
cout << dt << endl;
cout << " Enter iout (to produce snapshots each iout timesteps) >> ";
cin >> iout;
cout << iout << endl;
cout << " Enter istat (to produce statistics each istat timesteps) >> ";
cin >> istat;
cout << istat << endl;
cout << " Enter Mach number >> ";
cin >> Ma;
cout << Ma << endl;
cout << " Enter the volume of the cavity >> ";
cin >> Vcav;
cout << Vcav << endl;
cout << " Enter the volume of the inlet impedance >> ";
cin >> Vin;
cout << Vin << endl;

//////////////////////////////////
/////    Model parameters   //////
//////////////////////////////////

nu=1./Re;
Xccav = 1.0/(Vcav*Ma^2);
Xcin = 1.0/(Vin*Ma^2);
gamma=1.4;
coeffComp=1.0;


//////////////////////////////////
/////  Fluid field variables //////
//////////////////////////////////

XXxH [upx,upy,upp];
XXxH [uppx,uppy,uppp];
XXxH [upppx,upppy,upppp];

XXxH [ux,uy,up];
XXxH [uxb,uyb,upb]; 
XXxH<complex> [uMx,uMy,uMp];
XH2 ubx,uby;

XXxH [rhsux,rhsuy,rhsup];

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//
///////////////////// Macros of differential operators //////////////////////////

macro div(u) (dx(u#x)+dy(u#y)+u#y/y) // macro for divergence 
macro Convx(uax,uay,ub,v) ( (uax*dx(ub#x)+uay*dy(ub#x))*v) // EOM
macro Convy(uax,uay,ub,v) ( (uax*dx(ub#y)+uay*dy(ub#y))*v) // EOM
macro GradGrad(u,v) (dx(u)*dx(v) + dy(u)*dy(v)) //EOM
macro InnerProd(u,v) (u#x*v#x + u#y*v#y) //EOM
macro recons(u1,u2) [beta0*u1#x + beta1*u2#x, beta0*u1#y + beta1*u2#y]//EOM
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x)) ], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor
macro Conv(ua,ub,v) ( 
              ((uxb*dx(ub#x)+uyb*dy(ub#x))+(ub#x*dx(uxb)+ub#y*dy(uxb)))*v#x 
            + ((uxb*dx(ub#y)+uyb*dy(ub#y))+(ub#x*dx(uyb)+ub#y*dy(uyb)))*v#y 
                    ) // macro for mutual convection operator

//////////////////////////////////////////////////////////////////////////////////

IFMACRO(!BoundaryconditionsDNSAxi)
	macro BoundaryconditionsDNSAxi(u,v)
	     on(1,u#y=0.0)
	    + on(11,u#x=0.0) 
		+ on(2,22,23,u#x=0.0,u#y=0.0)
	    + on(21,u#x=0) 
	    + on(3,u#y=0) + on(31,u#x=0) 
		+ on(5,u#x=0.0)+on(4,u#y=0)
		+ on(6,u#y=0.0)      
	//EOM
ENDIFMACRO


varf  NS ([ux,uy,up],[vx,vy,vp])=
	int2d(th)(
	Jac*(
	  alpha0*InnerProd(u,v)/dt
	- up*div(v)
	+ 2*nu*(D(u):D(v))  
	+ Conv(ub,u,v)
	+ vp*(div(u))
	) )
	+ BoundaryconditionsDNSAxi(u,v)
	
	- int1d(th,21)(bcactive*(Jac*hSurface(21)*Xccav)*vy*N.y*(ux*Nx+uy*Ny)*dt) // uy because normal is vertical 
	- int1d(th,11)(bcactive*(Jac*hSurface(11)*Xcin)*vy*N.y*(ux*Nx+uy*Ny)*dt) 
	- int1d(th,1)(bcactive*(Jac*hSurface(1)*Xcin)*vx*N.x*(ux*Nx+uy*Ny)*dt)
	- int1d(th,3)(bcactive*(Jac*Ma/8.0*hSurface(3)*vx*N.x)*(ux*Nx+uy*Ny)/dt^2)
	- int1d(th,31)(bcactive*(Jac*Ma/8.0*hSurface(31)*vy*N.y)*(ux*Nx+uy*Ny)/dt^2) 
	/* Viscous term Int by Parts */
	- int1d(th,21)(bcactive*Jac*2*nu*((D(u)*[N.x,N.y])'*[vx,vy]))
 	- int1d(th,11)(bcactive*Jac*2*nu*((D(u)*[N.x,N.y])'*[vx,vy]))
 	- int1d(th,1)(bcactive*Jac*2*nu*((D(u)*[N.x,N.y])'*[vx,vy]))
 	- int1d(th,3)(bcactive*Jac*2*nu*((D(u)*[N.x,N.y])'*[vx,vy]))
 	- int1d(th,31)(bcactive*Jac*2*nu*((D(u)*[N.x,N.y])'*[vx,vy]))
	
	;

varf CONVECT ([ux,uy,up],[vx,vy,vp])=
	-int2d(th) (   Jac*(vx/dt)*(alpha1*convect(recons(up,upp),-dt,upx) + alpha2*convect(recons(up,upp),-2*dt,uppx)) )
	-int2d(th) (   Jac*(vy/dt)*(alpha1*convect(recons(up,upp),-dt,upy) + alpha2*convect(recons(up,upp),-2*dt,uppy))  )
	+ BoundaryconditionsDNSAxi(u,v)
	
	- int1d(th,21)(bcactive*Jac*Pcav*vy*N.y)
	- int1d(th,11)(bcactive*Jac*Pin*vy*N.y)
	- int1d(th,1)(bcactive*Jac*Pin*vx*N.x)
	- int1d(th,3)(bcactive*(2*Jac*Ma/8.0*hSurface(3)*vx*N.x)*(upx*Nx+upy*Ny)/dt^2)
	+ int1d(th,3)(bcactive*(Jac*Ma/8.0*hSurface(3)*vx*N.x)*(uppx*Nx+uppy*Ny)/dt^2)
	- int1d(th,31)(bcactive*(2*Jac*Ma/8.0*hSurface(31)*vy*N.y)*(upx*Nx+upy*Ny)/dt^2)
	+ int1d(th,31)(bcactive*(Jac*Ma/8.0*hSurface(31)*vy*N.y)*(uppx*Nx+uppy*Ny)/dt^2)
	;

	/* // Fully Explicit
	- int1d(th,21)(bcactive*Jac*vy*N.y*(Pcav-dt*Xccav*Qcav))

	- int1d(th,11)(bcactive*Jac*vy*N.y*(Pin-dt*Xcin*Qin))
	- int1d(th,1)(bcactive*Jac*vx*N.x*(Pin-dt*Xcin*Qin))
	
	- int1d(th,3)(bcactive*(Jac*vx*N.x)*((Ma/8.0)*(Qout-2*Qoutp+Qoutpp)/dt^2) )
	- int1d(th,31)(bcactive*(Jac*vy*N.y)*((Ma/8.0)*(Qout-2*Qoutp+Qoutpp)/dt^2) )
	*/

		/* Impose constant P=+0.001 (positive!)  at the inlet 
	- int1d(th,1)(Jac*bcactive*vx*N.x*0.001)
	- int1d(th,11)(Jac*bcactive*vy*N.y*0.001)
    */




DNSTimeStatisticsINIT(ffdatadir+"dns_Stats")
		
//////////////////////////////////
/////   Baseflow solution    /////
//////////////////////////////////			

cout << "--> Reading baseflow solution" << endl;
{
	ifstream file(ffdatadir+"baseflow_dns.txt");
	file >> uxb[];
	file >> Reans;
};

//////////////////////////////////
/////  Initial condition     /////
//////////////////////////////////

if(rep==0) // starting from a given initial condition
{  
	ifstream file(ffdatadir+"dnsfield_start.txt");
	file >> uMx[];
	[ux,uy,up] = [real(uMx),real(uMy),real(uMp)] ; 
	[upx,upy,upp] = [ux*cos(-dt),uy*cos(-dt),up*cos(-dt)]; // Restart previous time step
	[uppx,uppy,uppp] = [ux*cos(-2*dt),uy*cos(-2*dt),up*cos(-2*dt)]; // Restart previous time step
    tps = 0;
}
else // Starting from previous solution. Restart
{
	ifstream file(ffdatadir+"dnsfield_"+rep+".txt");
	file >> ux[];
	file >> Reans;
	file >> Qin;
	file >> Pin;
	file >> Qcav;
	file >> Pcav;
	file >> Pout;
	file >> Qout;
	file >> Qoutp;
	file >> Qoutpp;
	file >> DQout;
	file >> DQoutp;
	file >> DQoutpp;
	file >> tps;
	cout << "Starting from previous field for it= " << rep << " ; tps = " << tps << endl; 

	int testCB;
	SFcheckfile("dnsfield_"+(rep-1)+".txt",testCB);
	if (testCB==-1)
	{
		cout << "$$ No file for the previous time step" << endl;
		[upx,upy,upp] = [ux*cos(-dt),uy*cos(-dt),up*cos(-dt)]; // Restart previous time step
	} 
	else
	{
		cout << "$$ Reading the previous time step " << endl;
		ifstream file(ffdatadir+"dnsfield_"+(rep-1)+".txt");
		file >> upx[];
	};

	testCB;
	SFcheckfile("dnsfield_"+(rep-2)+".txt",testCB);
	if (testCB==-1)
	{
		cout << "$$ No file for the t=(t-2*dt) time step" << endl;
		[uppx,uppy,uppp] = [ux*cos(-2*dt),uy*cos(-2*dt),up*cos(-2*dt)]; // Restart previous time step
	} 
	else
	{
		cout << "$$ Reading the t-2*dt " << endl;
		ifstream file(ffdatadir+"dnsfield_"+(rep-2)+".txt");
		file >> uppx[];
	};
};
	  
alpha0=1.5; alpha1=-2.; alpha2=0.5; beta0=2; beta1=-1; // coeffs for order 2 
matrix NSMAT=NS(XXxH,XXxH,solver=sparsesolver,tgv=-1);

/////////////////////////////////////////////
///////////   Time loop         /////////////
/////////////////////////////////////////////

// First iteration model deactivated
bcactive=0;
int itstartModel = 5;
for (int it=rep+1;it<=itmax;it++)
{
	if(it == rep + itstartModel)
	{
		bcactive = 1.0;
		NSMAT=NS(XXxH,XXxH,solver=sparsesolver,tgv=-1);
		cout << " Model is activated " << endl;
	} 

	// Previous time-steps
	upppx[]=uppx[];
	uppx[]=upx[];
	upx[]=ux[];
	rhsux[]=CONVECT(0,XXxH,tgv=-1);
	ux[] = NSMAT^-1*rhsux[];


	Qin = FlowRate(1,u)+FlowRate(11,u); // Qin
	Qout = FlowRate(3,u) + FlowRate(31,u); // Qout extrapolated
	Qcav = FlowRate(21,u); // Qcav

	cout << " Pout imposed " <<   -int1d(th,3)(bcactive*(Jac*Ma/8.0)*(ux*Nx+uy*Ny)/dt^2)
	- int1d(th,31)(bcactive*(Jac*Ma/8.0)*(ux*Nx+uy*Ny)/dt^2)
	+ int1d(th,3)(bcactive*(2*Jac*Ma/8.0)*(upx*Nx+upy*Ny)/dt^2)
	- int1d(th,3)(bcactive*(Jac*Ma/8.0)*(uppx*Nx+uppy*Ny)/dt^2)
	+ int1d(th,31)(bcactive*(2*Jac*Ma/8.0)*(upx*Nx+upy*Ny)/dt^2)
	- int1d(th,31)(bcactive*(Jac*Ma/8.0)*(uppx*Nx+uppy*Ny)/dt^2)  << endl;
	cout << " Pin imposed " <<  Pin - Xcin*dt*Qin << endl;
	cout << " Pcav imposed " <<  Pcav - Xccav*dt*Qcav << endl;

	// macro MaskCAV() (x>0&&x<1.5&&y>0.5&&y<=3) // EOM
	Pcav =  int1d(th,21)(Jac*up/SResonator); //  Pcav 
	Pin =  int1d(th,1)(Jac*up/SResonatorIN)+int1d(th,11)(Jac*up/SResonatorIN); //  Pin
	Pout =  int1d(th,3)(Jac*up/SResonatorOUT)+int1d(th,31)(Jac*up/SResonatorOUT); //  Pout

	Qoutp = FlowRate(3,up) + FlowRate(31,up);
	Qoutpp = FlowRate(3,upp) + FlowRate(31,upp);



	tps=tps+dt;

	if(it%iout==0||it==itmax)
	{
		XXxH [uDNSx,uDNSy,uDNSp];
		[uDNSx,uDNSy,uDNSp] = [ux,uy,up];
		{
        	ofstream g(ffdatadir+"dnsfield_"+(it)+".txt");
			g << uDNSx[] << endl << endl;
			g << Re << Qin << Pin << Qcav << Pcav << Pout << Qout << Qoutp << Qoutpp << DQout << DQoutp << DQoutpp << endl << endl;
			g << tps << endl << endl;
		}
		{
        	ofstream g(ffdatadir+"dnsfield_"+(it-1)+".txt");
			g << upx[] << endl << endl;
		}
		{
        	ofstream g(ffdatadir+"dnsfield_"+(it-2)+".txt");
			g << uppx[] << endl << endl;
		}
		SFWriteDNSField(ffdatadir+"dnsfield_"+(it)+".ff2m",uDNS,"DNSField",it,tps)		
    	};
    
	if(it%istat==0||it==itmax) 
	{
	    DNSTimeStatistics(ffdatadir+"dns_Stats",u,up,t,it)
	}

 };


		 

		
