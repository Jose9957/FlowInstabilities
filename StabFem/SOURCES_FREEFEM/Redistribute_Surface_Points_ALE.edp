// 
// Rectification of a mesh : redistribution of points along boundary
// 
// DF, 08/12/2021
//

include "Macros_StabFem.idp"
macro USETECPLOT() NO //EOM
macro POSTPROCESSPAUL YES //EOM
macro POSTPROCESSSTABFEM YES //EOM

	verbosity = 0;

	int WAIT;
	int dataTest;

cout <<endl;
cout <<"       ::::::::::::::::::::::::::::::::::::::::::::::::::::"<<endl;
cout <<"         Redistribute_Surface_Points_ALE.edp   "<<endl;
cout <<"       ::::::::::::::::::::::::::::::::::::::::::::::::::::"<<endl<<endl;

real S = 0;int i=0;

//	cout <<"* Enter 1 if you want to wait for the plot or 0 if not "<<endl;
//	cin  >> WAIT;


	mesh th,ThB;
	macro ThF th//EOM
	string meshF,meshB,meshF0,meshB0;
	meshF0 =ffdatadir+"mesh.msh";	
	meshB0 =ffdatadir+"mesh_aux.msh";	
		
	 ThF  = readmesh(meshF0);	
	  ThB  = readmesh(meshB0);			 	
	
	fespace Eta(ThF,P1);
	fespace ETAf(ThF,[P2,P2]);
	fespace ETAb(ThB,[P2,P2]);		

	
	Eta eta;
	ETAf [etaFx,etaFy],[etaFtx,etaFty];
	ETAb [etaBx,etaBy],[etaBtx,etaBty];	
	
	fespace UP(ThF,[P2,P2,P1]);
	//velocity - pressure
	UP [Ux,Uy,P],[dux,duy,dp],[vx,vy,q];
	
	real Pb,dpb,Pb0;


	//Reading Data from a file
	int Nb,NsF0;
	real Oh0,We0,Re0,Roo,E,Nv0,Nb0,Rx,Ry,Volume,Area,Chi;
	real Oh,We,Re;

		{
		cout <<endl<<"using data stored in STABFEM mode"<<endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
		file >> Ux[];
		file >> Oh >> We >> Pb; 
		}


	//Loading the normal vectors defined on the vertices

	include "Macros_Curvature.idp";

	CalcGeomSurf;

	real Lsurf=S0PointSurf(Nsurface);
	Nv0 = ThF.nv;
	Nb0 = Nsurface;


// compute zeta needed to rectify mesh

fespace Wh11(th,P1);
Wh11 zeta;
for(int ksurf=0; ksurf<Nsurface+1; ksurf++)
{	
//	  cout << " s0(i) " << S0PointSurf(ksurf)  << " ; iso : " << ksurf*Lsurf/Nsurface << " ; gap : " << S0PointSurf(ksurf)-ksurf*Lsurf/Nsurface << endl;
      zeta[][IndexPointSurf(ksurf)] = (S0PointSurf(ksurf)-ksurf*Lsurf/Nsurface);
}



	macro div(u) (dx(u#x)+u#x/x+dy(u#y))//EOM
	macro Grad(u)  [[dx(u#x),u#x-u#x,dy(u#x)], [u#x-u#x,u#x/x,u#x-u#x], [dx(u#y),u#x-u#x,dy(u#y)]]  //EOM	
	macro tGrad(u) [[dx(u#x),u#x-u#x,dx(u#y)], [u#x-u#x,u#x/x,u#x-u#x], [dy(u#x),u#x-u#x,dy(u#y)]]  //EOM		
	macro D(u) (0.5*Grad(u)+0.5*tGrad(u))//EOM


	// Calculation of a continuous deformation field for the mesh
	solve a66([etaFx,etaFy],[etaFtx,etaFty]) = 
	int2d(ThF)(  div(etaF)*div(etaFt)*x + (D(etaF):D(etaFt))*x  )
	+on(7,etaFx = zeta*N0z, etaFy = -zeta*N0r)
	+on(81,82,81,82,etaFx=0,etaFy=0)
	+on(6,etaFx=0)
	+on(5,etaFy=0)
	;

	plot([etaFx,etaFy]);
func nx=N0x; func ny=N0y; func tx=T0x; func ty=T0y;	 cout << "normal/tg vectors : Macro" <<endl;

	// same inside the bubble
//	solve a666([etaBx,etaBy],[etaFtx,etaFty]) = 
//	int2d(ThB)(  div(etaF)*div(etaFt)*x + (D(etaF):D(etaFt))*x  )
//	+on(7,etaBx = zeta*N0z, etaBy = -zeta*N0r)
//	+on(81,82,81,82,etaBx=0,etaBy=0)
//	+on(6,etaBx=0)
//	+on(5,etaBy=0)
//	;
real TGV = 1e30;
	solve bubbleDisplacement([etaBx,etaBy],[etaBtx,etaBty]) = 
	int2d(ThB)(  div(etaB)*div(etaBt)*x + (D(etaB):D(etaBt))*x  )
	+int1d(ThB,7)(etaBx*etaBtx*TGV+etaBy*etaBty*TGV)
	+int1d(ThB,6)(etaBx*etaBtx*TGV)
	+int1d(ThB,5)(etaBy*etaBty*TGV)	
	-int1d(ThB,7)((N0y*zeta*etaBtx-N0x*zeta*etaBty)*TGV);
	;

plot([etaBx,etaBy]);

mesh ThBold = ThB;
mesh ThFold = ThF;
	

	try
	{
	ThF  = movemesh(ThF,  [(x+etaFx),(y+etaFy)]);	
	ThB = movemesh(ThB, [(x+etaBx),(y+etaBy)]);	
	}
	catch(...)
	{	
	cout << "Movemesh failed !!! EXITING HERE" << endl;
	exit(201);
	};
		
	
	plot(ThF);
	plot(ThB,ThBold);
	//no interpolation of the data on the new mesh
	
	CalcGeomSurf;
	

// GENERATE OUTPUT FILES

// First define Macros
IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)(1/x*(dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(1,2,3,psi=0)
					         + on(81,82,psi=-0*x^2*y/2);
//EOM
ENDIFMACRO      
	    
IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
	fespace p2forff2m(th,P1);  
    p2forff2m vort,psi,test; 
    solve CalcVort(vort,test)=int2d(th)(vort*test)-int2d(th)((-dy(u#r)+dx(u#z))*test);
	/*vort=-dy(u#r)+dx(u#z); */
	CalcPsi(psi,vort,test); 
	ofstream file(filename);
   	{
   	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for an axisymmetric flow with deformable free surface" << endl;
    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1.3 datadescriptors ur,uz,p,Oh,We,Pb" << endl;
    file << " real* Oh real* We real* Pb "
         << " real Re real Rx real Ry real Volume real Area real Chi "
         << " P1 vort P1 psi int iter" << endl << endl ;
	file << Oh << endl << We << endl << Pb << endl;	
	file << Re << endl << Rx << endl << Ry << endl;
	file << Volume	<< endl << Area  << endl <<  Chi  << endl;	
	for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	for (int j=0;j<psi[].n ; j++) file << psi[][j] << endl;
	file << iter << endl << endl;
 	}
	};
//EOM
ENDIFMACRO



// ECRITURE DES FICHIERS MESH (version STABFEM)
		savemesh(ThF,ffdatadir+"mesh.msh");
		savemesh(ThB,ffdatadir+"mesh_aux.msh");
		SFWriteMesh(ffdatadir+"mesh.ff2m",th,"rectified");
		SFWriteMeshSurface(ffdatadir+"mesh_surface.ff2m",th);
		SFWriteConnectivity(ffdatadir+"mesh_connectivity.ff2m",th);
		

// ECRITURE DES FICHIERS BASEFLOW (version STABFEM)		
		{		
			ofstream f(ffdatadir+"BaseFlow.txt");
				int nold=f.precision(16);
				f.scientific << Ux[] << endl << endl;
				f << Oh    		<< endl;
				f << We    		<< endl;
				f << Pb    		<< endl;
		
			UP [uur,uuz,uup];
			[uur,uuz,uup] = [Ux,Uy,P];
			SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",uu,"BaseFlowSurf",i);
			cout <<" Mesh and base flow field saved"<<endl;
		}
		
