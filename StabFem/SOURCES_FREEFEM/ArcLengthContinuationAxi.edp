//
//  PROGRAM ArcLengthContinuation2D.edp
//  Arclength contination in the alpha / beta plane
//  Alpha is the 'parameter' (here Reynolds nut customizable with macro) 
//  Beta is the 'monitor' (for instance energy but customizable through some macro)
//  
//  Arclength continuation is based on matrix extension of the Jacobian system
//  The desingularisation of the Jacobian comes from an extra condition which 
//  requires to follow a continous branch trhough a turning point.
//  
//  Notation n for Newton steps j for iterations of the whole arc-length process.
//  Capital letters J and N used for final steps of each of the lower letter processes.
//
//  Predictor step
//
//  \alpha^0_j = \alpha^N_{j-1} + \frac{d \alpha^N_{j-1}}{ds} ds
//  u^0_j = u^N_{j-1} + \frac{d u^N_{j-1}}{ds} ds
//  beta(u^0_j) = beta(u^N_{j-1}) + \frac{d beta(u^N_{j-1})}{ds} ds
//
//  where \frac{d u^N_{j-1}}{\alpha} =  -[ \frac{\partial{NS}}{\partial u}  ]^{-1} \frac{\partial{NS}}{\partial \alpha}
//  and normalised through \frac{d beta(u^N_{j-1})}{ds}^2 + \frac{d \alpha^N_{j-1}}{ds}^2 = 1
//
//  Corrector step
//  |																					        |
//  | \frac{\partial{NS}}{\partial u}                    \frac{\partial{NS}}{\partial \alpha}   |
//  |                                                                                           |
//  | \frac{\partial{beta}}{\partial ds} beta()			  \frac{\partial{\alpha}}{\partial  ds} |
//
//  RHS = [-NS(u), ds - \frac{\partial{beta}}{\partial ds} beta(u^n_{j} - u^0_{j-1}) 
//         - \frac{\partial{\alpha}}{\partial  ds}(alpha^n_{j} - alpha^0_{j-1})]
// 
//  Program developed for a rotating cylinder but adaptable to other cases
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	dS, DFyDsp, DparamDsp (directions of the tangent vector in (omega/Fy) plane)
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, error code is 201.
//
// 
//  author : J.Sierra and D.Fabre

//////////////////////////////////////////////////////////////////////////////////
//
//		0 : Headers (Include/load & global macros)		
//


include "StabFem.idp";


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		1 : Definition of parameters		
//


real DAlphaDs,DbetaDAlpha,DbetaDAlphap,DAlphaDsp;
real DReDs,DbetaDRe,DbetaDRep,DReDsp;
real dS,DbetaDs,DbetaDsp;
real Re,Reans,Re0,DReG,RePrev;
real dOmega=0.0, dRe=0.0;
real nu;
// Newton paramaters
real res,ener=1.;
real tol = 1e-6;
real dXX = 1;
int  iter = 1;


// CUSTOM-defined parameters (U1max, U2max, etc...) from macro
IFMACRO(SFInputParametersNewton)
SFInputParametersNewton
ENDIFMACRO

// Numerical parameters frorom getARGV
int Nitermax = getARGV("-Nitermax",20);


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		2 : Defintion of FEM spaces (lecture of mesh)		
//


IFMACRO(!defU)
	macro defU(u) [u#x,u#r,u#p] // EOM
ENDIFMACRO

mesh th;
th=readmesh(ffdatadir+"mesh.msh");
fespace Xh(th,P2);       //f.e. space for veloecity components
fespace Mh(th,P1);      //f.e space for pressure
fespace XXMh(th,[P2,P2,P1]); // f.e. space for triplet [u,v,p]
XXMh defU(Deru);
XXMh defU(DuG);          
XXMh defU(u0);        
XXMh defU(u);          ///////  -> unknown for the Navier-Stokes problem
XXMh defU(v);          ///////  -> test function for Navier-Stokes
XXMh defU(du);   		 ///////  -> increment for the Newton iteration
XXMh defU(up);  ;   	 ///////  -> buffer vector  to store previous iteration (Newton) 


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		4b : Customizable macros for input/output	
//
//

IFMACRO(!SFInput)
macro SFInput()
	cout << " Enter the step for the pseudo-arclength method " << endl;
	cin >> dS;

	cout << " Enter previous derivative in direction DbetaDs " << endl;
	cin >> DbetaDsp;

	cout << " Enter previous derivative in direction DparamDsp " << endl;
	cin >> DparamDsp;
	cout << "Step: " << dS << " derivative DbetaDs: " << DbetaDs << " DparamDsp " << DparamDsp  << endl; 
// EOM
ENDIFMACRO

IFMACRO(!DefaultGuessForNewton) /* if your want something else this macro may be redefined in your Macro_StabFem.idp */
	macro DefaultGuessForNewton
	defU(u) = [0,0,0]; //EOM
ENDIFMACRO


IFMACRO(!SFInputBaseFlow)
macro SFInputBaseFlow()
int testCB = 0;
try{ ifstream file(ffdatadir+"BaseFlow_guess.txt"); }
catch(...){testCB = 1; cout << "$$ NB : this 'ERROR' message is normal at this stage, the error was correcty caughth by StabFem. Relax !"; };

if (testCB!=0)
{
	cout << "$$ No file BaseFlow_guess.txt : strarting from arbitrary initial condition" << endl;
	DefaultGuessForNewton;
} 
else
{
	cout << " reading baseflow " << endl;
    ifstream file(ffdatadir+"BaseFlow_guess.txt");
    file >> ux[];
    file >> Reans;
    Re = Reans;
};
/* Previous value of the Newton iteration upx and value before Newton arc length u0x. Both initially equal to ux */
upx[] = ux[];
u0x[]= ux[];
param0 = param;
nu=1./Re; 
cout << endl << " >>> Re = " << Re <<endl;
// EOM
ENDIFMACRO

// B. Post-processing
IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)(1/y*(dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(6,21,22,23,psi=0)
					         + on(1,4,2,psi=y^2/2);
//EOM
ENDIFMACRO  

IFMACRO(!SFWriteBaseFlowAC)
	macro SFWriteBaseFlowAC(filename,u,typeFlow,iter)
		{
		fespace p1forff2m(th,P1);  
		p1forff2m xx,yy; 
		xx=x; yy=y;
	    p1forff2m vort;
		p1forff2m psi,phi,test; /* stream function ; may not work in all cases */
		vort=-dy(u#x)+dx(u#r);
		CalcPsi(psi,vort,test)  
		ofstream file(filename);
		file << "### Data generated by Freefem++ ; " << endl;
	    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
	    file << "datatype BaseFlow datastoragemode ReP2P2P1.1 datadescriptors ux,ur,p,Re" << endl;
		file << "real* Re real* beta real* Energy real tangent1 real tangent2 real U1 real U2 int bctype P1 vort P1 psi real iter " ;
		file << endl << endl ; 
		file << Re << endl;	
	    real BETA = beta(u);
		cout << "#    beta =  " << BETA << endl; 
	    file << BETA << endl ; 	
        file << int2d(th)(u#x^2+u#r^2) << endl;
	    file << DbetaDs << endl;	
	    file << DparamDs << endl;
        file << SFGeomUmax1 << endl;
        file << SFGeomUmax2 << endl;
        file << SFGeomInletType << endl;
		for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
		for (int j=0;j<psi[].n ; j++) file << psi[][j] << endl;
	    file << iter << endl;
	   	}
	    //EOM
ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		4b : Customizable macros for the variational formulation	
//
//


///// CUSTOMIZABLE MACROS FOR MONITOR
// COPY THIS IN YOUR MACROS IF YOU WANT TO USE IT!

// Here is the default : ENERGY
// A custom case can be found on 

IFMACRO(!scalebeta)
	macro scalebeta() 1.0 //EOM
ENDIFMACRO

// beta is the monitor.

IFMACRO(!beta)
	macro beta(u) (int2d(th)(scalebeta*(u#r^2+u#x^2))) //EOM
ENDIFMACRO

// dbetadu is the variation of monitor. 
// Use this macro with Dbeta = dbetads to assembly matrix (mat12 = dbeta/ds * [dbeta/du] (du)  )
// and Dbdeta = 1 just to compute [dbeta/du] ( du ) 

IFMACRO(!dbetadu)
   macro dbetadu(meshTh,Dbeta,nuRe,u,du) 
   (
   int2d(meshTh)(2*scalebeta*Dbeta*(u#r*du#r+u#x*du#x))
   )
//EOM
ENDIFMACRO

IFMACRO(!param)
	macro param Re //EOM
	macro param0 Re0 // EOM
	macro DparamG DReG // EOM
	macro paramPrev RePrev // EOM
	macro DparamDs DReDs // EOM
	macro DparamDsp DReDsp // EOM
	macro DbetaDparam DbetaDRe // EOM
	macro DbetaDparamp DbetaDRep // EOM
	macro dparam dRe // EOM   
	macro DerNSDparam(FESpace) vNsDRe(0,FESpace,tgv=-1) //
ENDIFMACRO

// A. Boundary conditions 
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO
IFMACRO(!Vinlet)
macro Vinlet() 0. //EOM
ENDIFMACRO
IFMACRO(!Winlet)
macro Winlet() 0. //EOM
ENDIFMACRO

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,up,v)
	           on(1,du#r=Vinlet-up#r,du#x=Uinlet-up#x)
             + on(2,21,22,23,du#x=0.0,du#r=0.0)
             + on(5,du#x=0.0)+on(4,51,du#r=0) /* ??? */
             + on(6,du#r=0.0)      
//EOM
ENDIFMACRO

macro div(u) (dx(u#x)+dy(u#r)+u#r/y)// macro for divergence 
macro Grad(u) [[dx(u#x), dy(u#x),  u#x-u#x ], [dx(u#r), dy(u#r), u#x-u#x],[u#x-u#x,u#x-u#x,u#r/y ]] // macro for rate-of-deformation tensor
macro D(u) [[dx(u#x), .5*(dx(u#r)+dy(u#x)),  u#x-u#x ], [.5*(dx(u#r)+dy(u#x)), dy(u#r),u#x-u#x],[u#x-u#x,u#x-u#x,u#r/y ]] // macro for rate-of-deformation tensor

macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#r*dy(ub#x))+(ub#x*dx(ua#x)+ub#r*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#r)+ua#r*dy(ub#r))+(ub#x*dx(ua#r)+ub#r*dy(ua#r)))*v#r 
                    ) // macro for mutual convection operator

/* Macro to update nu in each sub-iteration of the correction step */
IFMACRO(!UpdateNU)
macro UpdateNU()

IFMACRO(CUSTOMnu)
nu = CUSTOMnu;
ENDIFMACRO

IFMACRO(!CUSTOMnu)
nu = 1.0/Re;
ENDIFMACRO
//EOM
ENDIFMACRO
//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		5 : Variational formulation
//
//

real eps = 1e-12;
varf jacobian(defU(du),defU(v))=int2d(th)((
			-2*nu*(D(du):D(v))
             + vp*div(du)
             + div(v)*dup
				-Conv(up,du,v)
                +eps*dup*vp
		     )*y
              )
	+  BoundaryconditionsBaseFlow(du,up,v);     

varf vNs(defU(du),defU(v))=-int2d(th)(
			(
    		-2*nu*(D(up):D(v))
             + vp*div(up)
             + div(v)*upp
             -.5*Conv(up,up,v)
          )*y)		   
  +  BoundaryconditionsBaseFlow(du,up,v);    

varf OrthoQ(defU(v),defU(du))=int2d(th)(y*(Derux*dux+Derur*dur+Derup*dup));

varf betaVarf(defU(v),defU(du))=dbetadu(th,DbetaDs,nuRe,u,du);
   
varf vNsDAlpha(defU(du),defU(v)) = on(2,dux=-y/0.5,dur=x/0.5); // this one is for rotation and should not work

varf vNsDRe(defU(du),defU(v))=int2d(th)(y*2*(1/Re^2)*(D(up):D(v)));

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		6 : Reading input parameters and files
//
//


SFInput
SFInputBaseFlow

// If Nu is something else than 1/Re define a macro CUSTOMnu in your  .idp file
IFMACRO(CUSTOMnu)
nu = CUSTOMnu;
ENDIFMACRO



//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		7a : Run-time -- Predictor step
//
//

cout << "Computation of the initial tangent " << endl;

/* Previous values of beta and param */
real param00 = param;
real beta00 = beta(up);

/* Update the tangent dU/dp  as a reminder: dU/dp = (dR/dU)^{-1}*dR/dp */

matrix JAC=jacobian(XXMh,XXMh); set(JAC,solver=sparsesolver);
real[int] DerNSparam = DerNSDparam(XXMh);
Derux[] = JAC^-1*DerNSparam;
Derux[] = - Derux[];
cout << " beta ; dbetadu " <<  beta(u) << " " << dbetadu(th,1.,nuRe,u,Deru) << endl;
DbetaDparam = dbetadu(th,1.,nuRe,u,Deru); // instead of beta(Deru);


/* Normalization of tangents. Reminder: ||dBeta/dS||^2 + ||dParam/dS||^2 = 1 */
DbetaDs = DbetaDparam/sqrt(1+DbetaDparam^2);
DparamDs = 1.0/sqrt(1+DbetaDparam^2);

IFMACRO(FREEFEMPLOTS,YES)
plot(Derux,fill=1,wait=1);
ENDIFMACRO

/* Determination of the sign of the tangent */

real scalarProduct = DbetaDsp*DbetaDs + DparamDsp*DparamDs;
cout << "Inner product =  " << scalarProduct  << endl;

if(scalarProduct < 0)
{
	DbetaDs*=-1.0;
	DparamDs*=-1.0;
}



cout << " tangents (from  input) : " << DbetaDsp << " ; " <<  DparamDsp << endl;
cout << " tangents (from  predictor step) : " << DbetaDs << " ; " <<  DparamDs << endl << endl;
cout << "End of the computation of the initial tangent " << endl;

cout << "###### Prediction step ######" << endl;
ux[] += dS*DparamDs*Derux[];
param = param + dS*DparamDs;
cout << " param ; dparam = " << param << " ; " << dS*DparamDs << endl;
cout << " beta  ; dbeta  = " << beta(u) << " ; " << beta(u)-beta00 << endl;
cout << " dbeta/dparam = " << (beta(u)-beta00)/(dS*DparamDs) << endl;


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		7b : Run-time -- Orthogonal correction step
//
//

cout << "###### Correction step ######" << endl;

while(abs(dXX)>tol&&abs(dXX)<1e6&&iter<Nitermax)
{ 
	cout << endl << "# Iteration : " << iter << " of the Newton-corrector step"<< endl;
	// Previous value of the Newton method 
	upx[]=ux[];
	UpdateNU
	/* Update the difference w.r.t. the state previous the predictor */
	DuGx[] = ux[]- u0x[];
	DparamG = param - param0;   
	/* Assemble the system */ 
	cout << " Assembling matrix..." << endl;
    matrix mat11=jacobian(XXMh,XXMh,tgv=-1);
    real[int] mat12 = DerNSDparam(XXMh);
    real[int] mat21 = betaVarf(0,XXMh,tgv=-1);
    real mat22 = DparamDs;
	matrix LinOp = [
					[mat11,		mat12],
					[mat21',  	mat22]
				   ];
	cout << " LU-ing matrix..." << endl;
	set(LinOp,solver=sparsesolver);
    // Assemble RHS
    cout << " Assembling RHS..." << endl;
    real[int] RHS1 = vNs(0,XXMh,tgv=-1);
    real RHS2 =  dS - mat22*DparamG - mat21'*DuGx[]; // DAVID : should be zero ???
	real[int] RHS = [RHS1, RHS2];

    cout << "    => norm (NS) ; norm(ds-DS) : " << RHS1.l2 << " : " << RHS2 << endl;   
	cout << " solving BIG problem..." << endl;
	real[int] dX(LinOp.n);
	dX = LinOp^-1*RHS;
	[dux[], dparam] = dX;
	ux[] += dux[];
	param += dparam;
	
	cout << endl << "   ### ||du0||, dparam, dbeta : " << dux[].l2 << " "  << dparam << " " << dbetadu(th,1.,nuRe,u,du) << endl;
	dXX = dux[].l2+dparam;
	cout << "   ### ||u0|| : " << ux[].l2 << endl;
	cout <<  "  ### param = " << param << endl;
    cout << "   ### beta = " << beta(u) << endl;
    cout << "       dparam/dbeta = " <<  dparam/dbetadu(th,1.,nuRe,u,du) << endl;
	iter++;
};


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		8 : Post-processing
//
//


/*=====     Error detection    ======*/

if((abs(dXX)>1e6)||(iter>=Nitermax))
{
	SFerror("$$ NEWTON ITERATION FAILED");
	cout << "$$ Leaving FreeFem++ with error code 201" << endl;
	exit(201);
}

real Dbeta,Dparam;
{Dbeta = (beta(u)-beta00);
Dparam = (param-param00);}
cout << " Tangents recomputed at end of step : " << Dbeta/sqrt(Dbeta^2+Dparam^2) << " " << Dparam/sqrt(Dbeta^2+Dparam^2) << endl;;


/*=============================================
=            SAVE step                       =
=============================================*/
{
  {
	  ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
	  file << ux[]; 
	  file << endl << endl << Re << endl;
  }; 
  if(iter == 10) iter = -1; // Not converged
  SFWriteBaseFlowAC(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver

};
/*=====     End of SAVE step   ======*/


//
//
//
//////////////////////////////////////////////////////////////////////////////////

