//
//  PROGRAM Newton_2D_Comp.edp
//  computation of 2D compessible base flow [ux,uy,p,T,rho](x,y)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt		  -> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Update October 2019. J.S.

//////////////
cout << "$$$$ ENTERING Newton_2D_Comp.edp " << endl << "$$" << endl; 
//		include "SF_Geom.edp"; // to be removed soon
include "StabFem.idp";

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters		
//

real Re,Reans,Ma,Maans,Omegax,Omegaxans;
string symmetryBaseFlow;
cout << " Enter Reynolds Number ?' " << endl;
cin >> Re;
cout << " Enter Mach Number ?' " << endl;
cin >> Ma;
cout << " Enter rotational speed of the cylinder " << endl;
cin >> Omegax;
cout << "$$ Enter symmetry property of base flow  ? ('N','S', or 'A') >> ";
cout << "$$ Enter symmetry property of base flow  ? ('N','S', or 'A') >> ";
cin >> symmetryBaseFlow;
cout << symmetryBaseFlow << endl;
real gamma=getARGV("-gamma",1.4); 
real Pr=getARGV("-Pr",0.7);

cout << endl << " >>> RE = " << Re << "  Mach = " << Ma << " Omegax =  " << Omegax <<endl;
cout << " gamma = " << gamma << endl;
cout << " Pr = " << Pr << endl;
//////////////////////////////////////////////////////////////////////////////////////////////
// Physical parameters


real nu=1./Re; // kinematic viscosity

//////////////////////////////////////////////////////////////////////////////////////////////
// Simulation parameters

real TOLLERANCENewton=1e-8;  /// tollerance of newton loop
int NITERATIONNEWTLOOP=40;  //////////////  Max number of ITERATIONs --> Newton loop
real TOLLERANCEDiv = 20.0; // Tolerance to reset initial condition due to divergence of the Newton method.
real ts; // Computational time.
int Nitermax=30; // Maximum number of iterations
real res=1.0; // Control flow of the Newton iteration
real ener=1.0; // Control flow of the Newton iteration

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//  

mesh th;
th=readmesh(ffdatadir+"mesh.msh");

fespace XXxxxH(th,[P2,P2,P1,P1,P1]); ///    vel 2x P2 + pres P1 + temp P1 + dens P1
fespace XH2(th,P2);
//macro def(u,p,T,rho)[u#x,u#y,p,T,rho]//EOF
macro defUU(u)[u#x,u#y,u#p,u#T,u#rho]//EOF  
XXxxxH defUU(du);
XXxxxH defUU(Ub);

int testCB;
SFcheckfile("BaseFlow_guess.txt",testCB);
if (testCB==-1)
{
	cout << "$$ No file BaseFlow_guess.txt : starting from arbitrary initial condition" << endl;
	IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
	macro DefaultGuessForNewton
		defUU(Ub) = [1.0,0.0,0.0,1.0,1.0]; //EOM
	ENDIFMACRO
	DefaultGuessForNewton;
} 
else
{
	cout << "$$ Reading file BaseFlow_guess.txt" << endl;
	ifstream file(ffdatadir+"BaseFlow_guess.txt");
	file >> Ubx[];
	file >> Reans;
	file >> Maans;
	file >> Omegaxans;
	cout << "$$ Re of guess field : " << Reans << endl; 
	cout << "$$ Ma of guess field : " << Maans << endl; 
	cout << "$$ Omegax of guess field : " << Omegaxans << endl; 
};

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//
//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your SF_Custom.idp file.
//
	
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO	

IFMACRO(!Vinlet)
macro Vinlet() 0. //EOM
ENDIFMACRO	

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,Ub,us)
	           on(1,du#x=Uinlet(y)-Ub#x,du#y=Vinlet(y)-Ub#y,du#rho=1.-Ub#rho,duT=1.-Ub#T)
	         + on(3,du#x=Uinlet(y)-Ub#x,du#y=0.0-Ub#y,du#rho=1.-Ub#rho,duT=1.-Ub#T)  
             + on(2,du#x=0.0-Ub#x,du#y=0.0-Ub#y)
             + int1d(th,6)(du#x*us#x*1e30*(symmetryBaseFlow=="A")+du#y*us#y*1e30*(symmetryBaseFlow=="S"))       
//EOM
ENDIFMACRO

IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,rho,test)
      solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(rho*vort*test)
					         + on(6,2,21,22,23,psi=0)
					         + on(1,3,psi=y);
//EOM
ENDIFMACRO     

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
		fespace p1forff2m(th,P1);  
	    p1forff2m vort,divergence;
		vort=dy(u#x)-dx(u#y); /* vorticity */
	    divergence=dx(u#x)+dy(u#y); 
		ofstream file(filename);
	   	{
		file << "### Data generated by Freefem++ ; " << endl;
	    file << typeFlow << " for a 2D-compressible problem " << endl;
	    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1P1P1.2 datadescriptors ux,uy,p,T,rho,Re,Mach" << endl;
		file << "real* Re real* Mach P1 vort P1 div real iter " << endl << endl ; 
		file << Re << endl;	
	    file << Ma << endl;
				for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	            for (int j=0;j<vort[].n ; j++) file << divergence[][j] << endl;
				file << iter << endl;
		}
	}; 
// EOM
ENDIFMACRO

/////////////////////////////////////////////////////////////////////////////////
/////// macro to define some useful operators
macro div(u) ((dx(u#x)+dy(u#y)))   //EOM
macro ugradf(u,f) ((u#x*dx(f)+u#y*dy(f)))    //
macro termnonlinear(u,v,w) ((w#x*(u#x*dx(v#x)+u#y*dy(v#x))+w#y*(u#x*dx(v#y)+u#y*dy(v#y)))) //
macro Grad(u) [[dx(u#x),dx(u#y)],[dy(u#x),dy(u#y)]]//EOM
macro Strain(u)[[dx(u#x),0.5*(dx(u#y)+dy(u#x))],[0.5*(dx(u#y)+dy(u#x)),dy(u#y)]]//EOM
macro gradgrad(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM
/////////////////////////////////////////////////////////////////////////////////

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//

varf jacobian(defUU(du),defUU(us))=int2d(th)
										(
										usrho*(durho*div(Ub)+Ubrho*div(du)+ugradf(Ub,durho)+ugradf(du,Ubrho)) 
								       //mass equation
								       -dup*div(us)+2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))
								       +Ubrho*termnonlinear(du,Ub,us)+durho*termnonlinear(Ub,Ub,us)+Ubrho*termnonlinear(Ub,du,us)
								       //momentum
								  		+usT*(durho*ugradf(Ub,UbT)+Ubrho*ugradf(Ub,duT)+Ubrho*ugradf(du,UbT)+(gamma-1)*(div(Ub)*(durho*UbT+Ubrho*duT) 
								  		+ Ubrho*UbT*div(du))-gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(du):Strain(Ub))+(Strain(Ub):Strain(du)))
								  		-2.0/3.0*(2.0*div(Ub)*div(du))))+gamma/(Pr*Re)*gradgrad(duT,usT)
								       // energy
								       +usp*(gamma*Ma^2*dup-(durho*UbT+Ubrho*duT))
								  		)
  										+BoundaryconditionsBaseFlow(du,Ub,us);


varf vNs(defUU(du),defUU(us))=-int2d(th)(
								usrho*(Ubrho*div(Ub)+ugradf(Ub,Ubrho))
							   //mass equation
							   -Ubp*div(us)+2.0/Re*(Strain(Ub):Grad(us))
							   -2.0/(3.0*Re)*(div(Ub)*div(us))+Ubrho*termnonlinear(Ub,Ub,us)
							   //momentum
								+usT*(Ubrho*ugradf(Ub,UbT)+(gamma-1)*UbT*Ubrho*div(Ub)
								   -gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(Ub):Strain(Ub)))-2.0/3.0*(div(Ub)*div(Ub))))
								   +gamma/(Pr*Re)*gradgrad(UbT,usT)
							   // energy
							   +usp*(1.0 + gamma*Ma^2*Ubp-(Ubrho*UbT))
							   )
  							   +BoundaryconditionsBaseFlow(du,Ub,us);

//
//
//
//////////////////////////////////////////////////////////////////////////////////

cout << " ................................................... "<< endl;	
cout << " ................................................... "<< endl;	

  
//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//    

int i=0;
while((ener>TOLLERANCENewton)&(i<=NITERATIONNEWTLOOP))
{
  ts=clock();
  matrix Newt=jacobian(XXxxxH,XXxxxH);
  cout<<"Matrix formed in "<<clock()-ts<<" s"<<endl;  
  real[int] rhs= vNs(0,XXxxxH);
  set(Newt,solver=sparsesolver,tgv=-1);
  dux[] =  (Newt^-1*rhs);
  ener=sqrt(int2d(th)(abs(duy)^2+abs(dux)^2)); 
  cout << "iter "<<i<<" | sqrt(int2d(th)(dux^2+duy^2)) = " << ener << endl;
  Ubx[]+=dux[];
  i++;	    

}// end of NEWTON LOOP
 	  
cout << " -------------------------------------------------------- "<< endl;	
cout << " Newton iteration ok!"<< endl;

////// OUTPUT FOR STABFEM  
if((ener>50)||(i>Nitermax))
{
	cout << "$$ NEWTON ITERATION FAILED" << endl;
	cout << "$$ Leaving FreeFem++ with error code 201" << endl;
	exit(201);
}

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//    
		

XXxxxH [ux,uy,up,uT,urho] = defUU(Ub);
{
  {
	  ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
	  file << ux[]; 
	  file << endl << endl << Re << endl << Ma << endl << Omegax << endl;
	  exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
  }; 
  SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",i); // file in .ff2ml format for StabFem driver
};


//
//
//
//////////////////////////////////////////////////////////////////////////////////


	    
	    
	  



