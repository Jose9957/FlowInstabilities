/// Program AdaptationMask.edp : 
/// construction of a "Mask" function to enforce the mesh adaptor to respect a minimum density in some regions 

include "StabFem.idp";

// reading mesh
mesh th = readmesh(ffdatadir+"mesh.msh");
 fespace Vh(th,P2);fespace VhVh(th,[P2,P2],periodic=MESHPERIODICITY);
 VhVh<complex> [Maskx,Masky];

// reading parameters and constructing mask
string typeMask;
cout << "Enter Mask type [rectangle,ellipse,...] >> " ;
cin >> typeMask;
cout << typeMask << endl;
//typeMask = "rectangle";
if(typeMask=="rectangle")
{
	// reading parameter for "rectangle" type
	real Xmin,Xmax,Ymin,Ymax,DX;
	cout << "Enter successively [Xmin,Xmax,Ymin,Ymax] >> " ;
	cin >> Xmin >> Xmax >> Ymin >> Ymax ;
	cout << Xmin << " ; " <<  Xmax << " ; " <<  Ymin << " ; " <<  Ymax << endl ;
	cout << "Enter DX (expected grid step) >> " ;
	cin >> DX ;
	cout << DX << endl ;

    // fespaces in this case
    Vh MaskEnvelope;

	// creating Mask function
	real Xc = (Xmin+Xmax)/2; real Lx = abs(Xmax-Xmin);real Yc = (Ymin+Ymax)/2; real Ly = abs(Ymax-Ymin);

	func real ENV(real x,real Xmin,real Xmax) 
	{
	 if(x<Xmin)
	 	{ return 0; }
	 else if(x<Xmax)
		{ return (x-Xmin)*(Xmax-x);}
	 else
	 	return 0;
	}; 
	  
    [Maskx,Masky] = [exp(1i*x/(10*DX))*ENV(y,Ymin,Ymax)*ENV(x,Xmin-0*DX,Xmax+0*DX),exp(1i*y/(10*DX))*ENV(x,Xmin,Xmax)*ENV(y,Ymin-0*DX,Ymax+0*DX)];

}
else if(typeMask=="trapeze")
{
	// reading parameter for "rectangle" type
	real Xmin,Xmax,Ymin,Ymax,Thetamin,Thetamax,DX;
	cout << "Enter successively [Xmin,Xmax,Ymin,Ymax,Thetamin,Thetamax] >> " ;
	cin >> Xmin >> Xmax >> Ymin >> Ymax >> Thetamin >> Thetamax;
	cout << Xmin << " ; " <<  Xmax << " ; " <<  Ymin << " ; " <<  Ymax 
         << " ; " << Thetamin << " ; " <<  Thetamax << endl ;

	cout << "Enter DX (expected grid step) >> " ;
	cin >> DX ;
	cout << DX << endl ;

    // fespaces in this case
    Vh MaskEnvelope;

	// creating Mask function
	func real ENVT(real x,real y) 
	{
     real Tx,Ty;
	 if(x<Xmin)
	 	{ Tx = 0; }
	 else if(x<Xmax)
		{ Tx = (x-Xmin)*(Xmax-x);}
	 else
	 	{ Tx = 0; };

     if(y<(Ymin+tan(pi/180*Thetamin)*(x-Xmin)))
	 	{ Ty = 0; }
	 else if(y>(Ymax+tan(pi/180*Thetamax)*(x-Xmin)))
		{ Ty = 0;}
	 else
	 	{ Ty = (y-(Ymin+tan(pi/180*Thetamin)*(x-Xmin)))*(y-(Ymax+tan(pi/180*Thetamax)*(x-Xmin))); };
     return Tx*Ty;
}
    MaskEnvelope = ENVT(x,y);
    [Maskx,Masky] = [exp(1i*x/(10*DX))*MaskEnvelope,exp(1i*y/(10*DX))*MaskEnvelope];

}
else if(typeMask=="ellipse")
{
	// reading parameter for "rectangle" type
	real Xc,Yc,Xl,Lx,Ly,DX;
	cout << "Enter successively [Xc,Yc,Lx,Ly] >> " ;
	cin >> Xc >> Yc >> Lx >> Ly ;
	cout << Xc << " ; " <<  Xc << " ; " <<  Yc << " ; " <<  Yc << endl ;
	cout << "Enter DX (expected grid step) >> " ;
	cin >> DX ;
	cout << DX << endl ;

    // fespaces in this case
    Vh MaskEnvelope;

	func real ENVE(real x,real y,real Xc,real Yc,real Lx,real Ly) 
	{
     real R2 = (x-Xc)^2/Lx^2 + (y-Yc)^2/Ly^2;

	 if(R2>1)
	 	{ return 0; }
	 else
	 	{ return 1-R2; }
	}; 
	MaskEnvelope = ENVE(x,y,Xc,Yc,Lx,Ly);
    [Maskx,Masky] = [exp(1i*x/(10*DX))*MaskEnvelope,exp(1i*y/(10*DX))*MaskEnvelope];

}
else if(typeMask=="thermal7"||typeMask=="thermal27"||typeMask=="thermal2")
{

cout << "Enter delta (expected grid step) >> " ;
	real delta;
    cin >> delta ;
	cout << delta << endl ;

Vh MaskEnvelope;

// reading parameters and constructing mask

//	real delta = getARGV("-delta",.1);
//	cout << delta << endl;
	
if (typeMask=="thermal7")
{
    solve calcMask(Maskx,Masky) = int2d(th)(dx(Maskx)*dx(Masky)+dy(Maskx)*dy(Masky)+1i/(100*delta*delta)*Maskx*Masky)
    + on(7,Maskx = 1.);
}
else if (typeMask=="thermal27")
{
    solve calcMask(Maskx,Masky) = int2d(th)(dx(Maskx)*dx(Masky)+dy(Maskx)*dy(Masky)+1i/(100*delta*delta)*Maskx*Masky)
    + on(7,2,21,22,23,32,Maskx = 1.);
}
else 
{
    solve calcMask(Maskx,Masky) = int2d(th)(dx(Maskx)*dx(Masky)+dy(Maskx)*dy(Masky)+1i/(100*delta*delta)*Maskx*Masky)
    + on(2,21,22,23,32,Maskx = 1.);
}

};



// else if (other cases ...)



// Writing the data in a .ff2m file
{ 
	fespace pp1(th,P1);
	pp1<complex> MaskP1=Maskx;
	pp1<complex> Mask2P1=Masky;
	ofstream file(ffdatadir+"Mask.ff2m"); 
    file << "### Data generated by Freefem++ ; " << endl;
    file << "Adaptation Mask" << endl;
    file << "datatype MASK datastoragemode CxP2P2"  << endl;
	file << "P1c Maskx P1c Masky" << endl << endl ; 
	for (int j=0;j<MaskP1[].n ; j++)
		file << real(MaskP1[][j]) << endl << imag(MaskP1[][j]) << endl;
	for (int j=0;j<MaskP1[].n ; j++)	
		file << real(Mask2P1[][j]) << endl << imag(Mask2P1[][j]) << endl;
    file << endl;
}


// exports as well in ".txt" format (for subsequent usage by FreeFem)
{
    ofstream file2(ffdatadir+"Mask.txt");
    file2 << Maskx[];
}


