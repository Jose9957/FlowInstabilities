//
//  PROGRAM Newton_2D_ForcedByPlasma.edp
//  computation of 2D base flow [ux,uy](x,y) WITH PLASMA FORCING
//
//
//  INPUT PARAMETERS (now managed with getARGV)
//   	nustar
//      fstar
//      Uin
//      symmetry ('S','A' or 'N')
//      (you can customize the list using customizable macro SFInputParametersNewton)
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
//		Forcing.txt			-> Forcing (phi, n)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt		-> base flow (FF format)
//      BaseFlow.ff2m       -> base flow (FF2M format)
//
// 	ERROR MANAGEMENT :
//      if Newton iteration diverges, return exit code 201.
//
//  HISTORY :
//  Created 7 oct 2020 by DF and CM, adapted from standard solver Newton_2D.edp


cout << "$$$$ ENTERING Newton_2D.edp " << endl << "$$" << endl;

include "StabFem.idp"


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters
//

real nustar, fstar, Uin, relax, itermaxrelax;

relax = getARGV("-relax",0.8); // Paramètre de relaxation qui multiplie l'incrément de Newton ( 0,8 pour une relaxation classique )
relax = 1-relax ; // Adaptation du paramètre du fait de l'utilisation dans le calcul de la solution ( on fait 1-relax )
itermaxrelax = getARGV("-itermaxrelax",0); // Parammètre qui règle le nombre d'itération pendant lesquelles on va appliquer la relaxation ( le but est de le faire juste au début pour trouver la bonne pente a descendre la bonne pente

///////////////////////////////////////////////////////////////////////////////////

nustar = getARGV("-nustar",1.);
fstar = getARGV("-fstar",1.);
Uin = getARGV("-Uin",0.);
cout << "$$ parameter nustar = " << nustar << endl;
cout << "$$ parameter fstar = " << fstar << endl;
cout << "$$ parameter Uin = " << Uin << endl;

///////////////////////////////////////////////////////////////////////////////////

// 1.C numerical paramters
string symmetryBaseFlow=getARGV("-Symmetry","N");
cout << "$$  Numerical parameters (handled by getARGV or default ) " << endl;
real tolerance=getARGV("-tolerance",2e-12);
cout << " tolerance = " << tolerance << endl;
int Nitermax=getARGV("-Nitermax", 50);
cout << " Nitermax = " << Nitermax << endl;
real relaxfinale=getARGV("-relaxfinale",100);
real Omegax = 0;

real gammaGD = 0; // a enlever

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files
//


		mesh th=readmesh(ffdatadir+"mesh.msh");

        fespace Xh(th,P2,periodic=MESHPERIODICITY);       //f.e. space for veloecity components
		fespace Mh(th,P1,periodic=MESHPERIODICITY);      //f.e space for pressure
		fespace XXMh(th,[P2,P2,P1],periodic=MESHPERIODICITY); // f.e. space for triplet [u,v,p]

		fespace Xh2IO(th,[P2,P2],periodic=MESHPERIODICITY); // f.e. space for [phi, ne]

		XXMh [ux,uy,up];          	///////  -> unknown for the Navier-Stokes problem
		XXMh [vx,vy,q];          	///////  -> test function for Navier-Stokes
		XXMh [upx,upy,upp];   	 	///////  -> buffer vector  to store previous iteration (Newton)
		XXMh [dux,duy,dup]; 		///////  -> increment for the Newton iteration

		Xh2IO [Uphi,Un];  			// read from plasma computation

		// Baseflow
		int testCB;
		SFcheckfile("BaseFlow_guess.txt",testCB);

    	if (testCB<0)
		{
		SFwarning("No file BaseFlow_guess.txt : starting from arbitrary initial condition");
		IFMACRO(!DefaultGuessForNewton) 		// if your want something else this macro may be redefined in your SF_Custom.idp
		macro DefaultGuessForNewton
		[ux,uy,up] = [0,0,0];					// EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		}
		else
		{
		cout << "$$ Reading file BaseFlow_guess.txt" << endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[];
//        real Reans;
//		file >> Reans;
//		cout << "$$ Re of guess field : " << Reans << endl;
		};

// Forcing
		SFcheckfile("Forcing.txt",testCB);
    	if (testCB<0)
		{
		SFerror("No file Forcing.txt ");
		}
		else
		{
		cout << "$$ Reading file Forcing.txt" << endl;
		ifstream file(ffdatadir+"Forcing.txt");
        file >> Uphi[];
		};


	cout << "$$ Starting Newton algorithm " << endl;



//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros
//

//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your SF_Custom.idp file.
//

IFMACRO(!Uinlet)
macro Uinlet() Uin //EOM
ENDIFMACRO

// Macro a modifier pour le conditions limites //---------------------------------------------------------------------------------------------------------------

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,u,v)
	         	on(2,21,du#x=-u#x,du#y=-u#y)
             		+ on(5,du#y=-u#y)
	             	+ on(1,du#x=Uinlet-u#x)
            		+ on(52,du#y=-u#y);
// 1 = Condition Limite entrée // 2 = Condition limite sur le collecteur et l'emetteur // 5 = Condition limites sur le haut // 52 = condition limite sur le bas ( haut et bas )

//EOM
ENDIFMACRO

// Macro a modifier pour le conditions limites //---------------------------------------------------------------------------------------------------------------


IFMACRO(!CalcPsi)
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(6,2,21,22,23,psi=0)
					         + on(1,4,psi=y*Uinlet);
//EOM
ENDIFMACRO

macro Trainee(u,symmetry)
	(
	(1*(symmetry=="N")+2*(symmetry=="S"))
	*(
	int1d(th,2,21,22,23)(u#p*N.x)
	-nustar*int1d(th,2,21,22,23)( (2*dx(u#x)*N.x+(dx(u#y)+dy(u#x))*N.y))
	)
	)
//EOM

macro Portance(u,symmetry)
	(
	(1*(symmetry=="N")+2*(symmetry=="A"))
	*(
	int1d(th,2,21,22,23)(u#p*N.y)
	-nustar*int1d(th,2,21,22,23)( (2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x))
	)
	)
//EOM

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1,periodic=MESHPERIODICITY);
    p1forff2m vort;
	vort=-dy(u#x)+dx(u#y); /* vorticity */
	p1forff2m psi,test;
	CalcPsi(psi,vort,test);
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1 datadescriptors ux,uy,p" << endl;
	file << "real* nustar real* fstar real* Uin real* Fx real* Fy P1 vort P1 psi real iter " << endl ;
	file << nustar << endl;
	file << fstar << endl;
	file << Uin << endl;
	file << Trainee(u,symmetryBaseFlow);
	file << Portance(u,symmetryBaseFlow);

			for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
	};
	}
//EOM
ENDIFMACRO

/////////////////////////////////////////////////////////////////////////////////
/////// macro to define some useful operators

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence
macro Conv(ua,ub,v) (
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//




// definition of linear system to be solved at each step of the iteration
problem NewtonIter([dux,duy,dup],[vx,vy,q]) =
    int2d(th)(
			-2*nustar*(D(du):D(v))
             + q*div(du)
             + div(v)*dup
			 - Conv(up,du,v)
             )
             +
    int2d(th)(
    		-2*nustar*(D(up):D(v))
             + q*div(up)
             + div(v)*upp
             - .5*Conv(up,up,v)
             - fstar*Un*(dx(Uphi)*vx+dy(Uphi)*vy)
             )
	+  BoundaryconditionsBaseFlow(du,up,v);

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//


// parameters for Newton loop

    real res=1;
    int iter=0;


// Newton loop
        while((res>tolerance)&(res<50)&(iter<=Nitermax))
        {
	    upx[]=ux[];
        NewtonIter ;
//
        ux[] = ux[]+(1-relax*(iter<=itermaxrelax || iter >=relaxfinale))*dux[];
		real enerl2=dux[].l2;
		res=sqrt(int2d(th)(dux^2+duy^2)/th.area);
	    cout << "$$ Iter = "<< iter+1 << " ; res = " << res << " ; res l2 = " << enerl2 << endl;
        iter++;
        plot(ux,cmm="iteration "+iter);
	  } ;

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//


// sortie des r?sultats

		if((res>50)||(iter>Nitermax))
		{
			SFerror("$$ NEWTON ITERATION FAILED");
			cout << "$$ Leaving FreeFem++ with error code 201" << endl;
			exit(201);
		}
		else

		{

		plot(ux,wait=1);

		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << ux[];
		  file << endl  << 0;
          real Omegaxforfile = Omegax; // LEGACY ; to be removed completely someday
		  file << endl  << Omegaxforfile << endl;
		  };


          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver


		};

cout << "$$$$ SUCESSFULLY LEAVING Newton_2D.edp "  << endl;
