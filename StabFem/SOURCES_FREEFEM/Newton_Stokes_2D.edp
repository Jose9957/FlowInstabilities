//
//  PROGRAM Newton_2D.edp
//  computation of 2D base flow [ux,uy](x,y)
//   
//
//  INPUT PARAMETERS (now managed with getARGV)
//   	Re
//      Omegax
//      alpha
//      symmetry ('S','A' or 'N')
//      (you can customize the list using customizable macro SFInputParametersNewton)
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, return exit code 201.
//
//
// INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
// Rewriten on october 2 2017 with macros.
// Cleaned in july 2019 for StabFem 2.9
// Redesigned in december 2019.
// New redesign in may 2020 (optional parameters)

		
cout << "$$$$ ENTERING Newton_2D.edp " << endl << "$$" << endl; 

include "StabFem.idp"

IFMACRO(!funcGenerateIntf)
/* Macro funcGenerateIntfU
   Generates an vector of size 1 boundary varf.
*/
macro defScalarFE(u) u // EOM
macro funcGenerateIntf(marker,FE)
varf von(defScalarFE(u),defScalarFE(v)) = on(marker,u=1);
// EOM
ENDIFMACRO

IFMACRO(!funcRestrictBound)
/* Macro funcRestrictBound
   Restricts the space FE to a set of boundary labels

   Matr -- (matrix) Transfer matrix
   marker -- (int[int]) List of ints to mark the boundary (set of labels)
   FE -- Finite Element space

  Example of utilisation: 
  Restriction matrix between full Lagrange multiplier space and fluid/structure interface space
  funcRestrictBound(f22,IrI,Ia); // Generates IrI transfer matrix

  Note. A zero coefficient is added to get the right matrix size to II,JJ and KK.
*/
macro funcRestrictBound(FE,Matr,marker)
{ 
  funcGenerateIntf(marker,FE)
  FE defScalarFE(VecU);
  VecU[]=von(0,FE,tgv=1);
  int[int]  II(VecU[].sum+1); II=0;
  int[int]  JJ(VecU[].sum+1); JJ=0;
  real[int]     KK(VecU[].sum+1); KK=0;
  II(VecU[].sum)=VecU[].sum-1;
  JJ(VecU[].sum)=FE#.ndof-1;

  int knew=0;
  for(int kold=0; kold<FE#.ndof; kold++)
  {
    if(VecU[][kold]==1)
    {
      II(knew)=knew;
      JJ(knew)=kold;
      KK(knew)=1;
      knew+=1;   
    }
  }
  matrix T = [II,JJ,KK];
  Matr = T;
}
// EOM
ENDIFMACRO


load "Element_P3"
load "Element_P4"

load "Element_PkEdge"

IFMACRO(!Pk) 
macro Pk [P2,P2,P1] //FEspace for pressure 
macro Pkstring() "P2P2P1P2P2P2" //
ENDIFMACRO


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters		
//

// 1A : Generic Parameter : Re
    real Re,Reans;

cout << "$$  Physical parameters " << endl;
Re = getARGV("-Re",0.);
cout << "Re = " << Re << endl;

// 1B : specific parameters 
IFMACRO(SFInputParametersNewton)
    // If a custom macro exists in the SF_Custom.idp file we use it
    SFInputParametersNewton;
ENDIFMACRO

IFMACRO(!SFInputParametersNewton)
    // Otherwise here are the expected physical parameters : Omegax,Symmetry (designed for rotating cylinder)
	/* Physical parameters (handled by standart input in this case) */
    cout << " Specific parameters (from getARGV)" << endl;
	string symmetryBaseFlow=getARGV("-Symmetry","S"); 
	cout << "$$ Symmetry property : " << symmetryBaseFlow << endl;
    real Omegax = getARGV("-Omegax",0.);
    cout << "$$ Rotation rate Omegax = " << Omegax << endl;
ENDIFMACRO


if (Re==0) 
{ SFerror("It is mandatory to give a value for Re using -Re (value)");
  exit(1);
};


// 1.C Numerical paramters
string IBPViscous = getARGV("-IBPViscous","D"); // either "D" or "Grad"
real tolerance=getARGV("-tolerance",1e-10);
int Nitermax=getARGV("-Nitermax", 30);
real gammaNewton    = getARGV("-gammaNewton",1.);
real isdtNewton     = getARGV("-isdtNewton",0.);
real CFLmin         = getARGV("-CFLmin",10.); 
real CFLmax         = getARGV("-CFLmin",1e30);
int DEBUG = getARGV("-DEBUG",0);

cout << "$$ NUMERICAL PARAMETERS (handled by getARGV or default ) " << endl;
cout << "$$ Fespace used : " << Pkstring << endl;
cout << "$$ Integration by parts of viscous term (D or Grad) : " << IBPViscous << endl;
cout << "$$ tolerance for Newton = " << tolerance << endl;
cout << "$$ Nitermax = " << Nitermax << endl;
cout << "$$ DEBUG MODE : " << DEBUG << endl;
if(isdtNewton!=0)
{ 
cout << "$$ Using local pseudo-timestep to stabilize Newton" << endl;
cout << " Cflmin, Cflmax : " << CFLmin << " , " << CFLmax << endl;
};

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//


		mesh th=readmesh(ffdatadir+"mesh.msh");
        fespace Xh(th,P2,periodic=MESHPERIODICITY);       //f.e. space for veloecity components
		fespace Mh(th,P1,periodic=MESHPERIODICITY);      //f.e space for pressure
		fespace XXMh(th,Pk,periodic=MESHPERIODICITY); // f.e. space for triplet [u,v,p]
        fespace XXMXXXh(th,[P2,P2,P1,P2,P2,P2],periodic=MESHPERIODICITY); // f.e. space for triplet [u,v,p,sigmaxx,sigmaxy,sigmayy]
		fespace f0(th,P0,periodic=MESHPERIODICITY);
        matrix<real> TFluidBoundaryP1;
        int[int] BoundarySlip =  [21,23];
        funcRestrictBound(Mh,TFluidBoundaryP1,BoundarySlip);



		XXMh [ux,uy,up];          ///////  -> unknown for the Navier-Stokes problem
		XXMh [vx,vy,q];          ///////  -> test function for Navier-Stokes
		XXMh [upx,upy,upp];   	 ///////  -> buffer vector  to store previous iteration (Newton) 
		XXMh [dux,duy,dup]; 		 ///////  -> increment for the Newton iteration
        XXMXXXh [uFx,uFy,uFp,uFsxx,uFsxy,uFsyy]; 
        Mh uR,duR;
		f0 dtlocal,tloc; // For definition of local time step

// Baseflow
		int testCB;
		SFcheckfile("BaseFlow_guess.txt",testCB);

    	if (testCB<0)
		{
		SFwarning("No file BaseFlow_guess.txt : starting from arbitrary initial condition");
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your SF_Custom.idp
		macro DefaultGuessForNewton
		[ux,uy,up] = [0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
		else
		{
		cout << "$$ Reading file BaseFlow_guess.txt" << endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> uFx[];
		file >> Reans;
        [ux,uy,up] = [uFx,uFy,uFp];
		cout << "$$ Re of guess field : " << Reans << endl; 
		};

IFMACRO(FREEFEMPLOTS,YES)
		plot(ux,wait=1);
		plot(uy,wait=1);
ENDIFMACRO

	cout << "$$ Starting Newton algorithm for Re = " << Re << endl;	
	

	real nu=1./Re; 
	// If Nu is something else than 1/Re define a macro CUSTOMnu in your StabFem.idp file
    IFMACRO(CUSTOMnu)
    nu = CUSTOMnu;
    ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//

//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your SF_Custom.idp file.
//

	
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO	
	
IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,u,v)
	           on(1,du#x=Uinlet-u#x,du#y=0.0)
	         + on(2,du#x=-u#x+Omegax*y,du#y=-u#y-Omegax*x) /* if rotation */
	         + on(4,du#y=-u#y)  
             + on(5,du#x=-u#x)
             + int1d(th,6)(du#x*v#x*1e30*(symmetryBaseFlow=="A")+du#y*v#y*1e30*(symmetryBaseFlow=="S"))
             + int1d(th,6)(u#x*v#x*1e30*(symmetryBaseFlow=="A")+u#y*v#y*1e30*(symmetryBaseFlow=="S"))         
//EOM
ENDIFMACRO


IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(6,2,21,22,23,psi=0)
					         + on(1,4,psi=y);
//EOM
ENDIFMACRO  



IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1,periodic=MESHPERIODICITY);  
    p1forff2m vort;
	vort=-dy(u#x)+dx(u#y); /* vorticity */
	p1forff2m psi,test; 
	CalcPsi(psi,vort,test);
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
    string storagemode = "Re"+Pkstring+".1";
    file << "datatype " << typeFlow << " datastoragemode " << storagemode << " datadescriptors ux,uy,p,tauxx,tauxy,tauyy,Re" << endl;
	file << "real* Re P1 vort P1 psi real iter " << endl ;
	file << Re << endl;	
			for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
	};
	}
//EOM
ENDIFMACRO

/////////////////////////////////////////////////////////////////////////////////
/////// macro to define some useful operators

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 
macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] 
// macro for rate-of-deformation tensor
macro GRAD(u) [[dx(u#x), dy(u#x)], [dx(u#y), dy(u#y)]] 
// macro for Gradient tensor

macro defTen(u) ( sqrt(2*(D(u):D(u)))  ) // gamma
macro muTen(u,alpha,nCar)  (  ( 1.0 + (alpha*defTen(u))^2.0)^((nCar-1.0)*0.5)  )         //  Carreau's law
macro muTenLin(du,u,alpha,nCar) (2.*((nCar-1.0)*alpha^2*( 1.0 + (alpha*defTen(u))^2.0 )^((nCar-3.0)*0.5) )*(D(u):D(du))  ) //

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//
real alpha=1e-6;
real delta = 1;
real alphaCarr = 1;
real nCarr = 0.8;
macro sigmaNewtonian(u,p) (-p+2*nu*[N.x,N.y]'*D(u)*[N.x,N.y]) // EOM
macro sigma(u,p) (-p+2*muTen(u,alphaCarr,nCarr)*[N.x,N.y]'*D(u)*[N.x,N.y]) // EOM
macro sigmaLin(du,u,dp) (-dp+2*muTenLin(du,u,alphaCarr,nCarr)*[N.x,N.y]'*D(u)*[N.x,N.y]+2*muTen(u,alphaCarr,nCarr)*[N.x,N.y]'*D(du)*[N.x,N.y] ) // EOM

varf vLNS([dux,duy,dup],[vx,vy,q])= -int2d(th)( 2*muTen(up,alphaCarr,nCarr)*(D(du):D(v)) + 2*muTenLin(du,up,alphaCarr,nCarr)*(D(up):D(v)) - q*div(du) - div(v)*dup ) - int1d(th,21,23)(  - alpha*(sigmaLin(du,up,dup)*delta*sigmaNewtonian(v,q))  )  + BoundaryconditionsBaseFlow(du,up,v);     
varf vLNSLambda([duR],[vx,vy,q])= -int1d(th,21,23)(duR*vx*N.x+duR*vy*N.y - alpha*(duR*delta*sigmaNewtonian(v,q)) );  
varf vLambdaLNS([dux,duy,dup],[vR])= -int1d(th,21,23)(dux*vR*N.x+duy*vR*N.y  - alpha*(sigmaLin(du,up,dup)*vR) );  
varf vLambdaLambda(duR,vR) = -int1d(th,21,23)(-alpha*duR*vR);

varf vNS([dux,duy,dup],[vx,vy,q])= int2d(th)(2*muTen(up,alphaCarr,nCarr)*(D(up):D(v)) - q*div(up) - div(v)*upp) + BoundaryconditionsBaseFlow(du,up,v);  
varf vNSLambda([duR],[vx,vy,q])= int1d(th,21,23)(uR*vx*N.x+uR*vy*N.y - alpha*(uR*delta*sigmaNewtonian(v,q)+sigma(up,upp)*delta*sigmaNewtonian(v,q)) );  
varf vLambdaNS([dux,duy,dup],[vR])= int1d(th,21,23)(upx*vR*N.x+upy*vR*N.y - alpha*(uR*vR+sigma(up,upp)*vR)  );  


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//    
   
   
// parameters for Newton loop            

    real res=1; // residual
    real res0=1; // residual at previous iteration	
    int iter=0;
    real enerl2=1;
        
// Newton loop
        while((enerl2>tolerance)&(res<100)&(iter<=Nitermax))
        {
            iter++;	
            real errorratio = res/res0;
            matrix mLNS = vLNS(XXMh,XXMh);
            real[int] ffRHS = vNS(0,XXMh);
            real[int] ffRHSNSLambdaT = vNSLambda(0,XXMh); 
            real[int] ffRHSLambdaNST = vLambdaNS(0,Mh); real[int] ffRHSLambdaNS = TFluidBoundaryP1*ffRHSLambdaNST; 

            matrix mLNSLambdaT = vLNSLambda(Mh,XXMh); matrix mLNSLambda = mLNSLambdaT*TFluidBoundaryP1';
            matrix mLambdaLNST = vLambdaLNS(XXMh,Mh); matrix mLambdaLNS = TFluidBoundaryP1*mLambdaLNST;
            matrix mLambdaLambdaT = vLambdaLambda(Mh,Mh); matrix mLambdaLambda = TFluidBoundaryP1*mLambdaLambdaT; mLambdaLambda = mLambdaLambda*TFluidBoundaryP1';
            real[int] RHSNS = ffRHS+ffRHSNSLambdaT;
            real[int] RHS = [RHSNS,ffRHSLambdaNS];
            matrix matA = [  [mLNS, mLNSLambda], [mLambdaLNS, mLambdaLambda]  ];
            set(mLNS,solver=sparsesolver);
            set(matA,solver=sparsesolver);
            real[int] dX(matA.n);
            dX = matA^-1*RHS;
            int iPos = 0;
            dux[] = dX(iPos:iPos+mLNS.n-1); iPos += mLNS.n;
            duR[] = TFluidBoundaryP1'*dX(iPos:iPos+TFluidBoundaryP1.n-1); iPos += TFluidBoundaryP1.n;

            ux[] = ux[]+dux[];
            uR[] = uR[]+duR[];
            upx[]=ux[];  
            enerl2=dux[].l2;
            res0 = res;
            res=sqrt(int2d(th)(dux^2+duy^2)/th.area);
            cout << "$$ Iter = "<< iter << "   Re = " << Re << " ; res = " << res << " ; res l2 = " << enerl2 << endl;
            plot(ux,wait=0,fill=1,value=1,cmm="ux");
		
		if (DEBUG==1)
		{
			ofstream file(ffdatadir+"DEBUG/U_Iter"+FixedFormatInt(iter,6)+".txt"); 		    
			file << ux[]; 
		    SFWriteBaseFlow(ffdatadir+"DEBUG/U_Iter"+FixedFormatInt(iter,6)+".ff2m",u,"Iteration",iter);
		    ofstream file2(ffdatadir+"DEBUG/DU_Iter"+FixedFormatInt(iter,6)+".txt"); 		    
			file2 << dux[]; 
		    SFWriteBaseFlow(ffdatadir+"DEBUG/DU_Iter"+FixedFormatInt(iter,6)+".ff2m",u,"DUIteration",iter);
		 }; 
           // file in .ff2ml format for StabFem driver

	  } ;

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//    
   

// sortie des r?sultats 

		if((res>50)||(iter>Nitermax))
		{
			SFerror("$$ NEWTON ITERATION FAILED");
			cout << "$$ Leaving FreeFem++ with error code 201" << endl;
			exit(201);
		}
		else
		{

		plot(ux,wait=1);

		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
          [uFx,uFy,uFp,uFsxx,uFsxy,uFsyy] = [ux,uy,up,2/Re*(dx(ux)),1/Re*(dx(uy)+dy(ux)) ,2/Re*(dy(uy))];
		  file << uFx[]; 
		  file << endl  << Re;
          real Omegaxforfile = Omegax; // LEGACY ; to be removed completely someday
		  file << endl  << Omegaxforfile << endl;
		  }; 
          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver

    
		};
          
cout << "$$$$ SUCESSFULLY LEAVING Newton_2D.edp "  << endl; 
