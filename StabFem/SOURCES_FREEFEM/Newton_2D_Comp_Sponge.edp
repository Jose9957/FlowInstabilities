//
//  PROGRAM Newton_2D_Comp.edp
//  computation of 2D compessible base flow [ux,uy,p,T,rho](x,y)
//  Sponge version
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Incorporated by David Fabre from a code of Flavio
// Updated by Javier Sierra.

///////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUDE FILES
load "MUMPS"
load "scotch";
include "StabFem.idp";
///////////////////////////////////////////////////////////////////////////////////////////////
real ts;
string ssparams = "nprow=1, npcol="+mpisize;
bool fplot=false;
int comp=0;
///////////////////////////////////////////////////////////////////////////////////////////////
// INPUT PARAMETERS FROM USER
real Re,Reans,Ma,Maans,Omegax,Omegaxans;
string symmetryBaseFlow;
if(mpirank==0)
{
	cout << " Enter Reynolds Number ?' " << endl;
	cin >> Re;

	cout << " Enter Mach Number ?' " << endl;
	cin >> Ma;

	cout << " Enter rotational speed of the cylinder " << endl;
	cin >> Omegax;

	cout << "$$ Enter symmetry property of base flow  ? ('N','S', or 'A') >> ";
    cin >> symmetryBaseFlow;
    cout << symmetryBaseFlow << endl;
}
broadcast(processor(0),Re); 
broadcast(processor(0),Ma); 
if(mpirank==0) cout << endl << " >>> RE = " << Re << "  Mach = " << Ma << " Omegax =  " << Omegax <<endl;
//////////////////////////////////////////////////////////////////////////////////////////////
// Physical parameters
real gamma=1.4; 
real Pr=0.7;
real nu=1./Re;    
///////////////////////////////////////////////////////////////////////////////////////////////
mesh th;
if(mpirank==0)
{ 
	th=readmesh(ffdatadir+"mesh.msh");
	int[int] nupart(th.nt);
	nupart=0; 
	if(mpisize>1)
	scotch(nupart, th, mpisize);
	th=change(th,fregion= nupart[nuTriangle]);
}
broadcast(processor(0),th); 
//////////////////////////////////////////////////////////////////////////////////////////////
real TOLLERANCENewton=1e-9;  /// tollerance of newton loop
int NITERATIONNEWTLOOP=40;  //////////////  Max number of ITERATIONs --> Newton loop
real TOLLERANCEDiv = 20.0; // Tolerance to reset initial condition due to divergence of the Newton method.
///////////////////////////////////////////////////////////////////////////////////////////////
fespace XH2(th,P2);
fespace XXxxxH(th,[P2,P2,P1,P1,P1]); ///   pres P1 + vel 2x P2 + temp P1 + dens P1
///////////////////////////////////////////////////////////////////////////////////////////////
macro defU(u,p,T,rho)[u#x,u#y,p,T,rho]//EOF
macro defUU(u)[u#x,u#y,u#p,u#T,u#rho]//EOF  
XXxxxH defUU(du);
XXxxxH defUU(Ub);
///////////////////////////////////////////////////////////////////////////////////////////////
XXxxxH defU(Urif,Prif,Trif,Rhorif)=[1.0,0.0,1.0,1.0,1.0];
///////////////////////////////////////////////////////////////////////////////////////////////
XH2 AMPFORCE;

IFMACRO(!SFSPONGE)
macro SFSPONGE()
	func real AmpSponge(real M, real xinf, real xsup, real yinfsup)  
	{
	  if(M>0)
	    return abs(1.+1./M)*(x>xsup)*(alpha*(x-xsup))+abs(1.-1./M)*(x<xinf)*(alpha*(xinf-x))+abs(1./M)*(abs(y)>yinfsup)*(alpha*(abs(y)-yinfsup));
	  else
	    return 0.0;
	}
	AMPFORCE=AmpSponge(Ma,xinfm,xinfv,yinf);
//EOM
ENDIFMACRO
// Define Sponge function and field
SFSPONGE


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//
//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your SF_Custom.idp file.
//
	
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO	

IFMACRO(!Vinlet)
macro Vinlet() 0. //EOM
ENDIFMACRO	

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,Ub,us)
	           on(1,du#x=Uinlet(y)-Ub#x,du#y=Vinlet(y)-Ub#y,du#rho=1.-Ub#rho,duT=1.-Ub#T)
	         + on(3,du#x=Uinlet(y)-Ub#x,du#y=0.0-Ub#y,du#rho=1.-Ub#rho,duT=1.-Ub#T)  
             + on(2,du#x=0.0-Ub#x,du#y=0.0-Ub#y)
             + int1d(th,6)(du#x*us#x*1e30*(symmetryBaseFlow=="A")+du#y*us#y*1e30*(symmetryBaseFlow=="S"))       
//EOM
ENDIFMACRO

IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,rho,test)
      solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(rho*vort*test)
					         + on(6,2,21,22,23,psi=0)
					         + on(1,3,psi=y);
//EOM
ENDIFMACRO     

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
		fespace p1forff2m(th,P1);  
	    p1forff2m vort,divergence;
		vort=dy(u#x)-dx(u#y); /* vorticity */
	    divergence=dx(u#x)+dy(u#y); 
		ofstream file(filename);
	   	{
		file << "### Data generated by Freefem++ ; " << endl;
	    file << typeFlow << " for a 2D-compressible problem " << endl;
	    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1P1P1.2 datadescriptors ux,uy,p,T,rho,Re,Ma" << endl;
		file << "real* Re real* Ma P1 vort P1 div real iter " << endl << endl ; 
		file << Re << endl;	
	    file << Ma << endl;
				for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	            for (int j=0;j<vort[].n ; j++) file << divergence[][j] << endl;
				file << iter << endl;
		}
	}; 
// EOM
ENDIFMACRO

///////////////////////////////////////////////////////////////////////////////////////////////
int testCB = exec("ls "+ffdatadir+"/BaseFlow_guess.txt");
if (testCB!=0)
{
	if(mpirank==0) cout << "$$ No file BaseFlow_guess.txt : starting from arbitrary initial condition" << endl;
	IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefUined in your Macro_StabFem.idp
	macro DefaultGuessForNewton
		defUU(Ub) = [1.0,0.0,1.0,1.0,1.0]; //EOM
	ENDIFMACRO
	DefaultGuessForNewton;
} 
else
{
	if(mpirank==0) cout << "$$ Reading file BaseFlow_guess.txt" << endl;
	ifstream file(ffdatadir+"BaseFlow_guess.txt");
	file >> Ubx[];
	file >> Reans;
	file >> Maans;
	file >> Omegaxans;
	if(mpirank==0) cout << "$$ Re of guess field : " << Reans << endl; 
	if(mpirank==0) cout << "$$ Ma of guess field : " << Maans << endl; 
	if(mpirank==0) cout << "$$ Omegax of guess field : " << Omegaxans << endl; 
};
///////////////////////////////////////////////////////////////////////////////////////////////
macro div(u) ((dx(u#x)+dy(u#y)))   //EOM
macro ugradf(u,f) ((u#x*dx(f)+u#y*dy(f)))    //
macro termnonlinear(u,v,w) ((w#x*(u#x*dx(v#x)+u#y*dy(v#x))+w#y*(u#x*dx(v#y)+u#y*dy(v#y)))) //
macro Grad(u) [[dx(u#x),dx(u#y)],[dy(u#x),dy(u#y)]]//EOM
macro Strain(u)[[dx(u#x),0.5*(dx(u#y)+dy(u#x))],[0.5*(dx(u#y)+dy(u#x)),dy(u#y)]]//EOM
macro gradgrad(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

varf jacobian(defUU(du),defUU(us))=int2d(th)
										(
										usrho*(durho*div(Ub)+Ubrho*div(du)+ugradf(Ub,durho)+ugradf(du,Ubrho)) 
								       //mass equation
								       -dup/(gamma*Ma^2)*div(us)+2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))
								       +Ubrho*termnonlinear(du,Ub,us)+durho*termnonlinear(Ub,Ub,us)+Ubrho*termnonlinear(Ub,du,us)
								       //momentum
								  		+usT*(durho*ugradf(Ub,UbT)+Ubrho*ugradf(Ub,duT)+Ubrho*ugradf(du,UbT)+(gamma-1)*(div(Ub)*(dup) 
								  		+ Ubp*div(du))-gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(du):Strain(Ub))+(Strain(Ub):Strain(du)))
								  		-2.0/3.0*(2.0*div(Ub)*div(du))))+gamma/(Pr*Re)*gradgrad(duT,usT)
								       // energy
								       +usp*(dup-(durho*UbT+Ubrho*duT))
								  		)
								  		+int2d(th)(AMPFORCE*(usy*duy+usx*dux+usT*duT+usrho*durho))
  										+BoundaryconditionsBaseFlow(du,Ub,us);


varf vNs(defUU(du),defUU(us))=-int2d(th)(
								usrho*(Ubrho*div(Ub)+ugradf(Ub,Ubrho))
							   //mass equation
							   -Ubp/(gamma*Ma^2)*div(us)+2.0/Re*(Strain(Ub):Grad(us))
							   -2.0/(3.0*Re)*(div(Ub)*div(us))+Ubrho*termnonlinear(Ub,Ub,us)
							   //momentum
								+usT*(Ubrho*ugradf(Ub,UbT)+(gamma-1)*Ubp*div(Ub)
								   -gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(Ub):Strain(Ub)))-2.0/3.0*(div(Ub)*div(Ub))))
								   +gamma/(Pr*Re)*gradgrad(UbT,usT)
							   // energy
							   +usp*(Ubp-(Ubrho*UbT))
							   )
							   -int2d(th)(AMPFORCE*(usy*(Uby-Urify)+usx*(Ubx-Urifx)+usT*(UbT-Trif)+usrho*(Ubrho-Rhorif)))
  							   +BoundaryconditionsBaseFlow(du,Ub,us);

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

real res,ener=1.;
if(mpirank==0)
{
	cout << " ................................................... "<< endl;	
	cout << " ................................................... "<< endl;	
}
int contout=0;

///////////////////////////NEWTON ITERATION////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
int i=0;
while((ener>TOLLERANCENewton)&(i<=NITERATIONNEWTLOOP))
{
	ts=clock();

	matrix NewtLoc=jacobian(XXxxxH,XXxxxH);
	matrix Newt;
	mpiAllReduce(NewtLoc,Newt,mpiCommWorld,mpiSUM);
	if(mpirank==0)
		cout<<"Matrix formed in "<<clock()-ts<<" s"<<endl;  
	real[int] rhsl= vNs(0,XXxxxH);
	real[int] rhs(Newt.n);
	mpiAllReduce(rhsl,rhs,mpiCommWorld,mpiSUM);
	set(Newt,solver=sparsesolver,sparams=ssparams);
	dux[] =  (Newt^-1*rhs);
	ener=sqrt(int2d(th)(abs(duy)^2+abs(dux)^2)); 
	if(mpirank==0)
	{
		cout << "iter "<<i<<" | sqrt(int2d(th)(dux^2+duy^2)) = " << ener << endl;
	}
	Ubx[]+=dux[];
	i++;	    

}// end of NEWTON LOOP
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
if(mpirank==0)
{
	cout << " -------------------------------------------------------- "<< endl;	
	cout << " Newton iteration ok!"<< endl;
};

XXxxxH [ux,uy,up,uT,urho] = defUU(Ub);
{
  {
	  ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
	  file << ux[]; 
	  file << endl << endl << Re << endl << Ma << endl << Omegax << endl;
	  exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
  }; 
  SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",i); // file in .ff2ml format for StabFem driver
};
///////////////////////////////////////////////////////////////////////////////////////////////








