//
//  PROGRAM ArcLengthContinuation2D.edp
//  computation of 2D arc length continuation of a 2D planar flow with alpha (rotation rate as parameter)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Omegax
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Done by J. Sierra with help D. Fabre.


//////////////
include "StabFem.idp";

real ts;
bool fplot=false;
int comp=0;

IFMACRO(!SFWriteBaseFlowAC)
macro SFWriteBaseFlowAC(filename,u,typeFlow,iter)
	if(iter>=0)
	{
		fespace p1forff2m(th,P1);  
		p1forff2m xx,yy; 
		xx=x; yy=y;
	    p1forff2m vort;
		vort=dy(u#x)-dx(u#y); /* vorticity */
		p1forff2m psi,phi; /* stream function ; may not work in all cases */
		solve Laplace(psi,phi) = int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi))-int2d(th)(-vort*phi)+on(1,psi=y)+on(3,6,psi=y)+on(2,psi=0);  
		ofstream file(filename);
	   	{
		file << "### Data generated by Freefem++ ; " << endl;
	    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
	    file << "datatype BaseFlow datastoragemode ReP2P2P1.1 datadescriptors ux,uy,p,Re" << endl;
		file << "real Re real Omegax real tangent1 real tangent2 P1 vort P1 psi real iter " ;
		string PostProcessBaseFlowDescription = "real Fx real Fy real Lx"; /* customizable output */ 
		file << PostProcessBaseFlowDescription << endl << endl ; 
		file << Re << endl;	
	    file << Omegax << endl;	
	    file << DFyDs << endl;	
	    file << DReDs << endl;	
				for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
				for (int j=0;j<psi[].n ; j++) file << psi[][j] << endl;
				file << iter << endl;
		}
	}
//EOM
ENDIFMACRO


real Re,Reans,Omegax,Re0,DReG,Omegaxans,RePrev;
real dS,DFyDsp,DReDsp;
string symmetryBaseFlow;

cout << " Enter the step for the pseudo-arclength method " << endl;
cin >> dS;

cout << " Enter previous derivative in direction DFyDs " << endl;
cin >> DFyDsp;

cout << " Enter previous derivative in direction DFyDs " << endl;
cin >> DReDsp;

cout << " Symmetry of the mesh ('N'-None , 'A'-Antisymmetric, 'S'-Symmetric) " << endl;
cin >> symmetryBaseFlow;


mesh th;
th=readmesh(ffdatadir+"mesh.msh");

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////

real TOLLERANCENewton=1e-9;  /// tollerance of newton loop
int NITERATIONNEWTLOOP=40;  //////////////  Max number of ITERATIONs --> Newton loop
real TOLLERANCEDiv = 20.0; // Tolerance to reset initial condition due to divergence of the Newton method.

	
fespace Xh(th,P2);       //f.e. space for veloecity components
fespace Mh(th,P1);      //f.e space for pressure
fespace XXMh(th,[P2,P2,P1]); // f.e. space for triplet [u,v,p]
XXMh [Derux,Deruy,Derup];
XXMh [DuGx,DuGy,DuGp];          
XXMh [u0x,u0y,u0p];          
XXMh [ux,uy,up];          ///////  -> unknown for the Navier-Stokes problem
XXMh [vx,vy,q];          ///////  -> test function for Navier-Stokes
XXMh [dux,duy,dup]; 		 ///////  -> increment for the Newton iteration
XXMh [upx,upy,upp];   	 ///////  -> buffer vector  to store previous iteration (Newton) 
real DReDs,DFyDRe,DFyDs;
real dRe=0.0;


int testCB = 0;
try{ ifstream file(ffdatadir+"BaseFlow_guess.txt"); }
catch(...){testCB = 1; cout << "$$ NB : this 'ERROR' message is normal at this stage, the error was correcty caughth by StabFem. Relax !"; };

//	int testCB = exec("ls "+ffdatadir+"/BaseFlow_guess.txt");
// ne marche pas avec windows !

if (testCB!=0)
{
	cout << "$$ No file BaseFlow_guess.txt : strarting from arbitrary initial condition" << endl;
	IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
	macro DefaultGuessForNewton
	[ux,uy,up] = [0,0,0]; //EOM
	ENDIFMACRO
	DefaultGuessForNewton;
} 
else
{
	cout << "$$ Reading file BaseFlow_guess.txt" << endl;
	 ifstream file(ffdatadir+"BaseFlow_guess.txt");
	file >> ux[];
	file >> Reans;
	file >> Omegaxans;
	Re = Reans; Omegax = Omegaxans;
	cout << "$$ Re of guess field : " << Reans << endl; 
};

cout << endl << " >>> RE = " << Re << " Omegax =  " << Omegax <<endl;
	    
//////////////////////////////////////////////////////////////////////////////////////////////

real nu=1./Re;    

cout << "$$ Starting Newton algorithm for Re = " << Re << endl;	
	

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 
macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor

macro Lift(u)   
	(
	(
	int1d(th,2,21,22,23)(u#p*N.y)
	-int1d(th,2,21,22,23)( nu*(2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x) )
	)
	) 
//EOM

  macro Drag(u)   
	(
		int1d(th,2,21,22,23)(u#p*N.x)
	    -int1d(th,2,21,22,23)( nu*(2*dx(u#x)*N.x + (dx(u#y)+dy(u#x))*N.y) )
	)
//EOM


varf jacobian([dux,duy,dup],[vx,vy,q])=int2d(th)( 
			-2*nu*(D(du):D(v))
             + q*div(du)
             + div(v)*dup
				-Conv(up,du,v)
             )
	+  BoundaryconditionsBaseFlow(du,up,v);     

varf vNs([dux,duy,dup],[vx,vy,q])=-int2d(th)(
    		-2*nu*(D(up):D(v))
             + q*div(up)
             + div(v)*upp
             -.5*Conv(up,up,v)
             )			   
  +  BoundaryconditionsBaseFlow(du,up,v);     


varf DerFyDu([vx,vy,q],[dux,duy,dup])=int1d(th,2,21,22,23)(dup*N.y)
	-int1d(th,2,21,22,23)( nu*(2*dy(duy)*N.y+  nu*(dx(duy)+dy(dux))*N.x));
varf OrthoQ([vx,vy,q],[dux,duy,dup])=int2d(th)((Derux*dux+Deruy*duy+Derup*dup));
varf LiftV([vx,vy,q],[dux,duy,dup])=int1d(th,2,21,22,23)(dup*N.y) - int1d(th,2,21,22,23)( nu*(2*dy(duy)*N.y+(dx(duy)+dy(dux))*N.x));
varf vNsDRe([dux,duy,dup],[vx,vy,q])=int2d(th)(2*(1/Re^2)*(D(up):D(v)));

real res,ener=1.;

cout << " ................................................... "<< endl;	
cout << " ................................................... "<< endl;	

int contout=0;
 
res=1.0;
ener=1.0;
int i=0,iter=0;
real tol = 1e-6;

// Computation of the Gradient. Tangent of pseudo-arc continuation
cout << "Computation of the initial tangent diff" << endl;
cout << " Initial Lift = " << Lift(u) << endl;
cout << " Initial Drag = " << Drag(u) << endl;



/*
matrix JacG=jacobian(XXMh,XXMh);
set(JacG,solver=sparsesolver);
u0x[] = ux[]; // Save initial ux
real[int] NSRe0 =  vNs(0,XXMh);
Re += 1e-4;
real[int] NSRe1 =  vNs(0,XXMh);

// Newton loop
real tolerance=2e-12;
int Nitermax=30;
iter=0;
res = 1;
while((res>1e-8)&(res<50)&(iter<=Nitermax))
{
	upx[]=ux[];      
	NewtonIter ;          
	ux[] = ux[]+dux[];
	real enerl2=dux[].l2;
	res=sqrt(int2d(th)(dux^2+duy^2)/th.area);
	cout << "$$ Iter = "<< iter+1 << "   Re = " << Re << " ; res = " << res << " ; res l2 = " << enerl2 << endl;
	iter++;
} ;
// return to initial values
Re -= 1e-4;
real[int] DerNSDRe = (NSRe0-NSRe1);
DerNSDRe /= 1e-4;
Derux[] = (ux[] - u0x[]);
Derux[] /= 1e-4;
DFyDRe = Lift(Deru);
DFyDs = DFyDRe/sqrt(1+DFyDRe^2);
DReDs = DReDsp/abs(DReDsp)/sqrt(1+DFyDRe^2);
*/





upx[] = ux[]; // To evaluate vNsDRe
real[int] DerNSDRe = vNsDRe(0,XXMh,tgv=-1);
matrix JacG=jacobian(XXMh,XXMh,tgv=-1);
real[int] DerFyDq = DerFyDu(0,XXMh);
set(JacG, solver=sparsesolver);
real[int] DeruDRe = JacG^-1*DerNSDRe;
DeruDRe *= -1;
DFyDRe = DerFyDq'*DeruDRe;
DFyDs = DFyDRe/sqrt(1+DFyDRe^2);
DReDs = DReDsp/abs(DReDsp)/sqrt(1+DFyDRe^2);


real scalarProduct = DFyDsp*DFyDs + DReDsp*DReDs;
if(scalarProduct < 0)
{
	DFyDs*=-1.0;
}

if(abs(DReDs) < abs(DReDsp) && DReDs < 0.05 && DReDs*DReDsp>0)
{
	DReDs*=-1.0;
}

 // Change sign to be monotonous (do not continue in the oposite sense).
// Return initial values
ux[] = u0x[];
upx[] = ux[];

cout << "Tangents : " << DFyDs << " " << DReDs << endl;
cout << "End of the computation of the initial tangent " << endl;


// PREVIOUS state
Re0 = Re;
u0x[]=ux[];

cout << "###### Prediction step ######" << endl;
ux[] += dS*DReDs*Derux[];
Re = Re + dS*DReDs;
cout << "NEW Reynolds number, Re = " << Re << endl;
real dXX = 1;
iter=1;

cout << "###### Corrector step ######" << endl;
while(abs(dXX)>tol&&abs(dXX)<1e6&&iter<100)
{ 
	cout << endl << "Iteration : " << iter << " of the Newton step"<< endl;
	upx[]=ux[];
	// Update the difference w.r.t. the state previous the predictor
	DuGx[] = ux[]- u0x[];
	DReG = Re - Re0;   
	// Assemble system
    matrix mat11=jacobian(XXMh,XXMh,tgv=-1);
    real[int] mat12 = DerNSDRe;
    real[int] mat21 = LiftV(0,XXMh,tgv=-1);
    real mat22 = DReDs;
    real[int] RHS1 = vNs(0,XXMh,tgv=-1);
    real RHS2 = dS - mat22*DReG - mat21'*DuGx[];
	real[int] RHS = [RHS1, RHS2];
	cout << " Assembling matrix..." << endl;
	matrix LinOp = [[mat11,mat12],
					[mat21',  mat22]];
	cout << " Assembling matrix... done" << endl;
	cout << " LU-ing matrix..." << endl;
	set(LinOp,solver=sparsesolver);
	cout << " LU-ing matrix... done" << endl;
	cout << " solving BIG problem..." << endl;
	real[int] dX(LinOp.n);
	dX = LinOp^-1*RHS;
	[dux[], dRe] = dX;
	ux[] += dux[];
	DReG += dRe;
	cout << endl << "   ### ||du0||, dRe : " << dux[].l2 
			<< " "  << dRe << endl;
	dXX = dux[].l2+dRe;
	
	cout << "   ### ||u0|| : " << ux[].l2 
			<< endl;
	cout <<  "   ### Re = " << Re << endl;
	cout << " Lift = " << Lift(u) << endl;
	cout << " Drag = " << Drag(u) << endl;

	iter++;

};

// SAVE


  
  ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
  file << ux[]; 
  file << endl << endl << Re << endl << Omegax << endl;
  
  exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
  exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BASEFLOWS/BaseFlow_ArcLength.txt"); 
  SFWriteBaseFlowAC(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",i); // file in .ff2ml format for StabFem driver
  exec("cp "+ffdatadir+"BaseFlow.ff2m "+ffdatadir+"BASEFLOWS/BaseFlow_ArcLength.ff2m"); 





	    
	    
	  

