/* =======================================

	Computation of Axisymmetric base flow with 3 velocity components 	
   ======================================= 

	PROGRAM Newton_AxiSwirl.edp
	Computation of Axisymmetric base flow [ux,ur,uphi](x,y)

	THIS FILE IS ADAPTED FROM Newton_Axi.edp

	INPUT PARAMETERS (from keyboard or pipe) :
		Re, ROTATION
	INPUT FILES :		
		mesh.msh 			 -> Mesh in Freefem format
		(BaseFlow_guess.txt) -> Guess base flow (generated by mesh generator, time integration or previous Newton)
							   ( if this file is absent the program will start from zero, 
							     unless a macro DefaultGuessForNewton is defined )
	OUTPUT FILES :
		BaseFlow.txt		 -> Base flow (FF format)
		BaseFlow.ff2m		 -> Base flow (FF2M format) 

	ERROR MANAGEMENT : 
		if Newton iteration diverges, error code is 201.

	History : 
	INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
	REwriten on october 2 2017 with macros.
	REWRITTEN with Adrien in 2028
	Upgraded to SF 2.9 july 2019 in Sapporo
	Simplified in january 2020 
...................................................... */

 /* ---------------------
		Import Macros 
    --------------------- */


	include "StabFem.idp";

/*  ------------------
		Param�tres 
    ------------------ */
	
	real Reans,lecture;
	real Uinfx = 1;
	
	real Re=getARGV("-Re",1.0);
	cout << "$$ Enter Reynolds number : " << Re << endl;
    real Omegax = getARGV("-Omegax",0.);
    cout << "$$ Rotation rate Omegax = " << Omegax << endl;		

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//

		
/*  -----------------------
		READING MESH and defining fe-spaces
    ----------------------- */
	
	mesh th = readmesh(ffdatadir+"mesh.msh");
	IFMACRO(FREEFEMPLOTS,YES)
		plot(th,wait=0);
	ENDIFMACRO

/*  ------------------
		Espaces EF 
    ------------------ */

IFMACRO(!MESHPERIODICITY)
macro MESHPERIODICITY() [[41,y],[42,y]] //EOM
ENDIFMACRO
// In case there are boundaries labelled 41,42 they are handled as periodic ; otherwise this definition has no effect

	fespace Xh(th,P2,periodic=MESHPERIODICITY);					//f.e. space for Velocity components
	fespace Mh(th,P1,periodic=MESHPERIODICITY);					//f.e. space for Pressure
	fespace XXMh(th,[P2,P2,P1],periodic=MESHPERIODICITY);		//f.e. space for Triplet [u,v,p]
	fespace XXXMh(th,[P2,P2,P2,P1],periodic=MESHPERIODICITY);	//f.e. space for Quadruplet [u,v,w,p]

	XXXMh [ux,ur,uphi,up]; 				// -> unknown for the Navier-Stokes problem
	XXXMh [vx,vr,vphi,vp];				// -> test function for Navier-Stokes
	XXXMh [upx,upr,upphi,upp];			// -> buffer vector to store previous iteration (Newton) 
	XXXMh [dux,dur,duphi,dup];			// -> increment for the Newton iteration
	XXMh [uaxix,uaxir,uaxip];			// -> unknown for the Navier-Stokes problem
		
		
/*  ---------------------------
		READING BASEFLOW
    --------------------------- */

	int NdimUVP = uaxix[].n;
	int NdimUVWP = ux[].n;
	
	int NdimBaseFlow;
	SFcheckfile("BaseFlow_guess.txt",NdimBaseFlow)	
	
    if (NdimBaseFlow<0)
		{
		cout << "$$ No file BaseFlow_guess.txt : strarting from arbitrary initial condition" << endl;
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
		macro DefaultGuessForNewton
		[ux,ur,uphi,up] = [0,0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
	else if(NdimBaseFlow == NdimUVP) 
		{
        cout << "Ndim = " << NdimUVP << " : reading UVP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> uaxix[];
        [ux,ur,uphi,up] = [uaxix,uaxir,0,uaxip];
		file >> Reans;
        }
	else if(NdimBaseFlow == NdimUVWP) 
        {
        cout << "Ndim = " << NdimUVWP << " : reading UVWP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[]; 
		file >> Reans;
        }
	else 
        {
        cout << " Error : Wrong dimension For BaseFlow_guess.txt file" << endl;
        };

	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl;
	real nu = 1./Re;
     // If Nu is something else than 1/Re define a macro CUSTOMnu in your  .idp file
    IFMACRO(CUSTOMnu)
    nu = CUSTOMnu;
    ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//

/*  -----------------------
		Customizable macros for boundary conditions and postprocessing
		(The ones defined here are default ones ; don't change them ! 
		if you want to customize paste them in your SF_Custom.idp file) 
    ----------------------- */



// A. Boundary conditions 

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,up,v)
               on(2,du#x=0.0,du#r=0.0,du#phi=Omegax*y-u#phi)
             + on(1,du#x=1.-u#x,du#r=0.0,du#phi=0.0)
             + on(6,du#r=0.0,du#phi=0.0) ;     
//EOM
ENDIFMACRO
// NB this macro is for rotating bluff bodies (for instance rotating sphere)
// for other cases (Taylor-Couette, etc...) the one actully used is in SF_Custom.idp


// B. Post-processing
      

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
    fespace p1forff2m(th,P1);  
    p1forff2m vort,psi,test; 
	vort=-dy(u#x)+dx(u#r);
	ofstream file(filename);
   	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for an axisymmetric incompressible problem" << endl;
    file << "datatype " << typeFlow << " datastoragemode ReP2P2P2P1.1 datadescriptors ux,ur,uphi,p,Re" << endl;
    file << "real* Re real* Omegax real iter P1 vort P1 psi" ; 
	CalcPsi(psi,vort,test)  
	string PostProcessBaseFlowDescription = " " ; 
	file << PostProcessBaseFlowDescription << endl << endl ; 
	file << Re << endl << Omegax << endl;	
	file << iter << endl << endl;
    for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	for (int j=0;j<psi[].n ; j++)  file << psi[][j]  << endl;
	};
//EOM
// NB this macro is a minimal one ; if using a customized version see SF_Custom.idp 
ENDIFMACRO

// C. Differential operators
/* Macro for Divergence  */
	macro div(im,u) (dx(u#x)+dy(u#r)+u#r/y+im/y*u#phi)//EOM

/* Macro for Vecocity gradient tensor  */
	macro Grad(im,u) [
			[dx(u#x),	dy(u#x),	im/y*u#x ], 
			[dx(u#r),	dy(u#r),	im/y*u#r-u#phi/y],
			[dx(u#phi),	dy(u#phi),	im/y*u#phi+u#r/y ]
			]//EOM

/* Macro for Rate-of-deformation tensor  */
	macro D(im,u) [	
				[dx(u#x),					.5*(dx(u#r)+dy(u#x)),				.5*(im/y*u#x+dx(u#phi)) ], 
				[.5*(dx(u#r)+dy(u#x)),		dy(u#r),							.5*(im/y*u#r-u#phi/y+dy(u#phi))],
				[.5*(im/y*u#x+dx(u#phi)),	.5*(im/y*u#r-u#phi/y+dy(u#phi)),	im/y*u#phi+u#r/y]
				]//EOM

/* Macro for Mutual convection operator  */
	macro Conv(ima,ua,imb,ub,v) ( 
              [v#x,v#r,v#phi]'*(Grad(ima,ua)*[ub#x,ub#r,ub#phi] + Grad(imb,ub)*[ua#x,ua#r,ua#phi])
              			)//EOM


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : problem definition
//

/*  -----------------------------------
		R�solution de Navier-Stokes 
    ----------------------------------- */



/* Syst�me lin�aris� */
	problem NewtonIter([dux,dur,duphi,dup],[vx,vr,vphi,vp]) =
		int2d(th)(
				(	vp*div(0,du)
					- Conv(0,up,0,du,v)
					+ dup*div(0,v)
					- 2*nu*(D(0,du):D(0,v))
				)*y)
		+ int2d(th)(
				(	vp*div(0,up)
					- .5*Conv(0,up,0,up,v)
					+ upp*div(0,v)
					- 2*nu*(D(0,up):D(0,v))
				)*y)
		+ BoundaryconditionsBaseFlow(du,up,v);

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//  
   
    
/* Param�tres de l'algorithme de Newton  */          
	real tolerance = 2e-12;
	real ener = 10;
	int Nitermax = 30;
	int iter = 0;
	
/* Algorithme de Newton  */
	while((ener>tolerance)&(ener<50)&(iter<=Nitermax))
        {
			upx[]=ux[];				// Uold=U   
			NewtonIter ;           	// Update of current solution u1=u1-w
			ux[] = ux[]+dux[];
			real enerl2=dux[].l2;
			ener = sqrt(int2d(th)(dux^2+dur^2+duphi^2)/th.area);
			cout << " iter = "<< iter+1 << "   Re = " << Re << " res = " << ener << " ; res l2 = " << enerl2 << endl;
			plot(dux,wait=0,value=false,nbiso=50,fill=1,
			     cmm="dux - Re="+int(Re)+" - It="+int(iter+1)+" - Res="+real(ener)+".");
			iter++;
		};


/*  ----------------------------
		Sortie des r�sultats 
    ---------------------------- */

/* Si non convergence */
	if((ener>50)||(iter>Nitermax))
		{
		cout << "$$ NEWTON ITERATION FAILED" << endl;
		cout << "$$ Leaving FreeFem++ with error code 201" << endl;
		exit(201);
		}
/* Si convergence */
	else
		{
		ofstream file(ffdatadir+"BaseFlow.txt"); 			// file in .txt format for FreeFem solvers
		file << ux[]; 
		file << endl << endl << Re << endl << Omegax << endl;
		SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver
		}; 
		

	
		
		