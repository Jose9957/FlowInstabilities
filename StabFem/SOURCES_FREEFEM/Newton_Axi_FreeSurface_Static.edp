// README :// This file is adapted from "Newton_FormePont_V.edp" from "LiquidBridges++_V1.3".// Has been updated by N. Achour & D. Fabre in July 2018// Calcul de la forme d'equilibre d'une surface libre statique (ou avec vitesse potentielle) axisym√©trique.// La forme initiale est lue dans le fichier "MeshBridge_guess.msh". verbosity = 0;// Parametres :real Rbase = 1; // On prend le rayon du tube capillaire comme echelle de longueur (eviter de changer !)//////////////////////////////////////////////////////////////////// MAILLAGE ET GEOMETRIE INITIAUX////////////////////////////////////////////////////////////////////include "SF_Geom.edp";include "StabFem.idp"mesh th=readmesh(ffdatadir+"mesh_guess.msh");mesh thsurface;if(typesurfacemesh=="plain") {thsurface = th; 	// Maillage 'surface'};if(typesurfacemesh=="empty") {thsurface = emptymesh(th); 	// Maillage 'surface'};real PP0 = 1; // guessreal PP1;real dpdz;real gamma ; string typestart; // possibilites : "pined", "axis", "plane", "freeH", "freeV"string typeend;    // possibilites : "pined", "axis", "plane", "angle"include "Macros_Geometry_FreeSurface.idp"///////////////////////////////////////// INPUT PARAMETER/////////////////////////////////////////cout << "$$ Entering FreeFem++ Program Newton_Axi_FreeSurface_Static.edp : " << endl;cout << "$$ COMPUTATION OF A MENISCUS (static equilibrium shape of a free surface) and corresponding mesh" << endl;cout << "$$ Input parameters : " << endl;string typecont;cout << "$$ Type of continuation : V (impose volume), P (impose pressure) or angle (impose angle) or S (arclength continuation) 	>> " ;cin >>  typecont;cout << typecont << endl;real VolObj;real thetaS, alphaS;if(typecont=="V"){cout << "$$ Value of prescribed volume  V0    >> " ;cin >> VolObj;cout << VolObj << endl;VolObj = VolObj/(2*pi);// Warning the "volume" used in the code is actually volume/(2 pi) ; to be rationalised someday}else if(typecont=="P"){cout << "$$ Value of prescribed reference pressure P0 (at z=0)    >> " ;cin >> PP0;cout << PP0 << endl;}else if(typecont=="angle"){cout << "$$ Value of prescribed static angle (degrees)    >> " ;cin >> thetaS;cout << thetaS ;thetaS = pi/180*thetaS;cout << "( = " << thetaS << " radians )" << endl;}else if(typecont=="S"){cout << "$$ WARNING : type continuation 'S' not yet implemented ! " << endl;exit(10);}else{cout << "$$ WARNING : type continuation n" << typecont << " not recognized !!! " << endl;exit(10);};cout << "$$ Value of surface tension  >>" ;cin >> gamma ;cout << gamma << endl;cout << "$$ Value of gravity parameter (rho g) >>  " ;cin >> dpdz;cout << dpdz << endl;real GAMMABAR;cout << "$$ Value of ROTATION parameter bar{Gamma}  = Gamma/(2*pi) >> " ;cin >> GAMMABAR;cout  << GAMMABAR << endl;if(GAMMABAR!=0) {cout << " ERROR : GAMMA (rotation) NOT YET IMPLEMENTED !!!'" << endl; exit(10);};cout << "$$ Value of parameter typestart (pined, axis, freeH or freeV) >> ";cin >> typestart;cout << typestart << endl;//if(typestart=="freeH") {cout << " typestart=freeH NOT YET IMPLEMENTED !!!'" << endl; exit(10);};cout << "$$ Value of parameter typeend (pined, axis, plane) >> "<< endl;cin >> typeend;if(typeend=="freeH") {cout << " typeend=freeH NOT YET IMPLEMENTED !!!'" << endl; exit(10);};if(typecont=="angle"){if(typestart=="freeV"){ alphaS = 3*pi/2-thetaS;}if(typestart=="freeH"){ alphaS = pi/-thetaS;}if(typestart=="pined"){ cout << "error : in 'angle' mode typestart must be set to either freeV or freeH (even if it's actually pined)" << endl;}};///////////////////////////////////////// Calcul de la geometrie initiale/////////////////////////////////////////// Calcul des normales et des courburesCalcGeomSurf;SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface);real Zmin = yPointSurf(0);real Zmax = yPointSurf(Nsurface);real L = Zmax-Zmin;//////////////////////////////////////////////////////////////////// ALGORIthME DE NEWTON//////////////////////////////////////////////////////////////////real Res=1;int Itmax = 30;//Res = 0;for(int i = 0; (i<Itmax)&(Res>1e-7);i++){// Calcul de la deformation de surface Wh1 etaNewton ;if(typecont=="V"){CalcEtaV(etaNewton,PP1,VolObj,dpdz);cout << " Modif pression : PP1 = " << PP1 << endl;PP0 = PP0+PP1;cout << " Nouvelle pression : PP0 : " << PP0 << endl;}else if(typecont=="P"){CalcEta(etaNewton,PP0,dpdz);}else if(typecont=="angle"){CalcEtaangle(etaNewton,PP1,alphaS,dpdz);}else{cout << "ERROR : typecont should only be V or P (S not implemented yet)" << endl;exit(10);};IFMACRO(FREEFEMPLOTS,YES)Vh etaext;ExtendEta(etaext); plot(etaext,fill=1,value=1,wait=1,cmm="eta ext"); //(pour visualisation)ENDIFMACRO// Calcul d'un champ de deplacement du maillage fespace Vh11(th,[P1,P1]);Vh11 [ur,uz];CalcDef(ur,uz);IFMACRO(FREEFEMPLOTS,YES)plot([ur,uz],fill=1,value=1,cmm="champ de deformation calcule iteration "+i,wait=1);ENDIFMACRO// Deplacement du maillagereal minarea=checkmovemesh(th,[x+ur,y+uz]);if (minarea <0 )	{		cout << " WARNING : movemesh not valid. trying to underrelax by a factor 1/2" << endl;		[ur,uz] = [ur/2,uz/2]; 	}th = movemesh(th,[x+ur,y+uz]);if(typesurfacemesh=="plain") {thsurface = th; 	// Maillage 'surface'};if(typesurfacemesh=="empty") {thsurface = emptymesh(th); 	// Maillage 'surface'};//Shempty = emptymesh(th);//Shempty = movemesh(Shempty,[x+urdef,y+uzdef]);//thsurface = th;// warning : ca ne marche qu'en mode "plain"... IFMACRO(FREEFEMPLOTS,YES)plot(th,thsurface,cmm="Deformation maillage iteration "+i,wait=1);ENDIFMACRO// Recalcul des normales et courburesCalcGeomSurf;ExtendC;K0ext = K0ext-(PP0-dpdz*y);IFMACRO(FREEFEMPLOTS,YES)plot(K0ext,fill=1,value=1,cmm="Erreur courbure iteration "+i,wait=1);ENDIFMACROreal NewVolume = int2d(th)(x);//cout << "NewVolume = " << NewVolume << endl; //Res = int1d(Shempty,2)( (K0a+K0b-(K0-dpdz*y))^2 );Res = int1d(thsurface,2)(abs(x)*(gamma*(K0a+K0b)-(PP0-dpdz*y))^2);cout << " iteration " << i << " : Res = " << Res << " ; Volume = " << NewVolume << " ; PP0 = " << PP0 << " ; angle = " << alphaPointSurf(0) <<  endl; //cout << " Max(eta) :" << etaNewton[].max << endl;}//  ----------------------------------------------------------------------------------------------------// Fin du Newton //  ----------------------------------------------------------------------------------------------------cout << endl << " ------- NEWTON TERMINE -------" << endl << endl;// Ecriture du maillage dans un fichierif (Res < 1e-4){ cout << "solution convergee : on copie le maillage dans mesh.msh" << endl; savemesh(th,ffdatadir+"mesh.msh");IFMACRO(SFWriteMesh)  	SFWriteMesh(ffdatadir+"mesh.ff2m",th,"deformed")ENDIFMACRO IFMACRO(SFWriteConnectivity)	SFWriteConnectivity(ffdatadir+"mesh_connectivity.ff2m",th);ENDIFMACROSFWriteMeshSurface(ffdatadir+"mesh_surface.ff2m",th);//// EXPORTATION DU "champ de base" AUX FORMAT FF2M{						ofstream file(ffdatadir+"FreeSurface.txt");	    file << gamma << endl << dpdz << endl << GAMMABAR << endl;	    SFWriteSurface(ffdatadir+"FreeSurface.ff2m",th);} real NewVolume = int2d(th)(x); cout << "$$ Statistique sur geometrie" << endl; cout << "$$ P0 = " << PP0 << endl; cout << "$$ Volume = " << 2*pi*NewVolume << "       ( Volume / 2pi = " << NewVolume << " ) " << endl;   cout << "$$ Angle at starting point = " << alphaPointSurf(0)*180/pi << "      ( = " << alphaPointSurf(0) << " radians )" << endl; }else{		cout << "$$ NEWTON ITERATION FAILED" << endl;		cout << "$$ Leaving FreeFem++ with error code 201" << endl;		exit(201);};cout << endl << "The end..." << endl << endl;
