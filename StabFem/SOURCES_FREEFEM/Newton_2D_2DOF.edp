//
//  PROGRAM Newton_2D.edp
//  computation of 2D base flow [ux,uy](x,y)
//   
//
//  INPUT PARAMETERS (now managed with getARGV)
//   	Re
//      Omegax
//      alpha
//      symmetry ('S','A' or 'N')
//      (you can customize the list using customizable macro SFInputParametersNewton)
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, return exit code 201.
//
//
// INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
// Rewriten on october 2 2017 with macros.
// Cleaned in july 2019 for StabFem 2.9
// Redesigned in december 2019.
// New redesign in may 2020 (optional parameters)

		
cout << "$$$$ ENTERING Newton_2D.edp " << endl << "$$" << endl; 

include "StabFem.idp"



IFMACRO(!Pk) 
macro Pk [P2,P2,P1] //FEspace for pressure 
macro Pkstring() "P2P2P1" //
ENDIFMACRO


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters		
//

// 1A : Generic Parameter : Re
    real Re,Reans;

cout << "$$  Physical parameters " << endl;
Re = getARGV("-Re",0.);
cout << "Re = " << Re << endl;

// 1B : specific parameters 
IFMACRO(SFInputParametersNewton)
    // If a custom macro exists in the SF_Custom.idp file we use it
    SFInputParametersNewton;
ENDIFMACRO

IFMACRO(!SFInputParametersNewton)
    // Otherwise here are the expected physical parameters : Omegax,Symmetry (designed for rotating cylinder)
	/* Physical parameters (handled by standart input in this case) */
    cout << " Specific parameters (from getARGV)" << endl;
	string symmetryBaseFlow=getARGV("-Symmetry","S"); 
	cout << "$$ Symmetry property : " << symmetryBaseFlow << endl;
    real Omegax = getARGV("-Omegax",0.);
    cout << "$$ Rotation rate Omegax = " << Omegax << endl;
ENDIFMACRO


if (Re==0) 
{ SFerror("It is mandatory to give a value for Re using -Re (value)");
  exit(1);
};


// 1.C Numerical paramters
string IBPViscous = getARGV("-IBPViscous","D"); // either "D" or "Grad"
real tolerance=getARGV("-tolerance",1e-10);
int Nitermax=getARGV("-Nitermax", 30);
real gammaNewton    = getARGV("-gammaNewton",1.);
real isdtNewton     = getARGV("-isdtNewton",0.);
real CFLmin         = getARGV("-CFLmin",10.); 
real CFLmax         = getARGV("-CFLmin",1e30);
int DEBUG = getARGV("-DEBUG",0);

cout << "$$ NUMERICAL PARAMETERS (handled by getARGV or default ) " << endl;
cout << "$$ Fespace used : " << Pkstring << endl;
cout << "$$ Integration by parts of viscous term (D or Grad) : " << IBPViscous << endl;
cout << "$$ tolerance for Newton = " << tolerance << endl;
cout << "$$ Nitermax = " << Nitermax << endl;
cout << "$$ DEBUG MODE : " << DEBUG << endl;
if(isdtNewton!=0)
{ 
cout << "$$ Using local pseudo-timestep to stabilize Newton" << endl;
cout << " Cflmin, Cflmax : " << CFLmin << " , " << CFLmax << endl;
};

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//


		mesh th=readmesh(ffdatadir+"mesh.msh");
		
        fespace Xh(th,P2,periodic=MESHPERIODICITY);       //f.e. space for veloecity components
		fespace Mh(th,P1,periodic=MESHPERIODICITY);      //f.e space for pressure
		fespace XXMh(th,Pk,periodic=MESHPERIODICITY); // f.e. space for triplet [u,v,p]
		fespace f0(th,P0,periodic=MESHPERIODICITY);

		XXMh [ux,uy,up];          ///////  -> unknown for the Navier-Stokes problem
		XXMh [vx,vy,q];          ///////  -> test function for Navier-Stokes
		XXMh [upx,upy,upp];   	 ///////  -> buffer vector  to store previous iteration (Newton) 
		XXMh [dux,duy,dup]; 		 ///////  -> increment for the Newton iteration
		XXMh [uSolidx,uSolidy,uSolidp]; 		 ///////  -> Solid velocity

		f0 dtlocal,tloc; // For definition of local time step

// Baseflow
		int testCB;
		SFcheckfile("BaseFlow_guess.txt",testCB);

    	if (testCB<0)
		{
		SFwarning("No file BaseFlow_guess.txt : starting from arbitrary initial condition");
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your SF_Custom.idp
		macro DefaultGuessForNewton
		[ux,uy,up] = [0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
		else
		{
		cout << "$$ Reading file BaseFlow_guess.txt" << endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[];
		file >> Reans;
		cout << "$$ Re of guess field : " << Reans << endl; 
		};

IFMACRO(FREEFEMPLOTS,YES)
		plot(ux,wait=1);
		plot(uy,wait=1);
ENDIFMACRO

	cout << "$$ Starting Newton algorithm for Re = " << Re << endl;	
	

	real nu=1./Re; 
	// If Nu is something else than 1/Re define a macro CUSTOMnu in your StabFem.idp file
    IFMACRO(CUSTOMnu)
    nu = CUSTOMnu;
    ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//

//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your SF_Custom.idp file.
//
	
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO	
	
IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,u,v)
	           on(1,du#x=Uinlet-u#x,du#y=0.0)
	         + on(2,du#x=-u#x+Omegax*y,du#y=-u#y-Omegax*x) /* if rotation */
	         + on(4,du#y=-u#y)  
             + on(5,du#x=-u#x)
             + int1d(th,6)(du#x*v#x*1e30*(symmetryBaseFlow=="A")+du#y*v#y*1e30*(symmetryBaseFlow=="S"))
             + int1d(th,6)(u#x*v#x*1e30*(symmetryBaseFlow=="A")+u#y*v#y*1e30*(symmetryBaseFlow=="S"))         
//EOM
ENDIFMACRO


IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)((dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(6,2,21,22,23,psi=0)
					         + on(1,4,psi=y);
//EOM
ENDIFMACRO     

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1,periodic=MESHPERIODICITY);  
    p1forff2m vort;
	vort=-dy(u#x)+dx(u#y); /* vorticity */
	p1forff2m psi,test; 
	CalcPsi(psi,vort,test);
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
    string storagemode = "Re"+Pkstring+".1";
    file << "datatype " << typeFlow << " datastoragemode " << storagemode << " datadescriptors ux,uy,p,Re" << endl;
	file << "real* Re P1 vort P1 psi real iter " << endl ;
	file << Re << endl;	
			for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
	};
	}
//EOM
ENDIFMACRO

/////////////////////////////////////////////////////////////////////////////////
/////// macro to define some useful operators

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 
macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] 
// macro for rate-of-deformation tensor
macro GRAD(u) [[dx(u#x), dy(u#x)], [dx(u#y), dy(u#y)]] 
// macro for Gradient tensor
macro ConvSolid(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y)))*v#y 
                    ) // macro for mutual convection operator



//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//




// definition of linear system to be solved at each step of the iteration
problem NewtonIter([dux,duy,dup],[vx,vy,q]) =
    int2d(th)( 
			-2*nu*(D(du):D(v))*(IBPViscous=="D")-nu*(GRAD(v):GRAD(du))*(IBPViscous=="Grad")
             + q*div(du)
             + div(v)*dup
			 - Conv(up,du,v)
			 + ConvSolid(uSolid,du,v)
			 + (isdtNewton/dtlocal)*( dux*vx+duy*vy ) // local pseudo-timestep method 
             )
             +
    int2d(th)(
    		-2*nu*(D(up):D(v))*(IBPViscous=="D")-nu*(GRAD(v):GRAD(up))*(IBPViscous=="Grad")
             + q*div(up)
             + div(v)*upp
             - .5*Conv(up,up,v)
             + ConvSolid(uSolid,up,v)
             )
	+  BoundaryconditionsBaseFlow(du,up,v);     
    
//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//    
   
   
// parameters for Newton loop            

    real res=1; // residual
    real res0=1; // residual at previous iteration	
    int iter=0;
    [uSolidx,uSolidy,uSolidp] = [-cos(theta0),sin(theta0),0.0];
        
// Newton loop
        while((res>tolerance)&(res<100)&(iter<=Nitermax))
        {
        iter++;	
        real errorratio = res/res0;
        real CFL = min(CFLmin/(errorratio^1.5),CFLmax)*iter;
		dtlocal = CFL*min(hTriangle/(sqrt(upx^2 + upy^2) + 1e-10 ),0.5*hTriangle*hTriangle/nu)+1e-20;
	    upx[]=ux[];      
        NewtonIter ;          
        ux[] = ux[]+gammaNewton*dux[];
		real enerl2=dux[].l2;
		res0 = res;
		res=sqrt(int2d(th)(dux^2+duy^2)/th.area);
	    cout << "$$ Iter = "<< iter << "   Re = " << Re << " ; res = " << res << " ; res l2 = " << enerl2 << endl;
		plot(ux,wait=0,fill=1,value=1,cmm="ux");
		
		if (DEBUG==1)
		{
			ofstream file(ffdatadir+"DEBUG/U_Iter"+FixedFormatInt(iter,6)+".txt"); 		    
			file << ux[]; 
		    SFWriteBaseFlow(ffdatadir+"DEBUG/U_Iter"+FixedFormatInt(iter,6)+".ff2m",u,"Iteration",iter);
		    ofstream file2(ffdatadir+"DEBUG/DU_Iter"+FixedFormatInt(iter,6)+".txt"); 		    
			file2 << dux[]; 
		    SFWriteBaseFlow(ffdatadir+"DEBUG/DU_Iter"+FixedFormatInt(iter,6)+".ff2m",u,"DUIteration",iter);
		 }; 
           // file in .ff2ml format for StabFem driver

	  } ;

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//    
   

// sortie des r?sultats 

		if((res>50)||(iter>Nitermax))
		{
			SFerror("$$ NEWTON ITERATION FAILED");
			cout << "$$ Leaving FreeFem++ with error code 201" << endl;
			exit(201);
		}
		else
		{

		plot(ux,wait=1);

		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << ux[]; 
		  file << endl  << Re;
          real Omegaxforfile = Omegax; // LEGACY ; to be removed completely someday
		  file << endl  << Omegaxforfile << endl;
		  }; 
          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver

    
		};
          
cout << "$$$$ SUCESSFULLY LEAVING Newton_2D.edp "  << endl; 
