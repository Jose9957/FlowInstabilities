//
//  PROGRAM Newton_Axi_Comp_Sponge.edp
//  Computation of axisymmetric compressible base flow [uz,ur,p,T,rho](z,r); in the code uz \equiv ux and ur \equiv uy
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Restructured 30/12/2020 | 
// Updated by Javier Sierra.

//////////////////////////////////////////////////////////////////////////////////
//
//		0 : Headers (Include/load & global macros)		
//


load "PETSc" // Load PETSc (real)
macro dimension() 2// EOM            // 2D or 3D useful for intN and similar macros
include "macro_ddm.idp" // Include macros for the partitioning of the mesh
macro def(i) [i,i#B,i#C]// EOM    
macro init(i)[i,i,i]// EOM         
macro DESACTIVATESLEPC() // EOM
include "StabFem.idp";
macro mpicout() if(mpirank==0) cout //EOF // Useful for outputs in the terminal
include "getARGV.idp" // Arguments instead of pipeline

/////////////////////////////////////////////////////////////////////////////////

mpiComm comm(mpiCommWorld, 0, 0);

int mpicommSize = mpiSize(mpiCommWorld);
int mpirank = mpiRank(mpiCommWorld);
int status; 

mpicout << "MPI Comm size = " << mpicommSize << endl;
mpicout << "MPI rank in Comm = " << mpiRank(comm) << endl;

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		1 : Parallel related macros		
//


/* Definition of Local mesh (without overlapping) */

IFMACRO(!LocalMeshNonOverlapped)
macro LocalMeshNonOverlapped(thLocalOverlapped,thLocalNonOverlapped,partUnity,PkFEM,restrictIdx)
{

	int[int] n2o;
	NewMacro thN2O()n2o EndMacro
    if(mpirank == 0)
        partitionerSeq(partUnity[], thLocalOverlapped, mpisize); 
    partitionerPar(partUnity[], thLocalOverlapped, mpiCommWorld, size);
    NewMacro ThName#UserPartitioning() partUnity[] EndMacro
    buildDmesh(thLocalOverlapped)
    restrictIdx = restrict(XXxH, XXxHG, n2o);
    thLocalNonOverlapped = trunc(thLocalOverlapped, abs(partUnity - mpirank) < 1e-1);
    partUnity = abs(partUnity - mpirank) < 1e-1 ? 1 : 0;
    createMat(th, A, PkFEM);
}
//EOM
ENDIFMACRO


/* Macro to perfom a reduction to rank == 0 of arithmetic (real or complex) Pk FEM fields */
IFMACRO(!SFReduceFespace)
macro SFReduceFespace(fieldth,fieldGlobthG,arithmetic)
{
	XXxHG<arithmetic> defU(fieldLocthG);
	XXxH<arithmetic> defU(fieldLocthL);
	XH partP2 = part;
	Xh partP1 = part;
	/* Restrict to non overlapping domain */
	defU(fieldLocthL) = [fieldth#x*partP2,fieldth#r*partP2,fieldth#p*part]; /* Global variable (interpolate) */
	fieldLocthG#x[](R) = fieldLocthL#x[];
	/* Reduce(sum) on proc == 0 */
	mpiReduce(fieldLocthG#x[], fieldGlobthG#x[], processor(0, comm), mpiSUM); 
	mpiReduce(fieldLocthG#r[], fieldGlobthG#r[], processor(0, comm), mpiSUM);
	mpiReduce(fieldLocthG#p[], fieldGlobthG#p[], processor(0, comm), mpiSUM);
}//EOM
ENDIFMACRO


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		2 : Definition of parameters		
//


/* Physical parameters */
real Re,Reans;
real nu;
/* Newton solver parameters */
real tolNewton=getARGV("-tolNewton",2e-8); // tolerance of newton loop
int imaxNewton=getARGV("-imaxNewton",40); // Max number of Newton iterations
real maxtolNewton = getARGV("-maxtolNewton",50.0); // Maximum tolerance for divergence criterion
real L2Norm=1; // L2Norm of the relevant quantity used as a tolerance-convergent monitor
int iNewton=0; // Iterations of Newton method

string 	sparamsDirect = "-pc_type lu -pc_factor_mat_solver_type mumps ";

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		3 : Defintion of FEM spaces (lecture of mesh)		
//


func Pk = [P2, P2, P1];
meshN th, thG, thNo;
if(mpirank==0)
  th=readmesh(ffdatadir+"mesh.msh"); /* global mesh read on rank 0 */
broadcast(processor(0, mpiCommWorld), th);     // global mesh broadcasted to all ranks
thG=th; /* Global mesh */

/* Definition of FEspaces */
fespace XH(th,P2);
fespace XHG(th,P2);
fespace XHNo(thNo,P2);

fespace Xh(th,P1);
fespace XhG(th,P1);
fespace XhNo(thNo,P1);

fespace Ph(th, P0);
fespace PhG(thG, P0);
fespace PhNo(thNo, P0);

fespace XXxH(th,Pk);   //   Local mesh (overlapped) : pres P1 + vel 2x P2 + temp P1 + dens P1
fespace XXxHG(thG,Pk); //   Global mesh: pres P1 + vel 2x P2 + temp P1 + dens P1
fespace XXxHNo(thNo,Pk); // Local mesh (without overlapping): pres P1 + vel 2x P2 + temp P1 + dens P1

/* Definition of Field definition macros */

macro defU(u)[u#x,u#r,u#p]//EOF  

/* Restriction */ 

int[int][int] intersection; /* local-to-neighbors renumbering */
real[int] DDD; /* partition of unity */
int s = getARGV("-meshSplit",1);; /* refinement factor */
Ph part;
int[int] R;

Mat A;
LocalMeshNonOverlapped(th,thNo,part,Pk,R)


/* Create thNo mesh: Local mesh (without overlapping) -- Another option use Dmesh */
//LocalMeshNonOverlapped(th,thNo,part,Pk,DDD,intersection,s)

/* Definition of Vector fields */
XXxH defU(du); // Update solution field
XXxHG defU(UbG); // Global solution field
XXxH defU(Ub);  // Local (overlapped) solution field 


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		4a : Customizable macros for the variational formulation	
//
//

/* Customizable definition of the Reynolds number -- dynamic viscosity (it should be mu, however nu as in the incompressible) */
IFMACRO(!SFReCustom)
macro SFReCustom nu=1./Re; //EOM
ENDIFMACRO

/* Provides access to the ReNumber in case of use for Boundary Conditions */
IFMACRO(!ReNumber)
macro ReNumber() Re // EOM For BC
ENDIFMACRO

/* Useful for boundary conditions */

/* Streamwise initial velocity */
IFMACRO(!Uin)
macro Uin(x,y) 0.0 //EOM
ENDIFMACRO	

/* Crosswise initial velocity */
IFMACRO(!Vin)
macro Vin(x,y) 0. //EOM
ENDIFMACRO	

/* initial Temperature */
IFMACRO(!Pin)
macro Pin(x,y) 0. //EOM
ENDIFMACRO	

/* Definition of macros for variational formulations */ 

/* Jacobian of the system of coordinates */

IFMACRO(!JJJ)
macro JJJ() y //EOM
ENDIFMACRO

/* Differential forms */

macro div(u) (dx(u#x)+dy(u#r)+u#r/y)// macro for divergence 
macro Grad(u) [[dx(u#x), dy(u#x),  u#x-u#x ], [dx(u#r), dy(u#r), u#x-u#x],[u#x-u#x,u#x-u#x,u#r/y ]] // macro for rate-of-deformation tensor
macro D(u) [[dx(u#x), .5*(dx(u#r)+dy(u#x)),  u#x-u#x ], [.5*(dx(u#r)+dy(u#x)), dy(u#r),u#x-u#x],[u#x-u#x,u#x-u#x,u#r/y ]] // macro for rate-of-deformation tensor
macro Conv(ua,ub,v) ( 
((ua#x*dx(ub#x)+ua#r*dy(ub#x))+(ub#x*dx(ua#x)+ub#r*dy(ua#x)))*v#x 
+ ((ua#x*dx(ub#r)+ua#r*dy(ub#r))+(ub#x*dx(ua#r)+ub#r*dy(ua#r)))*v#r 
) // macro for mutual convection operator

/* Navier Stokes Fourier equations -- Linear forms */


IFMACRO(!ResidualNS)
macro ResidualEquationNS(u,v)  ( JJJ*(-2*nu*(D(u):D(v)) + v#p*div(u) + div(v)*u#p -.5*Conv(u,u,v) ) ) // EOM
ENDIFMACRO

/* End of Navier Stokes Fourier equations */

/* Navier Stokes Fourier derivative (jacobian) -- bilinear forms */

IFMACRO(!OperatorLNS)
macro OperatorLNS(U,u,v) ( JJJ*(-2*nu*(D(u):D(v)) + v#p*div(u) + div(v)*u#p - Conv(U,u,v) ) ) // EOM
ENDIFMACRO

/* End of Navier Stokes Fourier (jacobian) -- bilinear forms */

/* Boundary conditions -- generic */ 

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(U,u,v)
	           on(1,u#x=Uin(x,y)-U#x,u#r=Vin(x,y)-U#r)
             + on(2,21,22,23,u#x=0.0-U#x,u#r=0.0-U#r)
      		 + on(6,u#r=0.0-U#r) 
//EOM
ENDIFMACRO


/* End of Boundary conditions -- generic */ 

macro LiftExchange(nu,u,symm)
{
	LiftLoc = LiftCompute(th,nu,u,symm);
	mpiAllReduce(LiftLoc, LiftGlob, mpiCommWorld, mpiSUM);
} // EOM

macro DragExchange(nu,u,symm)
{
	DragLoc = DragCompute(th,nu,u,symm);
	mpiAllReduce(DragLoc, DragGlob, mpiCommWorld, mpiSUM);
} // EOM

macro Lift(nu,u,symm) LiftGlob // EOM
macro Drag(nu,u,symm) DragGlob // EOM


//////////////////////////////////////////////////////////////////////////////////
//
//		4b : Customizable macros for input/output	
//
//

/* Reading of parameters */
IFMACRO(!SFParameters)
macro SFParameters()
Re=getARGV("-Re",50.0);
mpicout << " --> Re = " << Re << endl;
SFReCustom; // Customizable Reynolds number definition
// EOM
ENDIFMACRO

IFMACRO(!SFWriteBaseFlowParallel)
macro SFWriteBaseFlowParallel(filename,u,typeFlow,iter)
	{
		ofstream file(filename);
	   	{
			file << "### Data generated by Freefem++ ; " << endl;
		    file << typeFlow << " for a axisymmetric-compressible problem " << endl;
		    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1.1 datadescriptors ux,ur,p,Re" << endl;
			file << "real* Re real iter " << endl << endl ; 
			file << Re << endl;	
			file << iter << endl;
		}
	}; 
// EOM
ENDIFMACRO

/* if your want something else this macro may be redefUined in your Macro_StabFem.idp */
IFMACRO(!DefaultGuessForNewton) 
macro DefaultGuessForNewton() defU(UbG) = [Uin(x,y),Vin(x,y),Pin(x,y)]; //EOM
ENDIFMACRO


IFMACRO(!SFReadBaseFlow)
macro SFReadBaseFlow()
if(mpirank==0)
{
	int testCB = exec("ls "+ffdatadir+"/BaseFlow_guess.txt");
	if (testCB!=0)
	{
		mpicout << "$$ No file BaseFlow_guess.txt : starting from arbitrary initial condition" << endl;
		DefaultGuessForNewton;
	} 
	else
	{
	    mpicout << "$$ Reading file BaseFlow_guess.txt" << endl;
		ifstream file(ffdatadir+"BaseFlow_guess.txt");
		file >> UbGx[];
		file >> Reans;
		mpicout << "$$ Re of guess field : " << Reans << endl; 
	};
}
broadcast(processor(0,comm),UbGx[]); /* broadcast the full initial meanflow */
defU(Ub) = defU(UbG); /* Restriction to the mpirank^{th} domain */
//EOM
ENDIFMACRO

IFMACRO(!SFPostProcess)
macro SFPostProcess(u,filename,iter)
	SFReduceFespace(u,UbG,real); /* Restrict & Reduce on proc == 0 */
	if(mpirank==0)
	{
		ofstream file(ffdatadir+filename+".txt");
		file << UbGx[]; 
		file << endl << Re << endl << endl;
		SFWriteBaseFlowParallel(ffdatadir+filename+".ff2m",UbG,"BaseFlow",iter);
	};
// EOM	
ENDIFMACRO


//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		5 : Reading files and parameters
//


SFParameters; // Read basic parameters
SFReadBaseFlow; // Read base flow
// Customizable physical parameters using macro (if needed define this macro in you SF_Custom.idp)
IFMACRO(SFInputParametersNewton)
SFInputParametersNewton;	
ENDIFMACRO

//
//
//
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//		6 : Construction of variational operators
//

varf vLNS(defU(du),defU(us))=intN(th)( OperatorLNS(Ub,du,us) ) + BoundaryconditionsBaseFlow(du,Ub,us);
varf vNS(defU(du),defU(us))=-intN(th)( ResidualEquationNS(Ub,us) ) + BoundaryconditionsBaseFlow(du,Ub,us);

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		7 : Resolution of the non-linear problem
//

while((L2Norm>tolNewton)&(iNewton<=imaxNewton))
{
  real timeI=mpiWtime();

  /* Assemble Linear operator in PETSc indexing */
  matrix mLNS = vLNS(XXxH,XXxH,tgv=-1);
  Mat<real> MLNS(A,mLNS);
  //Mat<real> MLNS(mLNS,intersection,DDD);
  timeI=mpiWtime()-timeI;
  mpicout<<"Linear operator assembled in "<< timeI << " s "<<endl;  

  /* Assemble RHS in PETSc indexing */
  real[int] RHS;
  {
  	  timeI=mpiWtime();
  	  real[int] ffRHS = vNS(0,XXxH,tgv=-1);
  	  changeNumbering(MLNS, ffRHS, RHS);
  	  timeI=mpiWtime()-timeI;
  	  mpicout<<"Residual assembled in "<< timeI << " s "<<endl;  

  }

  /* Update solution vector and Newton update in PETSc and fespace indexing */
  {

  	timeI=mpiWtime();
	real[int] dSolution(RHS.n); // Update of the Newton iteration
	set(MLNS, sparams=sparamsDirect);
	KSPSolve(MLNS,RHS,dSolution);
  	timeI=mpiWtime()-timeI;
  	mpicout<<"Linear system solved in "<< timeI << " s "<<endl;  

 	real[int] solPETSc;
  	changeNumbering(MLNS, Ubx[], solPETSc); /* Solution in PETSc indexing */ 
 	solPETSc = solPETSc + dSolution; /* Updated solution in PETSc indexing */
  	changeNumbering(MLNS, Ubx[], solPETSc, inverse = true, exchange = true); /* Updated solution in fespace indexing */ 
  	changeNumbering(MLNS, dux[], dSolution, inverse = true, exchange = true); /* Update of the solution in fespace indexing */ 
  }

  /* Norm of the meanflow */
  {
		real UbL2G; 
		real UbL2 = int2d(thNo)( JJJ*(Ubx*Ubx + Ubr*Ubr) );
		mpiAllReduce(UbL2, UbL2G, comm, mpiSUM);

		real dUbL2G; 
		real dUbL2 = int2d(thNo)( JJJ*(dux*dux + dur*dur) );
		mpiAllReduce(dUbL2, dUbL2G, comm, mpiSUM);
		L2Norm = dUbL2G;

		mpicout << " --- iteration " << iNewton << " --- " << endl;
		mpicout << " --- Monitor of the solution  --- " << endl;

		mpicout << " || U ||_{L^2} " << UbL2G  << endl;
		mpicout << " || dU ||_{L^2} " << dUbL2G  << endl;
  }

  ++iNewton;	    

}// end of NEWTON LOOP

mpicout << " -------------------------------------------------------- "<< endl;	
mpicout << " Newton iteration ok!"<< endl;

if((L2Norm>maxtolNewton)||(iNewton>=imaxNewton))
{
	mpicout << "--- NEWTON ITERATION FAILED ---" << endl;
	mpicout << "--- Leaving FreeFem++ with error code 201 ----" << endl;
	exit(201);
}


//
//
//
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//		8 : Post-Process
//


SFPostProcess(Ub,"BaseFlow",iNewton);


//
//
//
//////////////////////////////////////////////////////////////////////////////////






