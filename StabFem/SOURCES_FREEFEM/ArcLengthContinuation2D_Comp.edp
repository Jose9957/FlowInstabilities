//
//  PROGRAM ArcLengthContinuation2D.edp
//  Arclength contination in the Omega / beta plane
//  Here beta is a customizable parameter customizable through some macro
//  (typically proportional to lift force through beta = scale*Fy)
//  Options so far for beta are Fy and Fx. Any other implementation needs to be done
//  similarly
//  
//  Arclength continuation is based on matrix extension of the Jacobian system
//  The desingularisation of the Jacobian comes from an extra condition which 
//  requires to follow a continous branch trhough a turning point.
//  
//  Notation n for Newton steps j for iterations of the whole arc-length process.
//  Capital letters J and N used for final steps of each of the lower letter processes.
//
//  Predictor step
//
//  \alpha^0_j = \alpha^N_{j-1} + \frac{d \alpha^N_{j-1}}{ds} ds
//  u^0_j = u^N_{j-1} + \frac{d u^N_{j-1}}{ds} ds
//  beta(u^0_j) = beta(u^N_{j-1}) + \frac{d beta(u^N_{j-1})}{ds} ds
//
//  where \frac{d u^N_{j-1}}{\alpha} =  -[ \frac{\partial{NS}}{\partial u}  ]^{-1} \frac{\partial{NS}}{\partial \alpha}
//  and normalised through \frac{d beta(u^N_{j-1})}{ds}^2 + \frac{d \alpha^N_{j-1}}{ds}^2 = 1
//
//  Corrector step
//  |																					        |
//  | \frac{\partial{NS}}{\partial u}                    \frac{\partial{NS}}{\partial \alpha}   |
//  |                                                                                           |
//  | \frac{\partial{beta}}{\partial ds} beta()			  \frac{\partial{\alpha}}{\partial  ds} |
//
//  RHS = [-NS(u), ds - \frac{\partial{beta}}{\partial ds} beta(u^n_{j} - u^0_{j-1}) 
//         - \frac{\partial{\alpha}}{\partial  ds}(alpha^n_{j} - alpha^0_{j-1})]
// 
//  Program developed for a rotating cylinder but adaptable to other cases
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	dS, DFyDsp, DparamDsp (directions of the tangent vector in (omega/Fy) plane), Symmetry ('N') 
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, error code is 202.
//
// 
//  author : J.Sierra and D.Fabre

//////////////

include "StabFem.idp";

/*=============================================
=            Macros                           =
=============================================*/

macro def(u)[u#x,u#y,u#p,u#T,u#rho]//EOF  

IFMACRO(!Lift)
	macro Lift(u)   
		(
		int1d(th,2,21,22,23)(u#p*N.y)
		-nu*int1d(th,2,21,22,23)( (((4./3.)*dy(u#y) - (2./3.)*dx(u#x))*N.y+(dx(u#y)+dy(u#x))*N.x))
		) 
	//EOM
ENDIFMACRO

IFMACRO(!LifVarfMacro)
macro LifVarfMacro(meshTh,scaleFact,Dbeta,nuRe,du)
   (
   	int1d(meshTh,2,21,22,23)(scaleFact*Dbeta*du#p*N.y) 
	-int1d(meshTh,2,21,22,23)(scaleFact*Dbeta*nuRe*(  ((4./3.)*dy(du#y) - (2./3.)*dx(du#x))*N.y + (dx(du#y)+dy(du#x))*N.x)  ) 
   )
   //EOM
ENDIFMACRO

IFMACRO(!Drag)
  macro Drag(u)   
	(
	int1d(th,2,21,22,23)(u#p*N.x)
	-nu*int1d(th,2,21,22,23)( (((4./3.)*dx(u#x) - (2./3.)*dy(u#y))*N.x+ (dx(u#y)+dy(u#x))*N.y))
	)
	//EOM
ENDIFMACRO

IFMACRO(!DragVarfMacro)
   macro DragVarfMacro(meshTh,scaleFact,Dbeta,nuRe,du)
   (
   	int1d(meshTh,2,21,22,23)(scaleFact*Dbeta*du#p*N.x) 
	-int1d(meshTh,2,21,22,23)(scaleFact*Dbeta*nuRe*(((4./3.)*dx(du#x) - (2./3.)*dy(du#y))*N.x+ (dx(du#y)+dy(du#x))*N.y)) 
   )
//EOM
ENDIFMACRO

IFMACRO(!scale)
	macro scale() 1.0 //EOM
ENDIFMACRO

// COPY THIS IN YOUR MACROS IF YOU WANT TO USE IT!
/*
IFMACRO(!beta)
	macro beta(u) scale*Lift(u) //EOM
	macro BetaVarf(femSpace) LiftVarf(0,femSpace); //EOM
ENDIFMACRO

IFMACRO(!param)
	macro param Omegax //EOM
	macro param0 Omega0x // EOM
	macro DparamG DOmegaGx // EOM
	macro paramPrev OmegaxPrev // EOM
	macro DparamDs DAlphaDs // EOM
	macro DparamDsp DAlphaDsp // EOM
	macro DbetaDparam DbetaDAlpha // EOM
	macro DbetaDparamp DbetaDAlphap // EOM
	macro dparam dOmega // EOM   
	macro DerNSDparam(FESpace) vNsDAlpha(0,FESpace) //
ENDIFMACRO
*/

IFMACRO(!beta)
	macro beta(u) scale*Drag(u) //EOM
	macro BetaVarf(femSpace) DragVarf(0,femSpace); //EOM
ENDIFMACRO

IFMACRO(!param)
	macro param Re //EOM
	macro param0 Re0 // EOM
	macro DparamG DReG // EOM
	macro paramPrev RePrev // EOM
	macro DparamDs DReDs // EOM
	macro DparamDsp DReDsp // EOM
	macro DbetaDparam DbetaDRe // EOM
	macro DbetaDparamp DbetaDRep // EOM
	macro dparam dRe // EOM   
	macro DerNSDparam(FESpace) vNsDRe(0,FESpace) //
ENDIFMACRO

IFMACRO(!SFWriteBaseFlowAC)
	macro SFWriteBaseFlowAC(filename,u,typeFlow,iter)
		{
		fespace p1forff2m(th,P1);  
		p1forff2m xx,yy; 
		xx=x; yy=y;
	    p1forff2m vort;
		vort=-dy(u#x)+dx(u#y); /* vorticity */
		p1forff2m psi,phi; /* stream function ; may not work in all cases */
		solve Laplace(psi,phi) = int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi))
		-int2d(th)(-vort*phi)+on(1,psi=y)+on(3,6,psi=y)+on(2,psi=0);  
		ofstream file(filename);
		file << "### Data generated by Freefem++ ; " << endl;
	    file << typeFlow << " for a 2D-compressible problem " << endl;
	    file << "datatype " << typeFlow << " datastoragemode ReP2P2P1P1P1.3 " << endl;
		file << "real* Re real* Ma real* Omegax  real* beta real Fy real Fx real tangent1 real tangent2 P1 vort P1 psi real iter " ;
		file << endl << endl ; 
		file << Re << endl;	
		file << Ma << endl;
	    file << Omegax << endl;
	    real BETA = beta(u);
		cout << "#    beta =  " << BETA << endl; 
	    file << BETA << endl ; 	
		     /* Calcul de la trainee et portance */
	    real LiftMode = Lift(u);
		cout << "#    Fy =  " << LiftMode << endl; 
	    file << LiftMode << endl ; 
	    real DragMode = Drag(u);
		cout << "#    Fx =  " << DragMode << endl; 
	    file << DragMode << endl ; 
	    file << DbetaDs << endl;	
	    file << DparamDs << endl;
		for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
		for (int j=0;j<psi[].n ; j++) file << psi[][j] << endl;
	    file << iter << endl;
	   	}
	    //EOM
ENDIFMACRO

IFMACRO(!Uinlet)
macro Uinlet(y) 1. //EOM
ENDIFMACRO	

IFMACRO(!Vinlet)
macro Vinlet(y) 0. //EOM
ENDIFMACRO	

IFMACRO(!BoundaryconditionsBaseFlowAC)
macro BoundaryconditionsBaseFlowAC(du,dp,dT,drho)
	           on(1,du#x=Uinlet(y)-ux,du#y=Vinlet(y)-uy,drho=1.-urho,dT=1.-uT)
	         + on(3,du#x=Uinlet(y)-ux,du#y=0.0-uy,drho=1.-urho,dT=1.-uT)  
             + on(2,du#x=-Omegax*y/0.5-ux,du#y=Omegax*x/0.5-uy)
//EOM
ENDIFMACRO

macro div(u) ((dx(u#x)+dy(u#y)))   //EOM
macro ugradf(u,f) ((u#x*dx(f)+u#y*dy(f)))    //
macro termnonlinear(u,v,w) ((w#x*(u#x*dx(v#x)+u#y*dy(v#x))+w#y*(u#x*dx(v#y)+u#y*dy(v#y)))) //
macro Grad(u) [[dx(u#x),dx(u#y)],[dy(u#x),dy(u#y)]]//EOM
macro Strain(u)[[dx(u#x),0.5*(dx(u#y)+dy(u#x))],[0.5*(dx(u#y)+dy(u#x)),dy(u#y)]]//EOM
macro gradgrad(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM

/*=====  End of Macro section block  ======*/


/*=============================================
=            Definition of paramaters         =
=============================================*/

// Predictor-corrector variables
real DAlphaDs,DbetaDAlpha,DbetaDAlphap,DAlphaDsp;
real DReDs,DbetaDRe,DbetaDRep,DReDsp;
real dS,DbetaDs,DbetaDsp;
real Re,Reans,Re0,DReG,RePrev;
real Omegax,Omega0x,DOmegaGx,Omegaxans,OmegaxPrev;
real dOmega=0.0, dRe=0.0;
// symmetry base flow
string symmetryBaseFlow;
// Newton paramaters
real res,ener=1.;
real tol = 1e-6;
real dXX = 1;
int  iter = 1;
// Physical parameters of compressibility
real Ma,Maans;
real gamma=1.4; 
real Pr=0.71;
/*=====    END of paramaters definition   ======*/


/*=============================================
=            INPUT                            =
=============================================*/

cout << " Enter the step for the pseudo-arclength method " << endl;
cin >> dS;

cout << " Enter previous derivative in direction DbetaDs " << endl;
cin >> DbetaDsp;

cout << " Enter previous derivative in direction DbetaDs " << endl;
cin >> DparamDsp;

cout << " Symmetry of the mesh ('N'-None , 'A'-Antisymmetric, 'S'-Symmetric) " << endl;
cin >> symmetryBaseFlow;

/*=====          END OF INPUT          ======*/

/*=============================================
=            FEM FIELDS                       =
=============================================*/

mesh th;
th=readmesh(ffdatadir+"mesh.msh");
fespace Xh(th,P2);       //f.e. space for veloecity components
fespace Mh(th,P1);      //f.e space for pressure
fespace XXxxxH(th,[P2,P2,P1,P1,P1]); ///   pres P1 + vel 2x P2 + temp P1 + dens P1
XXxxxH def(Deru);
XXxxxH def(DuG);
XXxxxH def(u0);
XXxxxH def(u); // uunknown of NS
XXxxxH def(v);
XXxxxH def(du);
XXxxxH def(up);
th=readmesh(ffdatadir+"mesh.msh");

/*=====          END OF FEM FIELDS       ======*/


/*=============================================
=            BASEFLOW READ                    =
=============================================*/

int testCB = 0;
try{ ifstream file(ffdatadir+"BaseFlow_guess.txt"); }
catch(...){testCB = 1; cout << "$$ NB : this 'ERROR' message is normal at this stage, the error was correcty caughth by StabFem. Relax !"; };

if (testCB!=0)
{
	cout << "$$ No file BaseFlow_guess.txt : strarting from arbitrary initial condition" << endl;
	IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
	macro DefaultGuessForNewton
		def(u) = [0,0,0,0,0]; //EOM
	ENDIFMACRO
	DefaultGuessForNewton;
} 
else
{
	cout << "$$ Reading file BaseFlow_guess.txt" << endl;
	 ifstream file(ffdatadir+"BaseFlow_guess.txt");
    file >> ux[];
	file >> Reans;
	file >> Maans;
	file >> Omegaxans;
	Re = Reans; Omegax = Omegaxans; Ma = Maans; 
	cout << "$$ Re of guess field : " << Reans << endl; 
	cout << "$$ Ma of guess field : " << Maans << endl; 
	cout << "$$ Omegax of guess field : " << Omegaxans << endl; 
};
// Previous value of the Newton iteration upx and value before Newton arc length u0x
// Both initially equal to ux
upx[] = ux[];
u0x[]=ux[];
param0 = param;
real nu=1./Re; 
cout << endl << " >>> Re = " << Re << " Ma = " << Ma << " Omegax =  " << Omegax <<endl;
	    
/*=====          END OF BASE FLOW READ       ======*/
   
/*=============================================
=                   VARF                      =
=============================================*/

varf jacobian([dux,duy,dp,dT,drho],[usx,usy,ps,Ts,rhos])=int2d(th)(
										rhos*(drho*div(u)+urho*div(du)+ugradf(u,drho)+ugradf(du,urho)) 
								       //mass equation
								       -dp*div(us)+2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))
								       +urho*termnonlinear(du,u,us)+drho*termnonlinear(u,u,us)+urho*termnonlinear(u,du,us)
								       //momentum
								  		+Ts*(drho*ugradf(u,uT)+urho*ugradf(u,dT)+urho*ugradf(du,uT)+(gamma-1)*(div(u)*(drho*uT+urho*dT) 
								  		+ urho*uT*div(du))-gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(du):Strain(u))+(Strain(u):Strain(du)))
								  		-2.0/3.0*(2.0*div(u)*div(du))))+gamma/(Pr*Re)*gradgrad(dT,Ts)
								       // energy
								       +ps*(gamma*Ma^2*dp-(drho*uT+urho*dT))
								  		)
  										+BoundaryconditionsBaseFlowAC(du,dp,dT,drho);

varf vNs([dux,duy,dp,dT,drho],[usx,usy,ps,Ts,rhos])=-int2d(th)(
								rhos*(urho*div(u)+ugradf(u,urho))
							   //mass equation
							   -up*div(us)+2.0/Re*(Strain(u):Grad(us))
							   -2.0/(3.0*Re)*(div(u)*div(us))+urho*termnonlinear(u,u,us)
							   //momentum
								+Ts*(urho*ugradf(u,uT)+(gamma-1)*uT*urho*div(u)
								   -gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(u):Strain(u)))-2.0/3.0*(div(u)*div(u))))
								   +gamma/(Pr*Re)*gradgrad(uT,Ts)
							   // energy
							   +ps*(1.0 + gamma*Ma^2*up-(urho*uT))
							   )
  							   +BoundaryconditionsBaseFlowAC(du,dp,dT,drho);

varf OrthoQ(def(us),def(du))=int2d(th)((Derux*dux+Deruy*duy+Derup*dup+Derurho*durho+DeruT*duT));

varf LiftVarf(def(us),def(du))=LifVarfMacro(th,scale,DbetaDs,nu,du);

varf DragVarf([vx,vy,q],[dux,duy,dup])=DragVarfMacro(th,scale,DbetaDs,nu,du);                         

varf vNsDAlpha(def(du),def(us)) = on(2,dux=y/0.5,duy=-x/0.5);

varf vNsDRe(def(du),def(us))=int2d(th)((2.0/Re^2)*(Strain(du):Grad(us))-2.0/(3.0*Re^2)*(div(du)*div(us)));

/*=====          END OF VARF       ======*/

cout << " ................................................... "<< endl;	
cout << " ................................................... "<< endl;	
 

/*=============================================
=                   Predictor step            =
=============================================*/

// Computation of the Gradient. Tangent of pseudo-arc continuation
cout << "Computation of the initial tangent " << endl;
cout << " Initial Lift = " << Lift(u) << endl;
cout << " Initial Drag = " << Drag(u) << endl;
// Computation of initial tangent
matrix JAC=jacobian(XXxxxH,XXxxxH);
set(JAC,solver=sparsesolver);
real[int] DerNSparam = DerNSDparam(XXxxxH);
Derux[] = JAC^-1*DerNSparam;
Derux[] = - Derux[];
DbetaDparam = beta(Deru);
// Normalization of tangents
DbetaDs = DbetaDparam/sqrt(1+DbetaDparam^2);
DparamDs = 1.0/sqrt(1+DbetaDparam^2);

IFMACRO(FREEFEMPLOTS,YES)
plot(Derux,fill=1,wait=1);
ENDIFMACRO

// Determination of the sign of the tangent
real scalarProduct = DbetaDsp*DbetaDs + DparamDsp*DparamDs;
cout << "Inner product =  " << scalarProduct  << endl;

if(scalarProduct < 0)
{
	DbetaDs*=-1.0;
	DparamDs*=-1.0;
}

cout << "DbetaDs and DparamDs : " <<   DbetaDs << " " << DparamDs << endl;
cout << "End of the computation of the initial tangent " << endl;

cout << "###### Prediction step ######" << endl;
ux[] += dS*DparamDs*Derux[];
param = param + dS*DparamDs;
cout << "Predctor param = " << param << endl;

/*=====          End of Predictor step       ======*/

/*=============================================
=            Correction step                  =
=============================================*/

cout << "###### Correction step ######" << endl;

while(abs(dXX)>tol&&abs(dXX)<1e6&&iter<10)
{ 
	cout << endl << "# Iteration : " << iter << " of the Newton-corrector step"<< endl;
	// Previous value of the Newton method 
	upx[]=ux[];
	nu = 1.0/Re;
	// Update the difference w.r.t. the state previous the predictor
	DuGx[] = ux[]- u0x[];
	DparamG = param - param0;   
	// Assemble system
    matrix mat11=jacobian(XXxxxH,XXxxxH);
    real[int] mat12 = DerNSparam;
    real[int] mat21 = BetaVarf(XXxxxH);
    real mat22 = DparamDs;
    cout << " Assembling matrix..." << endl;
	matrix LinOp = [
					[mat11,		mat12],
					[mat21',  	mat22]
				   ];
	// Factorisation
	cout << " LU-ing matrix..." << endl;
	set(LinOp,solver=sparsesolver);
	cout << " LU-ing matrix... done" << endl;
    // Assemble RHS
    cout << " Assembling RHS..." << endl;
    real[int] RHS1 = vNs(0,XXxxxH);
    real RHS2 = dS - mat22*DparamG - mat21'*DuGx[];
	real[int] RHS = [RHS1, RHS2];
	cout << " solving BIG problem..." << endl;
	real[int] dX(LinOp.n);
	dX = LinOp^-1*RHS;
	[dux[], dparam] = dX;
	ux[] += dux[];
	param += dparam;
	cout << endl << "   ### ||du0||, dparam : " << dux[].l2 << " "  << dparam << endl;
	dXX = dux[].l2+dparam;
	cout << "   ### ||u0|| : " << ux[].l2 << endl;
	cout <<  "  ### param = " << param << endl;
	cout << " Lift = " << Lift(u) << endl;
	cout << " Drag = " << Drag(u) << endl;
	iter++;
};

if(abs(dXX)>tol || abs(dXX)>1e6) iter = -1; // Not converged
	


/*=====          End of Correction step       ======*/


/*=============================================
=            New recomputation of tangent     =
=============================================*/
/*
// Computation of initial tangent
JAC=jacobian(XXMh,XXMh);
set(JAC,solver=sparsesolver);
DerNSparam = DerNSDparam(XXMh);
Derux[] = JAC^-1*DerNSparam;
Derux[] = - Derux[];
DbetaDparam = beta(Deru);
// Normalization of tangents
DbetaDs = DbetaDparam/sqrt(1+DbetaDparam^2);
DparamDs = 1.0/sqrt(1+DbetaDparam^2);
if(scalarProduct < 0)
{
	DbetaDs*=-1.0;
	DparamDs*=-1.0;
}
cout << "NEW Tangents : " << DbetaDs << " " << DparamDs << endl;
*/
/*=====     End recomputation of tangent   ======*/

/*=============================================
=            SAVE step                       =
=============================================*/
{
  {
	  ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
	  file << ux[]; 
	  file << endl << endl << Re << endl << Ma << endl << Omegax << endl;
  }; 
  exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BASEFLOWS/BaseFlow_ArcLength.txt");  // a faire ailleurs
  SFWriteBaseFlowAC(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver
  exec("cp "+ffdatadir+"BaseFlow.ff2m "+ffdatadir+"BASEFLOWS/BaseFlow_ArcLength.ff2m");  // a faire ailleurs

};
/*=====     End of SAVE step   ======*/
