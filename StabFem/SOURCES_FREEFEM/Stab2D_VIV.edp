/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////
/////	FEM : Flow past a SPRING-MOUNTED circular cylinder  
/////	FORMULATION : RELATIVE VELOCITIES / RELATIVE FRAME (cf assemat et al.)
/////
/////   By D. Ferreira Sabino & D. Fabre, 2018
///// Redesigned by DF in june 2020 (for Senin case)
/////                        
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

//// THIS PROGRAM NEEDS SOME CLEAN UP !!!
include "StabFem.idp";


// FIRST HERE ARE A NUMBER OF MACROS INTRODUCED BY DIOGO (TO BE SIMPLIFIED)
IFMACRO(!SFWriteModeVIV)
macro SFWriteModeVIV(namefile,mode,ev,shift,typeFlow,iter)
{
    ofstream file(namefile);
   	fespace p1forff2m(th,P1); 
    	p1forff2m<complex> vort1;  		 
 	file << "### Data generated by Freefem++ ; " << endl;
	file << "Eigenmode for a 2D-incompressible problem " << endl;
    file << "datatype Eigenmode datastoragemode CxP2P2P1.4 datadescriptors ux,uy,p,etay,etayp,etaypp,lambda" << endl;
    string descriptionFF;
 	descriptionFF="real* Re complex* lambda complex shift int iter P1c vort real AEnergy complex Fy complex Y complex V complex A"; 
	file << descriptionFF << endl << endl ; 
	file << Re << endl << real(ev) << endl << imag(ev) << endl << real(shift) << endl << imag(shift) << endl << iter << endl << endl;
	vort1=-dy(mode#x)+dx(mode#y);
	for (int j=0;j<vort1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
		
	real AEnergyMode = sqrt(2*int2d(th)(abs(u#x)^2+abs(u#y)^2)); 
	file << AEnergyMode << endl;
	complex LiftMode = Portance(u,"A"); 
	file << real(LiftMode) << endl << imag(LiftMode) << endl;
	file << real(mode#Y) << endl << imag(mode#Y) << endl;
	file << real(mode#V) << endl << imag(mode#V) << endl;
	file << real(mode#A) << endl << imag(mode#A) << endl;
};
//EOM	
ENDIFMACRO

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
	
////////////////////////////////////////////////////////////////////////////////////////////
//END MACROS





real Re, nu, MASS, STIFFNESS, DAMP,shiftr,shifti;
real zero = 0;
complex SHIFT,shiftOP;
string symmetry="a",iadjoint="a", typeDA; //initialisation
int nev,ncv; // number of eigenvalues to compute ; Krylov Basis
real eps=1e-30;
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
///////////    Parameters    ////////////////////////////////////////////////////	
	
	cout << " Enter Reynolds:   " << endl; 
	cin  >> Re;
	cout<< "The Re is:"<<Re<< endl;
	nu=1.0/Re;

	cout << " Enter MASS :   " << endl;
	cin  >> MASS;
	cout << " Enter STIFFNESS :   " << endl; 
	cin  >> STIFFNESS;
	cout << " Enter DAMPING coeff :   " << endl; 
	cin  >> DAMP;
	cout << " Enter SHIFT (re,im) :   " << endl;
	cin  >> shiftr >> shifti;
	SHIFT = 1i*shifti+shiftr;
	
	symmetry="a";
	while(symmetry!="A"&&symmetry!="S"&&symmetry!="N"&&symmetry!="restart")
	{
		cout << " Symmetry properties ?? (A, S or N or restart)" << endl;
		cin >> symmetry;
		
	}

	iadjoint="a";
	while(iadjoint!="D"&&iadjoint!="A"&&iadjoint!="cA"&&iadjoint!="S"&&iadjoint!="cS"&&iadjoint!="restart")
	{
		cout << " Direct (D), Adjoint (A), continuous adjoint (cA) or D&A+sensitivity (S), D&A(c)+sentitivity (cS)  ? (or restart)" << endl;
		cin >> iadjoint;
	}

	cout << " Enter nev ? (will use simple shift-invert if nev = 1) " << endl;
	cin >> nev ;
	ncv = 4*nev; ///// Krylov Basis		//UNDERSTAND THIS





//DEFINITION OF THE DAMPING IN THE dimensional equation:
real DAMPING=2.*DAMP*sqrt(STIFFNESS*MASS);

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
///////////     Display      ////////////////////////////////////////////////////	

cout << " ### PARAMETERS SELECTED : " << endl;
cout << " Re = " << Re<< endl;
cout << " shift = " << SHIFT << endl;
cout << " mass = " << MASS << endl;
real mstar=4*MASS/pi;
cout << " mstar = " << mstar << endl;
cout << " STIFFNESS = " << STIFFNESS << endl;
if (STIFFNESS !=0){
	real Ustar=pi*sqrt(pi*mstar/STIFFNESS);
	cout << " Ustar = " << Ustar << endl;}
else {cout << " Unable to compute Ustar" << endl;}

cout << " DAMPING = " << DAMP << endl;
if (symmetry =="S") {cout << " Symmetric modes" << endl;}
else if (symmetry =="A") {cout << " Antiymmetric modes" << endl;}	
else if (symmetry =="N") {cout << " No symmetry axis" << endl;};	
	
if (iadjoint =="D") {cout << " DIRECT PROBLEM" << endl;}
else if (iadjoint =="A") {cout << " ADJOINT PROBLEM(discrete)" << endl;}
else {cout << " ERROR WHEN SELECTING PROBLEM TYPE (sensitivity not managed any more by this solver)" << endl;}
;
	
cout << " nev = " << nev << endl;

////////////////////////////////////
// Numerical parameters
string formulation = getARGV("-Vel","R"); // should be "A" or "R" for absolute/relative VELOCITY
string Frame = getARGV("-Frame","R"); // should be "A" or "R" for absolute/relative FRAME OF REFERENCE
string useAS = getARGV("-useAS","yes"); //
real AddedSTIFFNESS =getARGV("-AS",0.);
cout << endl << " Numerical parameters :" << endl;
cout << "Velocity : " << formulation <<endl;
cout << "Frame : " << Frame <<endl;
cout << "Including Added Stiffness terms : " << Frame <<endl;




/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
////////   Read Mesh  & FEM Variables    ////////////////////////////////////////	
mesh th=readmesh(ffdatadir+"mesh.msh");
//int bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6;

fespace Xh(th,P2);		////// f.e. space for vel.
fespace Mh(th,P1);		////// f.e. space for pressure
fespace XXMh(th,[P2,P2,P1]);	////// f.e. space for triplet [u,v,p]
XXMh<complex> [ux,uy,up];	///////  -> unknown for the Navier-Stokes problem 
XXMh [vx,vy,q];			///////  -> test for Navier-Stokes
XXMh [Ubx,Uby,Ubp];		///////  -> Base Flow

/////////////////////////////////////////////////////////////////////////////////
////////////////   Info      ////////////////////////////////////////////////////
//cout << " -.-.-.-.-.-.-.-. info -.-.-.-.-.-.-.-.-.-" << endl;
//cout << " nb of degree of freedom : " << XXMh.ndof << endl;
//cout << " nb of Triangles: " << th.nt << endl;
//cout << " nb of Vertices: " << th.nv << endl;
//cout << " -.-.-.-.-.-.-.-._________-.-.-.-.-.-.-.-." << endl;

/////////////////////////////////////////////////////////////////////////////////
////////////////  Macros       //////////////////////////////////////////////////
macro div(u) (dx(u#x)+dy(u#y))
// macro for divergence
 
macro Conv(ua,ub,v) ( 
	((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
	+ ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    )
// macro for mutual convection operator

macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] 
// macro for rate-of-deformation tensor

/////////////////////////////////////////////////////////////////////////////////
///////////  Load baseflow   ////////////////////////////////////////////////////
real Reans;
{
ifstream cbin(ffdatadir+"BaseFlow.txt");
cbin >> Ubx[];
//cbin >> Reans;
}


//int bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6,bclatNOP=41;

real TGVCL = 1e30; // for Diogo

IFMACRO(!BoundaryconditionsLNSE)
macro BoundaryconditionsLNSE(u,v,formulation)/*For the free movement problem*/
	int1d(th,1,4)(u#y*v#y*TGVCL*(formulation=="A") )
	+int1d(th,1,4)(u#y*v#y*TGVCL*(formulation=="R") ) /* + le terme BBB de interaction sur Avf*/
	+int1d(th,1,4)(u#x*v#x*TGVCL) /*useless if domain is big enough:sometimes it introduces errors. But needed if domain is not that big */
	+int1d(th,2,21,22,23)(u#y*v#y*TGVCL*(formulation=="A") ) /* + le terme AAA de interaction sur Avf*/
	+int1d(th,2,21,22,23)(u#y*v#y*TGVCL*(formulation=="R") )
	+int1d(th,2,21,22,23)(u#x*v#x*TGVCL )
	+int1d(th,6)(u#x*v#x*TGVCL*(symmetry=="A")+u#y*v#y*TGVCL*(symmetry=="S")) /*Valid for the 2 formulations*/
//EOM
ENDIFMACRO

IFMACRO(!dUinlet)
macro dUinlet 0.
//EOM
ENDIFMACRO


IFMACRO(!Portance)
macro Portance(u,symmetry)   
	(
	(1*(symmetry=="N")+2*(symmetry=="A"))
	*(
	int1d(th,2,21,22,23)(u#p*N.y)
	-nu*int1d(th,2,21,22,23)( (2*dy(u#y)*N.y+(dx(u#y)+dy(u#x))*N.x))
	)
	)
//EOM
ENDIFMACRO



IFMACRO(!AddedStiffness)
macro AddedStiffness(Ub,symmetry)   
	(
	(1*(symmetry=="N")+2*(symmetry=="S"))
	*(
	int1d(th,2,21,22,23)(dy(Ub#p)*N.y)
	-nu*int1d(th,2,21,22,23)( (2*dyy(Ub#y)*N.y+(dxy(Ub#y)+dyy(Ub#x))*N.x) )
	)
	)
//EOM
ENDIFMACRO

IFMACRO(!NormalizeMode)
macro NormalizeMode(u)
{
/*complex norm =Portance(u,symmetry)/.5;*/
complex norm = u#Y;
u#x[] = u#x[]/norm;
u#A = u#A/norm;
u#V = u#V/norm;
u#Y = u#Y/norm;
}
//EOM
ENDIFMACRO

/////////////////////////////////////////////////////////////////////////////////
////// BUILD A-MATRIX ///////////////////////////////////////////////////////////

//varf for generalized eigenvalue problem: 
varf   LNSE ([ux,uy,up],[vx,vy,q]) =
	int2d(th)( 
		- Conv(u,Ub,v)		//Terme 2
		+ up*div(v)		//Terme 3
		-2*nu*(D(u):D(v))	//Terme 4
		+ div(u)*q		//Terme 5
		+ up*q*(eps) 		//Terme Stabilization
             )
	+ int2d(th)( -SHIFT*(ux*vx+uy*vy+up*q*eps) ) //For taking into acound the shift in B matrix
 	+BoundaryconditionsLNSE(u,v,formulation);

varf   LNSEadjointDiscrete ([ux,uy,up],[vx,vy,q]) =
	int2d(th)( 
		- Conv(v,Ub,u)		//Terme 2: 	THIS CHANGED
		+ up*div(v)		//Terme 3
		-2*nu*(D(u):D(v))	//Terme 4	/*Diffusion(nu,ux,uy,vx,vy)*//*
		+ div(u)*q		//Terme 5
		+ up*q*(eps)		//Terme Stabilization
             )
	+ int2d(th)( -conj(SHIFT)*(ux*vx+uy*vy+up*q*eps) ) 
// warning that shift/eigenvalues of adjoint are complex conjugates of direct !
	+BoundaryconditionsLNSE(u,v,formulation); //DIOGO



////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//Matrix A for fixed cylinder     //////////////////////////////////////////////////
matrix<complex> OPff;


////////////////////////////////////////////////////////////////////////////////////
//Matrix Afv for VIV cylinder		////////////////////////////////////////////
varf afv([vx,vy,q],[ux,uy,up]) = Portance(u,"A"); //We seek just the A modes, for the linear analysis
// effet du fluide sur la vitesse v ; correspond à la force verticale
// WARNING : c'est un vecteur LIGNE, il faut intervertir les inconnues et les fcns tests !
complex[int] Afv = afv(0,XXMh); // maniere de construire un vecteur COLONNE qui sera ensuite transpose


////////////////////////////////////////////////////////////////////////////////////
//Matrix Avf and Aaf for VIV cylinder         //////////////////////////////////////

varf avbfluid([ux,uy,up],[vx,vy,q]) = //utiliser les fonctions u comme fonctions testes
		int1d(th,2,21,22,23)(-vy*TGVCL*(formulation=="A")) // v = V on body if absolute velocity
		+int1d(th,1,4) (vy*TGVCL*(formulation=="R"))	// v = -V on boundary if relative velocity
		+int2d(th)( ( vx*dy(Ubx)+vy*dy(Uby) )*(formulation=="A")*(Frame=="R")); // term for RA formulation

complex[int] Avf(ux[].n);
Avf = avbfluid(0,XXMh);


varf afbfluid([ux,uy,up],[vx,vy,q]) =
		int2d(th)(-vy*(formulation=="R")*(Frame=="R")); // Noninertial acceleration

complex[int] Aaf(ux[].n);
Aaf = afbfluid(0,XXMh); 

// boundary conditions if breaking translation invariance

varf ayfluid([ux,uy,up],[vx,vy,q]) =
	//	int1d(th,1,4)(vx*dUInlet*TGVCL*(Frame=="R"))
		int1d(th,1,4)(-(vy*dy(Ubx)+vx*dy(Ubx))*TGVCL*(Frame=="R"))
	+   int1d(th,2,21,22,23)((vy*dy(Ubx)+vx*dy(Ubx))*TGVCL*(Frame=="A"))
	;

complex[int] Ayf(ux[].n);
Ayf = ayfluid(0,XXMh);


if (AddedSTIFFNESS==0)
{ cout << "COMPUTING ADDED STIFFNESS:" << endl;
AddedSTIFFNESS= AddedStiffness(Ub,"S");
}
if ("useAS"=="yes")
{ 
cout << "Using Added Stiffness in matrix" << endl;
STIFFNESS = STIFFNESS + AddedSTIFFNESS;
};
 




////////////////////////////////////////////////////////////////////////////////////
//Matrix A for VIV cylinder   	 	 ///////////////////////////////////////////

matrix<complex> OP;// mat OP = A - shift B
//OP = A+ (-SHIFT)*B; // Dont use it, because A and B are stored differently=>doesnt work


if(iadjoint=="D"){
	OPff=LNSE(XXMh,XXMh,solver=sparsesolver);
	shiftOP=SHIFT;
OP = 	[
	[OPff,		  	 Ayf,	     	Avf,		    Aaf],
	[   0,		  -shiftOP,	       1.,	 		0],
	[   0,		 	 0,		-shiftOP,			1],
	[Afv',		-STIFFNESS,	-DAMPING,			-MASS-shiftOP*eps]
	];
}
else if(iadjoint=="A"||iadjoint=="cA"){
		OPff=LNSEadjointDiscrete(XXMh,XXMh,solver=sparsesolver);
	Afv = conj(Afv);
	shiftOP=conj(SHIFT);
OP = 	[
	[OPff,			0,	       0,		      Afv],
	[   0,	 	 -shiftOP,	       0,	       -STIFFNESS],
	[Avf',	    		1,	-shiftOP,		 -DAMPING],
	[Aaf',			0,	       1,	-MASS-shiftOP*eps]
	];
}


set(OP,solver=sparsesolver);



/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
////// BUILD B-MATRIX ///////////////////////////////////////////////////////////
//Matrix B for fixed cylinder
varf b([ux,uy,up],[vx,vy,q]) = int2d(th)( (ux*vx+uy*vy+up*q*eps) );
matrix<complex> BFluid = b(XXMh,XXMh,solver=sparsesolver);  

/////////////////////////////////////////////////////////////////////////////////
// Terms of Matrix B for VIV cylinder
matrix<complex> B = 
		[ 	[BFluid, 0,	0,	0],
			[0,	1,	0,	0],
			[0,	0,	1,	0],
			[0,	0,	0,	eps]	//TERME DE STABILIZATION
		];
set(B,solver=sparsesolver);


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////


///////////////////// CALL TO EIGENVALUE SOLVER 
 
int k;
complex[int] ev(nev); // to store nev eigein values
complex[int,int] EigenVEC(OP.n,nev);

SFEVSOLVE(k,nev,OP,B,shiftOP,ev,EigenVEC);

int Nmodes = min(k,nev); // nb. de vecteurs propres à post-traiter



////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
// POST PROCESSING

	string namefile;
    namefile=ffdatadir+"Spectrum.txt";
    ofstream fileVP1(namefile); 
	
	for (int i=0;i<Nmodes;i++)
	{
       fileVP1 << real(ev[i]) << " " << imag(ev[i]) << " " << Re << " " << 0 << " " << real(shiftOP) << " " << imag(shiftOP) << endl;
       	cout << "$$ Valeur propre : " << i+1 << "  : " << ev[i] << endl;
        namefile=ffdatadir+"Eigenmode"+(i+1);
        complex uA,uV,uY;
 		 [ux[],uA,uV,uY] = EigenVEC(:,i);
 		 NormalizeMode(u); 
 		  {
 		  ofstream fileMode(namefile+".txt");
 		  fileMode << ux[]; 
 		  fileMode << endl << real(uA) << endl << imag(uA)  << endl;
 		  fileMode << endl << real(uV) << endl << imag(uV)  << endl;
 		  fileMode << endl << real(uY) << endl << imag(uY)  << endl;
 		  fileMode << endl << real(ev[i]) << endl << imag(ev[i])  << endl;
 		  }
 		 cout << "$$ Writing eigenmode in file " << namefile << endl;
 		 SFWriteModeVIV(namefile+".ff2m",u,ev[i],shiftOP,"Eigenmode",1);	  		 
 	};

	cout << "Writing Output Files Done" << endl;

