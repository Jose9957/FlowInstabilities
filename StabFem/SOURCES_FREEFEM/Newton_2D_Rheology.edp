//
//  PROGRAM Newton_2D.edp
//  computation of 2D base flow [ux,uy](x,y)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
// REwriten on october 2 2017 with macros.

		cout << "$$$$ ENTERING Newton_2D.edp " << endl << "$$" << endl; 
		include "SF_Geom.edp";
		include "StabFem.idp";

//////////////////////////////////////////////////////////////////////////////
//////////////////----->             MACROS         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////
//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your StabFem.idp file.
//
	
IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,u,v)
	           on(1,du#x=1-u#x,du#y=0.0)
	         + on(2,du#x=-u#x,du#y=-u#y)
	         + on(4,du#y=-u#y)  
             + on(5,du#x=-u#x)
             + int1d(th,6)(du#x*v#x*1e30*(symmetryBaseFlow=="A")+du#y*v#y*1e30*(symmetryBaseFlow=="S"))       
//EOM
ENDIFMACRO

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1);  
	p1forff2m xx,yy; 
	xx=x; yy=y;
	p1forff2m ut,vt,pt;
	ut=u#x; vt=u#y; pt=u#p;
    p1forff2m vort;
	vort=-dy(u#x)+dx(u#y); /* vorticity */
	p1forff2m psi,phi; /* stream function ; may not work in all cases */
	solve Laplace(psi,phi) = int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi))-int2d(th)(-vort*phi)+on(2,psi=0); 
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
    file << "datatype BaseFlow datastoragemode ReP2P2P1.5 " << endl;
	file << "real Re real Omegax real AspectRatio real Cu real nRheo P1 ux P1 uy P1 p P1 vort P1 psi real iter " << endl ;
	file << Re << endl;	
	file << Omegax << endl;	
	file << e << endl;	
	file << Cu << endl;	
	file << nRheo << endl;	
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
	};
}
//EOM
ENDIFMACRO
	    

//////////////////////////////////////////////////////////////////////////////
//////////////////----->             parameters         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////
 
	mesh th=readmesh(ffdatadir+"mesh.msh");
	
    fespace Xh(th,P2);       //f.e. space for veloecity components
	fespace Mh(th,P1);      //f.e space for pressure
	fespace XXMh(th,[P2,P2,P1]); // f.e. space for triplet [u,v,p]

	XXMh [ux,uy,up];          ///////  -> unknown for the Navier-Stokes problem
	XXMh [vx,vy,q];          ///////  -> test function for Navier-Stokes
	XXMh [upx,upy,upp];   	 ///////  -> buffer vector  to store previous iteration (Newton) 
	XXMh [dux,duy,dup]; 		 ///////  -> increment for the Newton iteration
	real Re,Omegax,e,Cu,nRheo;
	real Reans,Omegaxans,eans,Cuans,nRheoans;
	string symmetryBaseFlow;
	
	cout << "$$ Entrer Reynolds Number  >> " ;
    cin >>  Re; 
    cout << Re << endl;
    cout << "$$ Enter rotational speed  >> " ;
    cin >>  Omegax; 
    cout << Omegax << endl ;
    cout << "$$ Enter aspect ratio  >> " ;
    cin >>  e; 
    cout << e << endl << endl;
    cout << "$$ Enter Cu  >> " ;
    cin >>  Cu;
    cout << Cu << endl << endl;
    cout << "$$ Enter nRheo  >> " ;
    cin >>  nRheo;
    cout << nRheo << endl << endl;
    cout << "$$ Enter symmetry property of base flow  ? ('N','S', or 'A') >> ";
    cin >> symmetryBaseFlow;
    cout << symmetryBaseFlow << endl;


//////////////////////////////////////////////////////////////////////////////
//////////////////----->             Reading input files         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////



int testCB = 0;
try{ ifstream file(ffdatadir+"BaseFlow_guess.txt"); }
catch(...){testCB = 1; cout << "$$ NB : this 'ERROR' message is normal at this stage, the error was correcty caughth by StabFem. Relax !"; };

//	int testCB = exec("ls WORK/BaseFlow_guess.txt");
// ne marche pas avec windows !

    	if (testCB!=0)
		{
		cout << "$$ No file BaseFlow_guess.txt : strarting from arbitrary initial condition" << endl;
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
		macro DefaultGuessForNewton
		[ux,uy,up] = [0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
		else
		{
		cout << "$$ Reading file BaseFlow_guess.txt" << endl;
		 ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[];
		file >> Reans >> Omegaxans >> eans >> Cuans >> nRheoans;
		cout << "$$ Re of guess field : " << Reans << endl; 
		};



	cout << "$$ Starting Newton algorithm for Re = " << Re << endl;	
	
	real nu=1./(Re*e); // TO BE MODIFIED ???

/////////////////////////////////////////////////////////////////////////////////
                         /////// macro to define some useful operators

macro div(u) (dx(u#x)+dy(u#y))// macro for divergence 
macro Conv(ua,ub,v) ( 
              ((ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
macro D(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor

macro defTen(u) ( sqrt(2*(D(u):D(u)))  ) // EOM

macro muTen(u,CuNumb,n)  (  ( 1.0 + (CuNumb*defTen(u))^2.0 )^((n-1.0)*0.5)  ) // EOM

macro muTenLin(du,u,CuNumb,n) (  2*((n-1)*CuNumb^2*( 1.0 + (CuNumb*defTen(u))^2.0 )^((n-3.0)*0.5) )*(D(u):D(du))  ) // EOM

// parameters for Newton loop            
    real tolerance=2e-12;
    int Nitermax=30;
    real res=10;	
    int iter=0;


//////////////////////////////////////////////////////////////////////////////////

// definition of linear system to be solved at each step of the iteration
problem NewtonIter([dux,duy,dup],[vx,vy,q]) =
    int2d(th)( 
			-2*nu*( (muTen(up,Cu,nRheo)*D(du):D(v)) + (muTenLin(du,up,Cu,nRheo)*D(up):D(v)) )
             + q*div(du)
             + div(v)*dup
			 -Conv(up,du,v)
             )
             +
    int2d(th)(
    		-2*nu*( (muTen(up,Cu,nRheo)*D(up)):D(v) )
             + q*div(up)
             + div(v)*upp
             -.5*Conv(up,up,v)
             )
	+  BoundaryconditionsBaseFlow(du,up,v);     
    
        
// Newton loop
        while((res>tolerance)&(res<50)&(iter<=Nitermax))
        {
	    upx[]=ux[];      
        NewtonIter ;          
        ux[] = ux[]+dux[];
		real enerl2=dux[].l2;
		res=sqrt(int2d(th)(dux^2+duy^2)/th.area);
	    cout << "$$ Iter = "<< iter+1 << "   Re = " << Re << " ; res = " << res << " ; res l2 = " << enerl2 << endl;
        iter++;
	  } ;



// sortie des r?sultats 

		if((res>50)||(iter>Nitermax))
		{
			cout << "$$ NEWTON ITERATION FAILED" << endl;
			exec("rm "+ffdatadir+"BaseFlow.txt");
			SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",-1);
		}
		else
		
		{
		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << ux[]; 
		  file << endl  << Re;
		  file << endl  << Omegax << endl;
		  file << endl  << e << endl;
		  file << endl  << Cu << endl;
		  file << endl  << nRheo << endl;
		  }; 
          exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
         

          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver

    
		};
          
cout << "$$$$ SUCESSFULLY LEAVING Newton_2D.edp "  << endl; 
