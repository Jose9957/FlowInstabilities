//
//  PROGRAM Newton_Axi_Comp_COMPLEX.edp
//  computation of Axi compressible base flow [ux,uy,p,T,rho](x,y)
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma
//	INPUT FILES :
//		BaseFlow_guess.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//		BaseFlow.txt			-> base flow (FF format)
//      BaseFlow.ff2m         -> base flow (FF2M format) 
//
// 	ERROR MANAGEMENT : 
//      if Newton iteration diverges, BaseFlow.txt is not generated and "iter" parameter in BaseFlow.ff2m is -1.
//
//
// Incorporated by David Fabre from a code of Flavio
// Modified by Javier Sierra.


//////////////

load "MUMPS_FreeFem"
load "scotch";
//load "../../SOURCES_OTHER/VTK/iovtk"
include "SF_Geom.edp";
include "Param_Mapping.edp";
include "StabFem.idp";

real ts;
string ssparams = "nprow=1, npcol="+mpisize;
bool fplot=false;
int comp=0;

real Re;
real Reans,lecture;

real Ma;




if(mpirank==0)
{
	cout << " Enter Reynolds Number ?' " << endl;
	cin >> Re;

	cout << " Enter Mach Number ?' " << endl;
	cin >> Ma;

}

broadcast(processor(0),Re); 
broadcast(processor(0),Ma); 
cout << endl << " >>> RE = " << Re << "    ;  Mach = " << Ma << " MPIRANK " << mpirank <<endl;
	    
//////////////////////////////////////////////////////////////////////////////////////////////

real gamma=1.4; 
real Pr=0.7;
real nu = 1/Re;  
// If Nu is something else than 1/Re define a macro CUSTOMnu in your Macros_StabFem.idp file
IFMACRO(CUSTOMnu)
nu = CUSTOMnu;
ENDIFMACRO

// Velocity at the inlet 
//real Uinlet = (SFGeomRhole1/SFGeomRcav)^2;

mesh th;

//include "cyl_mesh.edp";
//mesh th;
if(mpirank==0)
  { 
    th=readmesh(ffdatadir+"mesh.msh");
    int[int] nupart(th.nt);
    nupart=0; 
    if(mpisize>1)
    scotch(nupart, th, mpisize);
    th=change(th,fregion= nupart[nuTriangle]);
   }
broadcast(processor(0),th); 



//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//verbosity=10;
//real Re=1.0;

//////////////////////////////////////////////////////////////////////////////////////////////

real TOLLERANCENewton=1e-7;  /// tollerance of newton loop
int NITERATIONNEWTLOOP=40;  //////////////  Max number of ITERATIONs --> Newton loop
real TOLLERANCEDiv = 20.0; // Tolerance to reset initial condition due to divergence of the Newton method.

///////////////////////////////////////////////////////////////////////////////////////////////
fespace XH2(th,P2);
//fespace XH1(th,P1);
//fespace XH0(th,P0);
///////////////////////////////////////////////////////////////////////////////////////////////	
fespace XXxxxxH(th,[P2,P2,P2,P1,P1,P1]); ///   pres P1 + vel 2x P2 + temp P1 + dens P1
//fespace XXxH(th,[P2,P2,P1]);	     ///   vel P2 +press P1
macro def(u,p,T,rho)[u#x,u#y,u#z,p,T,rho]//EOF


  
XXxxxxH<complex> def(du,dp,dT,drho);
XXxxxxH<complex> def(Ub,Pb,Tb,Rhob);
XXxxxxH<complex> def(Urif,Prif,Trif,Rhorif)=[0.0,0.0,0.0,1.0,1.0,1.0];

{
ifstream file(ffdatadir+"BaseFlow_guess.txt");
file >> Ubx[];
file >> Reans;
};

cout << "$$ Newton for Re = " << Re << endl;	
cout << "$$ Reynolds of the initial condition : " << Reans << endl;

macro div(im,u) ((Dx(u#x)+Dy(u#y)+u#y/Rphys(x,y,ParamMap)+im/Rphys(x,y,ParamMap)*u#z))// macro for divergence 
macro ugradf(im,u,f) ((u#x*Dx(f)+u#y*Dy(f) + im/Rphys(x,y,ParamMap)*u#z*f))    //
macro termnonlinear(im,u,v,w) ((w#x*(u#x*Dx(v#x)+u#y*Dy(v#x)+im*u#z*v#x/Rphys(x,y,ParamMap))
								+w#y*(u#x*Dx(v#y)+u#y*Dy(v#y)+im*u#z*v#y/Rphys(x,y,ParamMap)-u#z*v#z/Rphys(x,y,ParamMap))
								+w#z*(u#x*Dx(v#z)+u#y*Dy(v#y)+im*u#z*v#z/Rphys(x,y,ParamMap)+u#z*v#y/Rphys(x,y,ParamMap)))) //
macro Grad(im,u) [[Dx(u#x),Dx(u#y),Dx(u#z)],
			   [Dy(u#x),Dy(u#y),Dy(u#z)],
			   [im/Rphys(x,y,ParamMap)*u#x,im/Rphys(x,y,ParamMap)*u#y-u#z/Rphys(x,y,ParamMap), im/Rphys(x,y,ParamMap)*u#z+u#y/Rphys(x,y,ParamMap)]]//EOM
macro Strain(im,u) [	
				[Dx(u#x), 				.5*(Dx(u#y)+Dy(u#x)),  .5*(im/Rphys(x,y,ParamMap)*u#x+Dx(u#z)) ], 
				[.5*(Dx(u#y)+Dy(u#x)), 	Dy(u#y),				.5*(im/Rphys(x,y,ParamMap)*u#y-u#z/Rphys(x,y,ParamMap)+Dy(u#z))],
				[.5*(im/Rphys(x,y,ParamMap)*u#x+Dx(u#z)),  .5*(im/Rphys(x,y,ParamMap)*u#y-u#z/Rphys(x,y,ParamMap)+Dy(u#z)), im/Rphys(x,y,ParamMap)*u#z+u#y/Rphys(x,y,ParamMap)]
				] // macro for rate-of-deformation tensor
macro gradgrad(im,u,v)(Dx(u)*Dx(v)+Dy(u)*Dy(v)+(im*im)/(Rphys(x,y,ParamMap)*Rphys(x,y,ParamMap))*u*v)//EOM

varf jacobian(def(du,dp,dT,drho),def(us,ps,Ts,rhos))=int2d(th,mpirank) (JJ*(Rphys(x,y,ParamMap)*(rhos*(drho*div(1i*m,Ub)+Rhob*div(1i*m,du)+ugradf(1i*m,Ub,drho)+ugradf(1i*m,du,Rhob)) 
								       //mass equation
								       -dp*div(1i*m,us)
								       +2.0/Re*(Strain(1i*m,du):Grad(1i*m,us))-2.0/(3.0*Re)*(div(1i*m,du)*div(1i*m,us))+Rhob*termnonlinear(1i*m,du,Ub,us)+drho*termnonlinear(1i*m,Ub,Ub,us)+Rhob*termnonlinear(1i*m,Ub,du,us)
								       //momentum
								       +Ts*(drho*ugradf(1i*m,Ub,Tb)+Rhob*ugradf(1i*m,Ub,dT)+Rhob*ugradf(1i*m,du,Tb)
								       	+(gamma-1)*(drho*Tb*div(1i*m,Ub)+Rhob*dT*div(1i*m,Ub)+Rhob*Tb*div(1i*m,du))
								       	-gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(1i*m,du):Strain(1i*m,Ub))+(Strain(1i*m,Ub):Strain(1i*m,du)))
								       	-2.0/3.0*(2.0*div(1i*m,Ub)*div(1i*m,du))))+gamma/(Pr*Re)*gradgrad(1i*m,dT,Ts)
								       // energy
								       +ps*(gamma*Ma^2*dp-(drho*Tb+Rhob*dT))
								       )))
  +BoundaryconditionsBaseFlow(du,dp,dT,drho,us,rhos,Ts,Uinlet);


varf vNs(def(du,dp,dT,drho),def(us,ps,Ts,rhos))=-int2d(th,mpirank)(JJ*(Rphys(x,y,ParamMap)*(rhos*(Rhob*div(1i*m,Ub)+ugradf(1i*m,Ub,Rhob))
							   //mass equation
							   -Pb*div(1i*m,us)
							   //+gradpdotv(Pb,us)
							   +2.0/Re*(Strain(1i*m,Ub):Grad(1i*m,us))-2.0/(3.0*Re)*(div(1i*m,Ub)*div(1i*m,us))
							   +Rhob*termnonlinear(1i*m,Ub,Ub,us)
							   //momentum
						    	+Ts*(Rhob*ugradf(1i*m,Ub,Tb)+(gamma-1.)*Rhob*Tb*div(1i*m,Ub)
							   	-gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(1i*m,Ub):Strain(1i*m,Ub)))
								-2.0/3.0*(div(1i*m,Ub)*div(1i*m,Ub))))+gamma/(Pr*Re)*gradgrad(1i*m,Tb,Ts)
							   // energy
							   +ps*(1.0+gamma*Ma^2*Pb-(Rhob*Tb))
							   )))
  +BoundaryconditionsBaseFlow(du,dp,dT,drho,us,rhos,Ts,Uinlet);

real res,ener=1.;
if(mpirank==0)
  {
    cout << " ................................................... "<< endl;	
    cout << " ................................................... "<< endl;	
  }
int contout=0;

  
    ///////////////////////////////////////////////////////////////////////
    
    
    

	res=1.0;
	ener=1.0;
	

	 
	  int i=0;
	  while((ener>TOLLERANCENewton)&(i<=NITERATIONNEWTLOOP))
	    {
	      ts=clock();
	      
	      matrix<complex> NewtLoc=jacobian(XXxxxxH,XXxxxxH);
	      matrix<complex> Newt;
	      mpiAllReduce(NewtLoc,Newt,mpiCommWorld,mpiSUM);
	      if(mpirank==0)
		cout<<"Matrix formed in "<<clock()-ts<<" s"<<endl;  
	      complex[int] rhsl= vNs(0,XXxxxxH);
	      complex[int] rhs(Newt.n);
	      mpiAllReduce(rhsl,rhs,mpiCommWorld,mpiSUM);
	      set(Newt,solver=sparsesolver,sparams=ssparams);
	      dux[] =  (Newt^-1*rhs);
	      ener=sqrt(abs(int2d(th)(JJ*(Rphys(x,y,ParamMap)*(abs(duy)^2+abs(dux)^2))))); 
	      if(mpirank==0)
		{
		  cout << "iter "<<i<<" | BNorm of u = " << ener << endl;
		}
	      Ubx[]+=dux[];
	      i++;	    
	    if(ener > TOLLERANCEDiv && i <= 5)
	    {
	    	cout << "Initial condition has been reseted" << endl;
	    	Ubx[] = Urifx[];
	    }
	     }// end of NEWTON LOOP
	     
	     /// NEXT IS PLOT AND POSTPROCESS
	  
	  if(mpirank==0)
	    {
	      //cout << "p,T,rho,u,v at (5,0): " << pp(5,0) << " " << Tp(5,0) << " " << rhop(5,0) << " " << uxp(5,0) << " " << uyp(5,0) << endl;
	      cout << " -------------------------------------------------------- "<< endl;	
	      plot(Pb,fill=1,value=1,cmm="press");
	      plot(Uby,fill=1,value=1,cmm="vel: y-component");
	      plot(Ubx,fill=1,value=1,cmm="vel: x-component");
	      plot(Tb,fill=1,value=1,cmm="Temp");
	      plot(Rhob,fill=1,value=1,cmm="density");
	      cout << " Newton iteration ok!"<< endl;
	    };
	  
	  
	  
	  ////// OUTPUT FOR STABFEM  
	    
	    // sortie des r?sultats 

		if((ener>50)||(iter>Nitermax))
		{
			cout << "$$ NEWTON ITERATION FAILED" << endl;
			cout << "$$ Leaving FreeFem++ with error code 201" << endl;
			exit(201);
		};
		

// temporary fix
XXxxxxH<complex> [ux,uy,uz,up,utemp,uro] = [(Ubx),(Uby),(Ubz),(Pb),(Tb),(Rhob)];
XXxxxxH [urx,ury,urz,urp,urtemp,urro] = [real(Ubx),real(Uby),real(Ubz),real(Pb),real(Tb),real(Rhob)];

		{
		  {ofstream file(ffdatadir+"BaseFlow.txt"); // file in .txt format for FreeFem solvers
		  file << ux[]; 
		  file << endl << endl << Re;
		  }; 
        //  exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_guess.txt"); 
         

          SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",ur,"BaseFlow",i); // file in .ff2ml format for StabFem driver
          int[int] forder=[1,1,1,1];
		  savevtk(ffdatadir+"/BflowCM_Re"+Re+"_M"+Ma+".vtk",th,urp,[urx,ury,urz],urtemp,urro,order=forder,dataname="p u T rho");
		};
          

	    
	    
	  



