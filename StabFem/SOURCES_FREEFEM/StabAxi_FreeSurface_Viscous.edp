///
// PROGRAM StabAxi_FreeSurface_Viscous.edp
// STILL TO BE RATIONALIZED A LOT !!!


//  Computation of the eigenvalues and eigenvectors for oscillations of a static meniscus (GENERAL PROGRAM)
// ----------------------------------------
// the problem is viscous : 


// previous comment : inviscid potential
// u = grad (phi) 
// PROBLEM : find $\omega$ and $[phi,eta]$  such that
// 	$$ \Delta \phi = 0 $$ inside the domain
// 	$$ \lambda \phi = - \gamma (-(K0a^2+K0b^2) \eta - \partial^2 \eta / \partial s^2 + m^2/r^2 \eta $$ on the free surface
// 	$$ \lambda \eta = grad \phi \dot n $$ on the free surface 
// 
//-----------------------------------------

// Remarque : phi et eta sont definis comme des champs P1 sur le volume, meme si eta n'a de sens qu'à la surface


include "StabFem.idp"

verbosity=0;

// constantes physiques 
//real g=0;                 // Gravity field
real gamma=1;	  // Surface Tension
real R=1;
real dpdz;
real nu;
real GAMMABAR;
//cout << "ENTREZ LA TENSION DE SURFACE GAMMA : "<< endl;
//cin >> gamma;
//if(gamma != 1){ 
//	// TO BE MODIFIED !
//	cout << "WARNING : PROGRAM HAS TO BE ADAPTED FOR GAMMA ~= 1"<< endl; 
//	exit(-1);
//	} ;

//cout << "ENTREZ LE PARAMETRE DE GRAVITE dp/dz = rho g : "<< endl;
//cin >> dpdz;


{
ifstream file(ffdatadir+"BaseFlow.txt");
file >> gamma >> dpdz >> GAMMABAR;
cout << "$$$ successfully read BF file containing physical parameters " << endl;
cout << "$$$ Surface tension gamma = " << gamma<< endl;
cout << "$$$ gravity rho g = " << dpdz<< endl;
cout << "$$$ circulation Gamma/(2 pi) = " << GAMMABAR << endl; 
}
if(GAMMABAR!=0)
{ cout << "WARNING : circulation not implemented in this solver " << endl;
exit(1);
};


cout << "ENTREZ LA VISCOSITE NU : "<< endl;
cin >> nu;

string typestart,typeend;
cout << "%% ENTREZ typestart (pined, axis, plane, freeH, freeV) : ";
cin >> typestart;
cout << typestart << endl;

cout << "%% ENTREZ typeend (pined, axis, freeH, freeV) : ";
cin >> typeend;
cout << typeend << endl;


int m;  // Nombre d'onde
cout << " ENTREZ Le nombre d'onde m ?" << endl;
cin >> m;

cout << " Enter SHIFT (re,im) :   " << endl; 
	real shiftr,shifti;
	cin  >> shiftr >> shifti;
	complex shift = 1i*shifti+shiftr;

int nev;
cout << " Enter nev ? (will use simple shift-invert if nev = 1)" << endl;
cin >> nev ;
	
	
IFMACRO(!SFWriteMode)		
macro SFWriteMode(namefile,MODE,ev)
  {	
   	fespace P1forfile(th,P1);
    P1forfile<complex> Etaforfile,K1forfile;
    Etaforfile=MODE#eta;
    K1forfile=MODE#k1;
   	{
	ofstream file(namefile);
	file << "### Data generated by Freefem++ ; " << endl;
    file << "Eigenmode of a free-surface problem (VISCOUS)" << endl;
    file << "datatype Eigenmode datastoragemode CxP1bP1bP1bP1P1P1 datadescriptors ur,uz,ut,p" << endl;
	file << "complex* lambda int* m P1surfc eta P1surfc K1" << endl << endl ;
	file << real(ev) <<  endl << imag(ev) << endl << m << endl << endl; 
		for(int ksurf=0;ksurf<Nsurface+1;ksurf++) 
	     { file << real(Etaforfile(xPointSurf(ksurf), yPointSurf(ksurf) )) << endl;
	       file << imag(Etaforfile(xPointSurf(ksurf), yPointSurf(ksurf) )) << endl; 
   	     };
	file << endl;
		for(int ksurf=0;ksurf<Nsurface+1;ksurf++) 
	     { file << real(K1forfile(xPointSurf(ksurf), yPointSurf(ksurf) )) << endl;
	       file << imag(K1forfile(xPointSurf(ksurf), yPointSurf(ksurf) )) << endl; 
   	     };
	file << endl;
	
   };
  }
//EOM	
ENDIFMACRO


// Parametres du calcul

cout << "==> Calcul des valeurs propres pour m = " << m << endl;


int Nval = nev;  // nb. de valeurs propres à calculer
//int Nmodes = Nval; // nb. de vecteurs propres à post-traiter
int ncv = 4*nev;   ///// Krylov Basis





////////////////////////////////////////////////////////////////
//
// MAILLAGE ET GEOMETRIE INITIAUX
//
////////////////////////////////////////////////////////////////


mesh th=readmesh(ffdatadir+"mesh.msh");
//mesh th=th; // autre nom possible...
mesh thsurface;
if(typesurfacemesh=="plain") 
{
thsurface = th; 	// Maillage 'surface'
};
if(typesurfacemesh=="empty") 
{
thsurface = emptymesh(th); 	// Maillage 'surface'
};
real L, K0, Vol, Area, PP0; // is this useful ?

include "Macros_Geometry_FreeSurface.idp"


//include "Macros_Geometry_FreeSurface.edp"
//include "Macros_Geometry_Surface.edp"

SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); // cf. macro
// Calcul des normales et des courbures
CalcGeomSurf;



fespace P1bP1bP1bP1P1P1(th,[P1b,P1b,P1b,P1,P1,P1]);
fespace PP1(th,P1);

P1bP1bP1bP1P1P1<complex> [uz,ur,uphi,up,ueta,uk1],[vz,vr,vphi,vp,veta,vk1];


//real shift = 1e-12;  // value of the shift
real RegEta = 1e-8;


macro div(im,u) (dy(u#z)+dx(u#r)+u#r/x+im/x*u#phi)// macro for divergence 
//macro Grad(im,u) [
//			[dy(u#z), dx(u#z),  im/x*u#z ], 
//			[dy(u#r), dx(u#r),  im/x*u#r-u#phi/x],
//			[dy(u#phi),dx(u#phi), im/x*u#phi+u#r/x ]
//			] // macro for vecocity gradient tensor
macro D(im,u) [	
				[dy(u#z), 				.5*(dx(u#z)+dy(u#r)),  .5*(im/x*u#z+dy(u#phi)) ], 
				[.5*(dx(u#z)+dy(u#r)), 	dx(u#r),				.5*(im/x*u#r-u#phi/x+dx(u#phi))],
				[.5*(im/x*u#z+dy(u#phi)),  .5*(im/x*u#r-u#phi/x+dx(u#phi)), im/x*u#phi+u#r/x]
			   ] // macro for rate-of-deformation tensor

//macro Conv(ima,ua,imb,ub,v) ( 
//              (Grad(ima,ua)*[ub#x,ub#r,ub#phi] + Grad(imb,ub)*[ua#x,ua#r,ua#phi])'*[v#x,v#r,v#phi]
//              			) // macro for mutual convection operator



// Warning boundary labelling :
// 2 surface, 1 axis, 5 plates.
// should be changed to 8, 6, 2.

// CONSTRUCTION DES MATRICES

macro nr() N0r // 
macro nz() N0z //


varf a([uz,ur,uphi,up,ueta,uk1],[vz,vr,vphi,vp,veta,vk1]) = 
 	int2d(th)(
 	         ( 
   			 - 2*nu*(D(1i*m,u):D(-1i*m,v))
             + up*div(-1i*m,v)
             + div(1i*m,u)*vp
             )*x
             )   	
	+ int1d(th,2)(gamma*uk1*(vz*nz+vr*nr)*x)  // dynamic BC
	+ int1d(th,2)(-vz*dpdz*ueta*nz*x)// gravity
	+ int1d(th,2)(veta*(uz*nz+ur*nr)*x) // kinematic BC
	+ int1d(th,2)((uk1*vk1+(Ds(ueta))*(Ds(vk1))-(K0a^2+K0b^2)*ueta*vk1+m^2/x^2*vk1*ueta
	             //-1e-5*((Ds(uk1))*(Ds(vk1))-(K0a^2+K0b^2)*uk1*vk1+m^2/x^2*vk1*uk1) // test
	             ) *x) // def of k1
	+ int2d(th)( -shift*(uz*vz+ur*vr+uphi*vphi)*x ) // shift volume
	+ int1d(th,2)(-shift*ueta*veta*x) // shift surface
	+ int2d(th)(1e-8*(ueta*veta+uk1*vk1)*x )
	+ int1d(th,5,55)(1e15*ueta*veta*((typestart=="pined")||(typeend=="pined"))) // pinned contact lines
	+ int1d(th,1)(uz*vz*1e15*(abs(m)>0)+(ur*vr+uphi*vphi)*1e15*(abs(m)!=1))
	+ int1d(th,1)(1e15*(uk1*vk1)*(abs(m)>0)) //axis 
//	+ on(5,55,ur=0,uz=0,uphi=0) // plates
	+ int1d(th,5,55)(1e15*(ur*vr+uz*vz+uphi*vphi))
;

varf b([uz,ur,uphi,up,ueta,uk1],[vz,vr,vphi,vp,veta,vk1]) =
      int2d(th)((uz*vz+ur*vr+uphi*vphi)*x )
    + int1d(th,2)(ueta*veta*x)
;


////////////////////////////////////////////////////
//
//  RESOLUTION DU PB AUX VALEURS PROPRES
//
//  Important warning : here the computed eigenvalues correspond to omega = lambda/i !
//  
/////////////////////////////////////////////////////


matrix<complex> OP= a(P1bP1bP1bP1P1P1,P1bP1bP1bP1P1P1,solver=sparsesolver,tgv=1e15); 
matrix<complex> B= b(P1bP1bP1bP1P1P1,P1bP1bP1bP1P1P1,solver=CG); 

//int nev=Nval;  // number of computed eigen valeu close to sigma
//complex[int] ev(Nval); // to store nev eigein values
//P1bP1bP1bP1P1P1<complex>[int] [eVuz,eVur,eVuphi,eVp,eVeta,eVK1](Nval);   // to store nev eigen vectors
//int k=EigenValue(OP,B,sigma=shift,value=ev,vector=eVuz,tol=1e-8,maxit=0,ncv=ncv);  

int k;
complex[int] ev(nev); // to store nev eigein values
complex[int,int] EigenVEC(OP.n,nev);

//cout << "Dimensions A, B : "<<  A.m << " x " << A.n << " and  " <<  B.m << " x " << B.n << endl; 

SFEVSOLVE(k,nev,OP,B,shift,ev,EigenVEC);

int Nmodes = min(k,nev); // nb. de vecteurs propres à post-traiter




////////////////////////////////////////////////////
//
//    POST TRAITEMENT
//
///////////////////////////////////////////////////




cout << " ### VP Calculees :" << endl;

//real[int]  eev(Nval);
ofstream EV(ffdatadir+"Spectrum.txt");
EV.scientific;
P1bP1bP1bP1P1P1<complex> [MODEz,MODEr,MODEphi,MODEp,MODEeta,MODEk1];

for (int i=0;i<Nmodes;i++)
  {
    cout << " VP numero " <<  i << " : " << real(ev[i]) << "+i" << imag(ev[i]) <<  endl;
    EV << real(ev[i]) << "  " << imag(ev[i]) << " " << L << "  " << K0  << " " << Vol << "  " << dpdz << "   " << m  
    << endl; 

// Normalisation of the modes
//        ueta[] = eVuz[i][];
		ueta[] = EigenVEC(:,i);
        complex norm;
        {
        PP1<complex> uetaTEMP=ueta;
        real[int] Xx = uetaTEMP[].re;
        real[int] Yy = uetaTEMP[].im;
        real[int] etaRAD  = Xx.*Xx;
                  etaRAD += Yy.*Yy;
        etaRAD = sqrt(etaRAD);
        int Imax = etaRAD.imax;
        norm =  uetaTEMP[][Imax];
      // if(norm ==0){ cout << "WARNING  : dected norm = 0 !" << endl; norm =1; };
        }
		ueta[] = 1/norm*ueta[];


  
// Post-traitement MODES
  if (i<k)
     {	
   	  ofstream FileTXT(ffdatadir+"Eigenmode"+(i+1)+".txt");
   	  FileTXT << ueta[];
   	  FileTXT << endl << endl;
   	  FileTXT << real(ev[i]) << " " << imag(ev[i]) << endl;
   	  MODEz[] = ueta[];
     SFWriteMode(ffdatadir+"Eigenmode"+(i+1)+".ff2m",MODE,ev[i]);

IFMACRO(FREEFEMPLOTS,YES)   
      plot(MODEr,cmm="mode numero"+i+" : ur", wait=1); 
      plot(MODEz,cmm="mode numero"+i+" : uz", wait=1); 
      plot(MODEphi,cmm="mode numero"+i+" : uphi", wait=1);	
      plot(MODEeta,cmm="mode numero"+i+" : eta", wait=1); 	
ENDIFMACRO

     };
  };	
	
// HACK for compatibility
if(nev==1)
{ 
  exec("cp "+ffdatadir+"Eigenmode0.txt "+ffdatadir+"Eigenmode.txt");
  exec("cp "+ffdatadir+"Eigenmode0.ff2m "+ffdatadir+"Eigenmode.ff2m");
};




