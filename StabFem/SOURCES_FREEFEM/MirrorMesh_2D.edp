

//
//  PROGRAM MirrorMesh.edp
//  Symmetrizes a mesh and a base flow
//   
// 	INPUT FILES
//		mesh.msh
//		BaseFlow.txt
//
//	OUTPUT FILES
//		mesh_mirror.msh
//		mesh_mirror.ff2m (and associated auxiliary files if relevant)
//		BaseFlow_mirror.txt
//		BaseFlow_mirror.ff2m
//
//	IMPORTANT NOTE :
//		currently the program will only work with [P2,P2,P1] data.
//		in the "mirroring" process the data is downgraded to [P1,P1,P1] 
//		so it is mandatory to recompute the flow afterwards 
//
//	This program is part of the StabFem project distributed under gnu public licence.
//  copyright D. Fabre & coauthors, 2017-2019



		cout << "$$$$ ENTERING MirrorMesh.edp " << endl << "$$" << endl; 
//		include "SF_Geom.edp";
		include "StabFem.idp";

//
// Parameters
//

	string symmetry = "S";
    string symmetryBaseFlow = "S";
	


//////////////////////////////////////////////////////////////////////////////
//////////////////----->             MACROS         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////
//
// Note : this solver requires three macros BoundaryConditionsBaseFlow, SFWriteBaseFlow.
// Below are "default" values for these macros, to be used in the most basic cases. If you want to
// customize these macros don't modify them here but copy them to your StabFem.idp file.
//
	


IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	fespace p1forff2m(th,P1);  
    p1forff2m vort;
	vort=-dy(u#x)+dx(u#y); /* vorticity */
	p1forff2m psi,phi; /* stream function ; may not work in all cases */
	solve Laplace(psi,phi) = int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi))-int2d(th)(-vort*phi)+on(2,psi=0); 
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for a 2D-incompressible problem (using GENERIC MACRO)" << endl;
    file << "datatype BaseFlow datastoragemode ReP2P2P1.1 datadescriptors ux,uy,p,Re" << endl;
	file << "real* Re P1 vort P1 psi real iter " << endl ;
	file << Re << endl;	
			for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	file << iter << endl;
	};
//EOM
ENDIFMACRO
	    

//////////////////////////////////////////////////////////////////////////////
//////////////////----->             parameters         <-----///////////////////
/////////////////////////////////////////////////////////////////////////////////
 
 real alpha; // needed for some cases
 
 //  Reading half-mesh and corresponding half-base flow
     
		mesh th1=readmesh(ffdatadir+"mesh.msh");
		
        fespace Xh(th1,P2);       //f.e. space for veloecity components
		fespace Mh(th1,P1);      //f.e space for pressure
		fespace XXMh(th1,[P2,P2,P1]); // f.e. space for triplet [u,v,p]
		fespace MMMh(th1,[P1,P1,P1]); // f.e. space for reprojecting (works only with P1 data)

		XXMh [ux,uy,up];  	
		real Re;
		{
		cout << "$$ Reading file BaseFlow.txt" << endl;
		 ifstream file(ffdatadir+"BaseFlow.txt");
      	file >> ux[];
		file >> Re;
		cout << "$$ Re of guess field : " << Re << endl; 
		};
		real nu = 1/Re;

	MMMh [uxA,uyA,upA]= [ux,uy,up];

IFMACRO(FREEFEMPLOTS,YES)
plot(ux,wait=1);
ENDIFMACRO

		// mirrored mesh

		mesh thM; 		
		thM = movemesh(th1,[x,-y]); 
		fespace XXMhMirror(thM,[P2,P2,P1]);
		fespace MMMhMirror(thM,[P1,P1,P1]); 
		MMMhMirror [uMxA,uMyA,uMpA];

		
		uMxA[]=uxA[];

IFMACRO(FREEFEMPLOTS,YES)
plot(uMxA,wait=1);
ENDIFMACRO		
		
	XXMhMirror [uMx,uMy,uMp];
		if(symmetry=="S")
			{
			[uMx,uMy,uMp] = [uMxA,-uMyA,uMpA];
			};
	    if(symmetry=="A")
			{
			[uMx,uMy,uMp] = [-uMxA,uMyA,-uMpA];
			};

			
	symmetry = "N";
    symmetryBaseFlow = "N";

		
		cout << "sucessfully created mirrored mesh" << endl;
		
		// Full mesh and base flow	
		
		mesh th = th1+thM;
		fespace XXMhF(th,[P2,P2,P1]); 
        fespace p1N(th,P1);
        p1N halfplus = (y>0?1:0);
        p1N halfmoins = 1-halfplus;
		XXMhF [uFx,uFy,uFp] = [ux*halfplus+uMx*halfmoins,uy*halfplus+uMy*halfmoins,up*halfplus+uMp*halfmoins];
		cout << "toto" << endl;
//		fespace XXMhF(th,[P2,P2,P1]); 
//		XXMhF [uFx,uFy,uFp]=[uFxA,uFyA,uFpA];
		cout << "sucessfully glued meshes" << endl;

// CHANGING LABEL 6 TO 69
int[int] r1=[6,69];
th = change(th, label=r1);


		
IFMACRO(FREEFEMPLOTS,YES)
plot(uFx,wait=1);
plot(uFy,wait=1);
ENDIFMACRO





cout << endl << "$$#### Mesh information AFTER MIRROR :" << endl;  
        cout << "$$#### Number of vertices    " << th.nv <<  endl;
	   // cout << "$$### Dimension of matrices " << vB[].n << endl << endl;


	savemesh(th,ffdatadir+"mesh_mirror.msh");
	
	IFMACRO(SFWriteMesh)
	SFWriteMesh(ffdatadir+"mesh_mirror.ff2m",th,"mirror");
	ENDIFMACRO
	
	IFMACRO(SFWriteConnectivity)
	SFWriteConnectivity(ffdatadir+"mesh_mirror_connectivity.ff2m",th);
	ENDIFMACRO
	
	IFMACRO(COORDINATEMAPPING,YES)
	SFWriteMapping(ffdatadir+"mesh_mirror_mapping.ff2m",th);
	ENDIFMACRO
	
	IFMACRO(FREESURFACE,YES)
	if(typesurfacemesh=="plain") 
	{
	thsurface = th; 	/* Maillage 'surface'*/
	};
	if(typesurfacemesh=="empty") 
	{
	thsurface = emptymesh(th); 	/* Maillage 'surface'*/
	};
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface);
	SFWriteSurface(ffdatadir+"mesh_mirror_surface.ff2m",th); // A REPRENDRE CAR CA NE MARCHERA PAS
	ENDIFMACRO


	IFMACRO(FREESURFACE,ALE)
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface);
	SFWriteMeshSurface(ffdatadir+"mesh_mirror_surface.ff2m",th); 
	// A REPRENDRE CAR CA NE MARCHERA PAS
	ENDIFMACRO


		  {ofstream file(ffdatadir+"BaseFlow_mirror.txt"); // file in .txt format for FreeFem solvers
		  file << uFx[]; 
		  file << endl  << Re;
		  file << endl  << 0 << endl;
		  }; 
                
          SFWriteBaseFlow(ffdatadir+"BaseFlow_mirror.ff2m",uF,"BaseFlow",0); // file in .ff2ml format for StabFem driver

   
          
cout << "$$$$ SUCESSFULLY LEAVING Newton_2D.edp "  << endl; 
