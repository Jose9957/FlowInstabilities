//
//  PROGRAM AdaptMesh.edp 
//   
// Usage : FreeFem++ AdaptMesh.edp 
//
//  INPUT PARAMETERS : Nfields Datastoragemode1 Nscalar1 [Datastoragemode2 Nscalar2...]
//   Datastoragemode is e.g. ReP2P2P1 for 2D flowfield (real storage mode)
//   Nscalar1 is number of scalars at the end of file, e.g. Re which is written at the last line in most baseflow files 
//				(these scalars are not used for adaptation but recopied in post-adaptation files)
//
//	INPUT FILES :
// 		mesh.msh ->  mesh in Freefem format
//		[FlowFieldToAdapt1.txt -> First flowfield to interpolate on new mesh]
//		[FlowFieldToAdapt2.txt -> Second flowfield to interpolate on new mesh]
//      [ ... ]
//
//  OUTPUT FILES :
//		mesh_adapt.msh -> New mesh
//		mesh_adapt.ff2m -> associated mesh information file
//		[FlowFieldAdapted1.txt -> First flowfield interpolated on new mesh]
//		[FlowFieldAdapted2.txt -> Second flowfield interpolated on new mesh]
//      [ ... ]
//
//  NB : 1/ program can work up to nfields = 8 (8 real fields, or 4 complex).
//		 2/ type of data currently handled comprises P2P2P1 (2D), P2P2P2P1 (3D), P2P2P1P1P1 (2D-compressible), P2P2P2P1P1P1 (3D-compressible), P2 (e.g. sensitivity), ...
//		 2/ After the data the files may contain a number "scalarnumber" of real scalars 
//					(for instance baseflows will contain a single scalar (scalarnumber=1) : Re, eigenmodes will contain eigenvalues (2 reals with scalarnumber=2), etc...)
//			Such scalars are simply rewritten at the end of files as is.
//
//
// 	ERROR MANAGEMENT : 
//
//  This is part of the StabFem project distributed under gnu licence, Copyright D. Fabre et al., 
//
//  Redesigned in September 2018
//


	verbosity = 0;
//	include "SF_Geom.edp";
	include "StabFem.idp";
	IFMACRO(COORDINATEMAPPING,YES)
//	include "Param_Mapping.edp";
	ENDIFMACRO
	
//string typestart,typeend;

IFMACRO(!SFWriteConnectivity) // this should be in StabFem.idp but if not present use this default one
macro SFWriteConnectivity(filename,Th)
  {
  ofstream file(filename);
  fespace p2MACRO(Th,P2);
  int p2connectivitylength = Th.nt*p2MACRO.ndofK;
  p2MACRO totozuzu;
  int np2 = totozuzu[].n;
  file << "### File generated by Freefem++ ; " << endl;
  file << "connectivity data for P2 or other formats" << endl;
  file << " " << endl; 
  file << "int np2 real." << p2connectivitylength  << " P2connectivity"  << endl;
  file << np2 << endl;
  for (int i=0; i<Th.nt; i++)
  	{
    for (int j=0; j<p2MACRO.ndofK; j++)
    	{
      	file << p2MACRO(i,j) << "\n";
    	}
  	}
} //EOM
ENDIFMACRO



// Input parameters
string typemeshmanipulation;
int nfields;
int nfieldsmax = 8;
int nscalarmax = 100;
string[int] datastoragemode(nfieldsmax);
int[int] scalarnumber(nfieldsmax);
real[int,int] scalars(nfieldsmax,nscalarmax);
complex[int,int] scalarscomplex(nfieldsmax,nscalarmax);

real[int,int] scalefield(nfieldsmax,3);

cout << "$$ ###################################" << endl;
cout << endl << "$$       ADAPTMESH.edp        " << endl; 
cout << endl << "$$ ###################################" << endl << endl;


cout << "$$ Enter nfields (number of fields to be used for adaptation) >> " ;
cin >> nfields ;
cout << nfields << endl;

for(int i = 0;i<nfields;i++)
    {
    cout << "$$ Enter storage mode of .txt file number " << i  << " ? (string like ReP2P2P1, etc...) >> " ;
    cin >> datastoragemode[i] ;
	cout << datastoragemode[i] << endl ;
    cout << "$$ Enter number of additional real scalars associated to flowfield in file number "<< i  << " >>  " ;
    cin >> scalarnumber[i] ; 
    cout << scalarnumber[i] << endl; 
    };
cout << endl << "$$ Adapting mesh to " << nfields << " flowfields" ;

cout << endl << endl;

 int nsplit=getARGV("-split",0);
if (nsplit!=0)
	{cout << " USING AdaptMesh.edp to SPLIT instead of ADAPTING ; level of split is " << nsplit << endl;};


// READ MESH 
	mesh th=readmesh(ffdatadir+"mesh.msh");
	mesh thold = th;
	int nvprev = th.nv;
    string typeth = "adapted";

IFMACRO(FREESURFACE,YES)
	mesh thsurface;
	if(typesurfacemesh=="plain") 
	{
	thsurface = th; 	// Maillage 'surface'
	};
	if(typesurfacemesh=="empty") 
	{
	thsurface = emptymesh(th); 	// Maillage 'surface'
	};
	string typestart,typeend;
	typestart="??"; typeend="??";
	
	include "Macros_Geometry_FreeSurface.idp"
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); // cf. macro
	CalcGeomSurf;
	cout << "Nsurface before ADAPT : " << Nsurface << endl;
ENDIFMACRO

IFMACRO(FREESURFACE,ALESTRAIN)
	string NormalVectEND = "ex";
	include "Macros_Paul.idp"
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); // cf. macro
	CalcGeomSurf;
	cout << "Nsurface before ADAPT : " << Nsurface << endl;
ENDIFMACRO

IFMACRO(FREESURFACE,ALE)
	include "Macros_Curvature.idp";
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); // cf. macro
	CalcGeomSurf;
	cout << "Nsurface before ADAPT : " << Nsurface << endl;
ENDIFMACRO





// NB ALL OTHER PARAMETERS ARE NOW WRITTEN IN THIS FILE :
	include "Param_Adaptmesh.idp";


// Declaration of possible data types 

IFMACRO(!MESHPERIODICITY)
macro MESHPERIODICITY() [[41,y],[42,y]] //EOM
ENDIFMACRO
    fespace p2(th,P2,periodic=MESHPERIODICITY);  
    fespace p2xp2(th,[P2,P2],periodic=MESHPERIODICITY);   
    fespace p1(th,P1,periodic=MESHPERIODICITY);
    fespace p1xp1(th,[P1,P1],periodic=MESHPERIODICITY);
    fespace p2xp1(th,[P2,P1],periodic=MESHPERIODICITY);
    fespace p0(th,P0,periodic=MESHPERIODICITY);
    fespace p2xp2xp1(th,[P2,P2,P1],periodic=MESHPERIODICITY);
    fespace p2xp2xp1xp1(th,[P2,P2,P1,P1],periodic=MESHPERIODICITY);
    fespace p1bxp1bxp1(th,[P1b,P1b,P1],periodic=MESHPERIODICITY);
    fespace p2xp2xp2(th,[P2,P2,P2],periodic=MESHPERIODICITY);
    fespace p2xp2xp2xp1(th,[P2,P2,P2,P1],periodic=MESHPERIODICITY);
    fespace p2xp2xp1xp1xp1(th,[P2,P2,P1,P1,P1],periodic=MESHPERIODICITY);
    fespace p2xp2xp2xp1xp1xp1(th,[P2,P2,P2,P1,P1,P1],periodic=MESHPERIODICITY);
    fespace p1bxp1bxp1bxp1xp1xp1(th,[P1b,P1b,P1b,P1,P1,P1],periodic=MESHPERIODICITY);  
    fespace p1bxp1bxp1bxp1xp1(th,[P1b,P1b,P1b,P1,P1],periodic=MESHPERIODICITY);  



// All flowfields will be converted to the most general format p2xp2xp2xp1xp1xp1<complex> for reprojection after adaptation
    p2xp2xp2xp1xp1xp1<complex>[int] [FTAx,FTAy,FTAz,FTAp,FTAr,FTAT](nfieldsmax);

    p2xp2xp2[int] [ADFTAx,ADFTAy,ADFTAz](2*nfieldsmax); 
    // this one is for the fields which will be used in adaptation (we usually only use the 2 or 3 components of the velocity because there is a limitation to max 4 components)
    
//    p2xp2xp2xp1xp1xp1<complex> [FTAIx,FTAIy,FTAIz,FTAIp,FTAIr,FTAIT];

   

	
/// LECTURE OF FIELDS TO ADAPT
int nfieldsR = 0;
for(int i=0;i<nfields;i++) 
{
    cout << "$$ Lecture of flowfield number " << i+1<< " with structure " <<   datastoragemode[i] << " + " << scalarnumber(i) << endl;
    ifstream file(ffdatadir+"FlowFieldToAdapt"+(i+1)+".txt");
    
    if(datastoragemode[i]=="ReP2P2P1")
	   {
          p2xp2xp1 [uBx,uBy,uBp]; 
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
           cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),(0+0i),uBp*(1+0i),(0+0i),(0+0i)];
          //          ADFTAx[nfieldsR][] = [uBx,uBy,0];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,0];
          nfieldsR++;
		}
    else if(datastoragemode[i]=="CxP2P2P1")
	   {
          p2xp2xp1<complex> [uBx,uBy,uBp]; 
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,(0+0i),uBp,(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),0];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),0];nfieldsR++;
		}
     else if(datastoragemode[i]=="ReP2P2P1P1")
	   {
          p2xp2xp1xp1 [uBx,uBy,uBp,uBt]; 
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
           cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),(0+0i),uBp*(1+0i),uBt*(1+0i),(0+0i)];
          //          ADFTAx[nfieldsR][] = [uBx,uBy,0];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,0];
          nfieldsR++;
		}
    else if(datastoragemode[i]=="CxP2P2P1P1")
	   {
          p2xp2xp1xp1<complex> [uBx,uBy,uBp,uBt]; 
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,(0+0i),uBp,uBp,(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),0];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),0];nfieldsR++;
		}
        else if(datastoragemode[i]=="ReP1bP1bP1")
	   {
          p1bxp1bxp1 [uBx,uBy,uBp]; 
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
           cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),(0+0i),uBp*(1+0i),(0+0i),(0+0i)];
          //          ADFTAx[nfieldsR][] = [uBx,uBy,0];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,0];
          nfieldsR++;
		}
    else if(datastoragemode[i]=="CxP1bP1bP1")
	   {
          p1bxp1bxp1<complex> [uBx,uBy,uBp]; 
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,(0+0i),uBp,(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),0];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),0];nfieldsR++;
		}
    else if(datastoragemode[i]=="ReP2P2P2P1")
		{
          p2xp2xp2xp1 [uBx,uBy,uBz,uBp]; 
          file >> uBx[]; 
         for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
         cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),uBz*(1+0i),uBp*(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,uBz];
          nfieldsR++;
		}
	else if(datastoragemode[i]=="CxP2P2P2P1")
	   {
          p2xp2xp2xp1<complex> [uBx,uBy,uBz,uBp]; 
          file >> uBx[]; 
           cout << "her" << endl;
          for(int j = 0;j<scalarnumber(i);j++){file >> scalarscomplex(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,uBz,uBp,(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),real(uBz)];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),imag(uBz)];nfieldsR++;
		}
  else if(datastoragemode[i]=="CxP2P2P1P1P1")
    {
          p2xp2xp1xp1xp1<complex> [uBx,uBy,uBp,uBrho,uBT]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl; 
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,uBp,uBp,uBrho,uBT];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),real(uBrho)];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),imag(uBrho)];nfieldsR++;
    }
    else if(datastoragemode[i]=="ReP2P2P1P1P1")
		{
          p2xp2xp1xp1xp1 [uBx,uBy,uBp,uBrho,uBT]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),(0+0i),uBp*(1+0i),uBrho*(1+0i),uBT*(1+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,uBrho];
          nfieldsR++;
		}
    else if(datastoragemode[i]=="CxP2P2P2P1P1P1")
    {
          p2xp2xp2xp1xp1xp1<complex> [uBx,uBy,uBz,uBp,uBrho,uBT]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl; 
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,uBz,uBp,uBrho,uBT];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),real(uBrho)];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),imag(uBrho)];nfieldsR++;
    }
    else if(datastoragemode[i]=="ReP2P2P2P1P1P1")
    {
          p2xp2xp2xp1xp1xp1 [uBx,uBy,uBz,uBp,uBrho,uBT]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl; 
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),uBz*(1+0i),uBp*(1+0i),uBrho*(1+0i),uBT*(1+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,uBz];
          nfieldsR++;
    }


     else if(datastoragemode[i]=="ReP1bP1bP1bP1P1P1")
		{
          p1bxp1bxp1bxp1xp1xp1 [uBx,uBy,uBz,uBp,uBrho,uBT]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};   
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	       
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),uBz*(1+0i),uBp*(1+0i),uBrho*(1+0i),uBT*(1+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,0];
          nfieldsR++;
		} 
	  else if(datastoragemode[i]=="CxP1bP1bP1bP1P1P1")
		{
          p1bxp1bxp1bxp1xp1xp1<complex> [uBx,uBy,uBz,uBp,uBrho,uBT]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};   
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	       
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,uBz,uBp,uBrho,uBT];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),real(uBz)];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),imag(uBz)];nfieldsR++;
		} 
		     else if(datastoragemode[i]=="ReP1bP1bP1bP1P1")
		{
          p1bxp1bxp1bxp1xp1 [uBx,uBy,uBz,uBp,uBrho]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};   
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	       
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),uBy*(1+0i),uBz*(1+0i),uBp*(1+0i),uBrho*(1+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,uBy,0];
          nfieldsR++;
		} 
	  else if(datastoragemode[i]=="CxP1bP1bP1bP1P1")
		{
          p1bxp1bxp1bxp1xp1<complex> [uBx,uBy,uBz,uBp,uBrho]; 
          file >> uBx[];   
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};   
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	       
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,uBz,uBp,uBrho,(0.+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),real(uBz)];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),imag(uBz)];nfieldsR++;
		} 
	 else if(datastoragemode[i]=="ReP2")
	   {
          p2 uBx;
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),(0+0i),(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,0,0];
          nfieldsR++;
		}
 else if(datastoragemode[i]=="CxP2")
	   {
          p2<complex> uBx;
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,(0+0i),(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),0,0];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),0,0];nfieldsR++;
		}
 else if(datastoragemode[i]=="CxP2P2")
	   {
          p2xp2<complex> [uBx,uBy];
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),0];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),0];nfieldsR++;
		}

else if(datastoragemode[i]=="ReP2P2")
	   {
          p2xp2<complex> [uBx,uBy];
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),0];nfieldsR++;
		}

else if(datastoragemode[i]=="ReP2P1")
	   {
          p2xp1<complex> [uBx,uBy];
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),0];nfieldsR++;
		}		

		
		 else if(datastoragemode[i]=="CxP1P1")
	   {
          p1xp1<complex> [uBx,uBy];
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl;	
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,uBy,(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),real(uBy),0];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),imag(uBy),0];nfieldsR++;
		}

	else if(datastoragemode[i]=="ReP1")
     {
          p1 uBx;
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl; 
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx*(1+0i),(0+0i),(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [uBx,0,0];
          nfieldsR++;
    }
 else if(datastoragemode[i]=="CxP1")
     {
          p1<complex> uBx;
          file >> uBx[]; 
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : " << uBx[].n << " + " << scalarnumber(i) << endl << endl; 
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [uBx,(0+0i),(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [real(uBx),0,0];nfieldsR++;
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [imag(uBx),0,0];nfieldsR++;
    }
 else if(datastoragemode[i]=="Re")
     {
          for(int j = 0;j<scalarnumber(i);j++){file >> scalars(i,j);};
          cout << "$$    Dimension of read file : No data + " << scalarnumber(i) << endl << endl; 
          [FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]] = [(0+0i),(0+0i),(0+0i),(1+0i),(0+0i),(0+0i)];
          [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] = [0,0,0];
          nfieldsR++;
    }
// else if ... 
/// add your needed case here !

    else
       {
        cout << "$$ ERROR in AdaptMesh : wrong type of storage mode : " << datastoragemode[i] << endl;   
        exit(210);
       };
       
       
    cout << "$$	Auxiliary SCALARS associated to this field : " << endl << "$$    " ;
    for(int j =0;j<scalarnumber(i);j++){ cout << scalars(i,j) << " " ;};
    cout << endl;

if(!isofield)
	{
	cout << " Not isofield ! => Renormalizing fields to adapt" << endl;
	p1 thefield; 
	thefield  = ADFTAx[nfieldsR];real scalex = thefield[].max-thefield[].min;scalex=max(scalex,1e-6);
	thefield  = ADFTAx[nfieldsR];real scaley = thefield[].max-thefield[].min;scaley=max(scalex,1e-6);
	thefield  = ADFTAx[nfieldsR];real scalez = thefield[].max-thefield[].min;scalez=max(scalex,1e-6);
	[ADFTAx[nfieldsR-1],ADFTAy[nfieldsR-1],ADFTAz[nfieldsR-1]] = 
	[1/scalex*ADFTAx[nfieldsR-1],1/scaley*ADFTAy[nfieldsR-1],1/scalez*ADFTAz[nfieldsR-1]];
};


	  
//	 [ADFTAx[nfieldsR],ADFTAy[nfieldsR],ADFTAz[nfieldsR]] =  [CUSTOMADAPT(x,y)*ADFTAx[nfieldsR],CUSTOMADAPT(x,y)*ADFTAy[nfieldsR],CUSTOMADAPT(x,y)*ADFTAz[nfieldsR]]; 
};



// Custom choices for AdaptMesh
// IF YOU WANT TO DO SOMETHING SPECIFIC FOR ADAPTATION IN YOUR CASE, DEFINE A MACRO CUSTOMADAPT  in your StabFem.idp file, it will be plugged here.      
IFMACRO(CUSTOMADAPT)
CUSTOMADAPT;
ENDIFMACRO


    cout << endl << "$$#### Mesh information BEFORE ADAPT :" << endl;  
    cout << "$$#### Number of vertices    " << th.nv <<  endl;	
    real MeshArea = int2d(th)(1);
    cout << endl << "$$#### Area :    " << MeshArea <<  endl;	
    // default values for Hmin and Hmaz;
    if(Hmax<0)
    { 
    Hmax = sqrt(MeshArea)/30;
    cout << "Hmax automatically set to" << Hmax << endl;
    }
    else
    { 
    cout << "Hmax set to " << Hmax << " according to specified parameters" << endl;
    };
    if(Hmin<0)
    { 
    Hmin = sqrt(MeshArea)/1e5;
    cout << "Hmin automatically set to " << Hmin << endl;
    }
    else
    { 
    cout << "Hmin set to " << Hmin << " according to specified parameters" << endl;
    };
    
///
/// declaration of new mesh(es)
///       

mesh thnew;	
//mesh thbis;
fespace p2xp2xp2xp1xp1xp1N(thnew,[P2,P2,P2,P1,P1,P1]);
//fespace p2xp2xp2xp1xp1xp1B(thnew,[P2,P2,P2,P1,P1,P1]);
p2xp2xp2xp1xp1xp1N<complex> [FTANx,FTANy,FTANz,FTANp,FTANr,FTANT];  
//p2xp2xp2xp1xp1xp1B<complex> [FTABx,FTABy,FTABz,FTABp,FTABr,FTABT];  

///
/// ADAPTING MESH
///       

cout << nsplit << endl;

if(nsplit !=0) 
{
	thnew = splitmesh(th,nsplit);
    cout << " #### SPLITTING MESH IN " << nsplit << " #########" << endl;
    typeth = "split";
}
else
{
typeth = "adapted";
if(nfieldsR==1)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==2)
{
cout << ADFTAx[0][].min << " " << ADFTAx[1][].max << endl;
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==3)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==4)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==5)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==6)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==7)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
					 [ADFTAx[6],ADFTAy[6],ADFTAz[6]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==8)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
					 [ADFTAx[6],ADFTAy[6],ADFTAz[6]],[ADFTAx[7],ADFTAy[7],ADFTAz[7]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==9)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
					 [ADFTAx[6],ADFTAy[6],ADFTAz[6]],[ADFTAx[7],ADFTAy[7],ADFTAz[7]],[ADFTAx[8],ADFTAy[8],ADFTAz[8]],
					 [ADFTAx[9],ADFTAy[9],ADFTAz[9]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==10)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
					 [ADFTAx[6],ADFTAy[6],ADFTAz[6]],[ADFTAx[7],ADFTAy[7],ADFTAz[7]],[ADFTAx[8],ADFTAy[8],ADFTAz[8]],
					 [ADFTAx[9],ADFTAy[9],ADFTAz[9]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==11)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
					 [ADFTAx[6],ADFTAy[6],ADFTAz[6]],[ADFTAx[7],ADFTAy[7],ADFTAz[7]],[ADFTAx[8],ADFTAy[8],ADFTAz[8]],
					 [ADFTAx[9],ADFTAy[9],ADFTAz[9]],[ADFTAx[10],ADFTAy[10],ADFTAz[10]],						
                                nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==12)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
					 [ADFTAx[6],ADFTAy[6],ADFTAz[6]],[ADFTAx[7],ADFTAy[7],ADFTAz[7]],[ADFTAx[8],ADFTAy[8],ADFTAz[8]],
					 [ADFTAx[9],ADFTAy[9],ADFTAz[9]],[ADFTAx[10],ADFTAy[10],ADFTAz[10]],[ADFTAx[11],ADFTAy[11],ADFTAz[11]],
					 						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else if(nfieldsR==13)
{
thnew = adaptmesh(th,[ADFTAx[0],ADFTAy[0],ADFTAz[0]],[ADFTAx[1],ADFTAy[1],ADFTAz[1]],[ADFTAx[2],ADFTAy[2],ADFTAz[2]],
					 [ADFTAx[3],ADFTAy[3],ADFTAz[3]],[ADFTAx[4],ADFTAy[4],ADFTAz[4]],[ADFTAx[5],ADFTAy[5],ADFTAz[5]],
					 [ADFTAx[6],ADFTAy[6],ADFTAz[6]],[ADFTAx[7],ADFTAy[7],ADFTAz[7]],[ADFTAx[8],ADFTAy[8],ADFTAz[8]],
					 [ADFTAx[9],ADFTAy[9],ADFTAz[9]],[ADFTAx[10],ADFTAy[10],ADFTAz[10]],[ADFTAx[11],ADFTAy[11],ADFTAz[11]],
					 [ADFTAx[12],ADFTAy[12],ADFTAz[12]],
						nbvx=Nbvx,err=error,ratio=Ratio,hmax=Hmax,hmin=Hmin,thetamax=Thetamax,nbjacoby=nbjacoby,anisomax=anisomax,
						verbosity=Verbosity,splitpbedge=Splitpbedge,splitin2=Splitin2,keepbackvertices=Keepbackvertices,periodic=MESHPERIODICITY);	
}
else
{
        cout << nfieldsR << endl;
        SFerror("$$ ERROR in AdaptMesh : number of fields too large ! (currently limited to 13 real or 6 complex)");   
        exit(210);
};
};


    cout << endl << "$$#### Mesh information AFTER ADAPT :" << endl;  
    cout << "$$#### Number of vertices    " << thnew.nv <<  endl;	
		
	plot(thold,wait=1);
	plot(thnew,wait=1);


IFMACRO(FREESURFACE,YES)
	if(typesurfacemesh=="plain") 
	{
	thsurface = thnew; 	/* Maillage 'surface'*/
	};
	if(typesurfacemesh=="empty") 
	{
	thsurface = emptymesh(thnew); 	/* Maillage 'surface'*/
	};
	cout << "surface numbering... " << endl;
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); 
	
ENDIFMACRO

IFMACRO(FREESURFACE,ALE)
	th = thnew;
	cout << "surface numbering... " << endl;
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); 
ENDIFMACRO
IFMACRO(FREESURFACE,ALESTRAIN)
	th = thnew;
	cout << "surface numbering... " << endl;
	SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); 
ENDIFMACRO




	savemesh(thnew,ffdatadir+"mesh_adapt.msh");
	
    macro Th2 Th // VERY UGLY FIX BECAUSE IN A FEW CASES THE MESH IS CALLED Th2 IN CUSTOM-DEFINED SFWriteMesh
	IFMACRO(SFWriteMesh)
	SFWriteMesh(ffdatadir+"mesh_adapt.ff2m",thnew,typeth);
	ENDIFMACRO
	
	IFMACRO(SFWriteConnectivity)
	SFWriteConnectivity(ffdatadir+"mesh_adapt_connectivity.ff2m",thnew);
	ENDIFMACRO
	
	IFMACRO(COORDINATEMAPPING,YES)
//	SFWriteMapping(ffdatadir+"Mapping.ff2m",thnew); // to be removed
//	SFWriteMapping(ffdatadir+"mesh_adapt_mapping.ff2m",thnew);
	ENDIFMACRO
	
	IFMACRO(FREESURFACE,YES)
	{	
		cout << "%% Nsurface after adaptation :" << Nsurface << endl;	
		SFWriteMeshSurface(ffdatadir+"mesh_adapt_surface.ff2m",thnew);
//	    real gamma; real GAMMABAR; real dpdz;
//		ifstream file(ffdatadir+"FreeSurface.txt");
//	    file >> gamma >> dpdz >> GAMMABAR;
//		real PP0;
//		SFWriteSurface(ffdatadir+"FreeSurface_adapt.ff2m",thnew);				
//		ofstream file2(ffdatadir+"FreeSurface_adapt.txt");
//	    file2 << gamma << endl << dpdz << endl << GAMMABAR << endl;
	};
	ENDIFMACRO

IFMACRO(FREESURFACE,ALE)
	{				
	cout << "%% Nsurface after adaptation :" << Nsurface << endl;	
	SFWriteMeshSurface(ffdatadir+"mesh_adapt_surface.ff2m",thnew);				
	};
ENDIFMACRO

IFMACRO(FREESURFACE,ALESTRAIN)
	{				
		cout << "%% Nsurface after adaptation :" << Nsurface << endl;	
		SFWriteMeshSurface(ffdatadir+"mesh_adapt_surface.ff2m",thnew);				
	};
ENDIFMACRO

IFMACRO(LINEICMESH,1)
  include "Macros_Lineic.idp"
  int[int] lab = [7];
  meshL thlin = extract(thnew,refedge = lab);
  fespace Vhlin(thlin,P1);
  Vhlin xsurf,ysurf,S0,N0x,N0y,K0a,K0b,alphasurf;
  CalcGeomLin(thlin,xsurf,ysurf,S0,alphasurf,N0x,N0y,K0a,K0b,th,7)
  SFWriteMeshLin(ffdatadir+"mesh_adapt_line.ff2m",Thlin,xsurf,ysurf,S0,N0x,N0y,K0a,K0b)
ENDIFMACRO


///	
/// INTERPOLATE FLOW FIELDS AND SAVE TO FILE
///

	

    fespace p2N(thnew,P2,periodic=MESHPERIODICITY); 
    fespace p2xp2N(thnew,[P2,P2],periodic=MESHPERIODICITY);   
    fespace p1N(thnew,P1,periodic=MESHPERIODICITY);
    fespace p1xp1N(thnew,[P1,P1],periodic=MESHPERIODICITY);
    fespace p2xp1N(thnew,[P2,P1],periodic=MESHPERIODICITY);   
    fespace p0N(thnew,P0,periodic=MESHPERIODICITY);
 	fespace p2xp2xp1N(thnew,[P2,P2,P1],periodic=MESHPERIODICITY);
    fespace p2xp2xp1xp1N(thnew,[P2,P2,P1,P1],periodic=MESHPERIODICITY);
    fespace p1bxp1bxp1N(thnew,[P1b,P1b,P1],periodic=MESHPERIODICITY);
 	fespace p2xp2xp2xp1N(thnew,[P2,P2,P2,P1],periodic=MESHPERIODICITY);
    fespace p2xp2xp1xp1xp1N(thnew,[P2,P2,P1,P1,P1],periodic=MESHPERIODICITY); 
    fespace p2xp2xp2xp1xp1xp1New(thnew,[P2,P2,P2,P1,P1,P1],periodic=MESHPERIODICITY); 
    fespace p1bxp1bxp1bxp1xp1xp1N(thnew,[P1b,P1b,P1b,P1,P1,P1],periodic=MESHPERIODICITY); 
    fespace p1bxp1bxp1bxp1xp1N(thnew,[P1b,P1b,P1b,P1,P1],periodic=MESHPERIODICITY);  

for(int i=0;i<nfields;i++) 
    {
    cout << "$$ Interpolating and writing flowfield number " << i+1<< " with structure " <<   datastoragemode[i] << "." << scalarnumber(i) << endl;
    ofstream U(ffdatadir+"FlowFieldAdapted"+(i+1)+".txt");

	
	
    if(datastoragemode[i]=="ReP2P2P1")
	   {
	   	  p2xp2xp1N [uBNx,uBNy,UBNp]=[real(FTAx[i]),real(FTAy[i]),real(FTAp[i])];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
	else if(datastoragemode[i]=="CxP2P2P1")
	   {
	   	  p2xp2xp1N<complex> [uBNx,uBNy,UBNp]=[FTAx[i],FTAy[i],FTAp[i]];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
     else if(datastoragemode[i]=="ReP2P2P1P1")
	   {
	   	  p2xp2xp1xp1N [uBNx,uBNy,UBNp,UBNt]=[real(FTAx[i]),real(FTAy[i]),real(FTAp[i]),real(FTAr[i])];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
	else if(datastoragemode[i]=="CxP2P2P1P1")
	   {
	   	  p2xp2xp1xp1N<complex> [uBNx,uBNy,UBNp,UBNt]=[FTAx[i],FTAy[i],FTAp[i],FTAr[i]];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
     else if(datastoragemode[i]=="ReP1bP1bP1")
	   {
	   	  p1bxp1bxp1N [uBNx,uBNy,UBNp]=[real(FTAx[i]),real(FTAy[i]),real(FTAp[i])];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
	else if(datastoragemode[i]=="CxP1bP1bP1")
	   {
	   	  p1bxp1bxp1N<complex> [uBNx,uBNy,UBNp]=[FTAx[i],FTAy[i],FTAp[i]];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
    else if(datastoragemode[i]=="ReP2P2P2P1")
        {
          p2xp2xp2xp1N [uBNx,uBNy,UBNz,UBNp]=[real(FTAx[i]),real(FTAy[i]),real(FTAz[i]),real(FTAp[i])]; 
          U << uBNx[]; 
          U << endl;
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        }
    else if(datastoragemode[i]=="CxP2P2P2P1")
	   {
	   	  p2xp2xp2xp1N<complex> [uBNx,uBNy,uBNz,UBNp]=[FTAx[i],FTAy[i],FTAz[i],FTAp[i]];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
    else if(datastoragemode[i]=="CxP2P2P1P1P1")
        {
          p2xp2xp1xp1xp1N<complex> [uBNx,uBNy,uBNp,uBNrho,uBNT]=[FTAx[i],FTAy[i],FTAp[i],FTAr[i],FTAT[i]];
          U << uBNx[]; 
          U << endl;
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        }
    else if(datastoragemode[i]=="ReP2P2P1P1P1")
        {
          p2xp2xp1xp1xp1N [uBNx,uBNy,uBNp,uBNrho,uBNT]=[real(FTAx[i]),real(FTAy[i]),real(FTAp[i]),real(FTAr[i]),real(FTAT[i])];
          U << uBNx[]; 
           U << endl;
           for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
           cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        }
    else if(datastoragemode[i]=="CxP2P2P2P1P1P1")
        {
          p2xp2xp2xp1xp1xp1New<complex> [uBNx,uBNy,uBNz,uBNp,uBNrho,uBNT]=[FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]];
          U << uBNx[]; 
          U << endl;
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        }
    else if(datastoragemode[i]=="ReP2P2P2P1P1P1")
        {
          p2xp2xp2xp1xp1xp1New[uBNx,uBNy,uBNz,uBNp,uBNrho,uBNT]=[real(FTAx[i]),real(FTAy[i]),real(FTAz[i]),real(FTAp[i]),real(FTAr[i]),real(FTAT[i])];
          U << uBNx[];
          U << endl; 
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        }
     
      else if(datastoragemode[i]=="ReP1bP1bP1bP1P1P1")
        {
          p1bxp1bxp1bxp1xp1xp1N [uBNx,uBNy,uBNz,uBNp,uBNrho,uBNT]=[real(FTAx[i]),real(FTAy[i]),real(FTAz[i]),real(FTAp[i]),real(FTAr[i]),real(FTAT[i])];
          U << uBNx[];
           U << endl; 
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        } 
      else if(datastoragemode[i]=="CxP1bP1bP1bP1P1P1")
        {
          p1bxp1bxp1bxp1xp1xp1N<complex> [uBNx,uBNy,uBNz,uBNp,uBNrho,uBNT]=[FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i],FTAT[i]];
          U << uBNx[];
           U << endl; 
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        } 
         else if(datastoragemode[i]=="ReP1bP1bP1bP1P1")
        {
          p1bxp1bxp1bxp1xp1N [uBNx,uBNy,uBNz,uBNp,uBNrho]=[real(FTAx[i]),real(FTAy[i]),real(FTAz[i]),real(FTAp[i]),real(FTAr[i])];
          U << uBNx[];
           U << endl; 
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        } 
      else if(datastoragemode[i]=="CxP1bP1bP1bP1P1")
        {
          p1bxp1bxp1bxp1xp1N<complex> [uBNx,uBNy,uBNz,uBNp,uBNrho]=[FTAx[i],FTAy[i],FTAz[i],FTAp[i],FTAr[i]];
          U << uBNx[];
           U << endl; 
          for(int j =0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
        }     	
	else if(datastoragemode[i]=="ReP2")
	   {
	   	  p2N uBNx=real(FTAx[i]);        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
	else if(datastoragemode[i]=="CxP2")
	   {
	   	  p2N<complex> uBNx=FTAx[i];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
	else if(datastoragemode[i]=="CxP1")
	   {
	   	  p1N<complex> uBNx=FTAx[i];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}	
	else if(datastoragemode[i]=="ReP1")
	   {
	   	  p1N uBNx=real(FTAx[i]);        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}		
	else if(datastoragemode[i]=="CxP2P2")
	   {
	   	  p2xp2N<complex> [uBNx,uNBy]=[FTAx[i],FTAy[i]];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
	
	else if(datastoragemode[i]=="ReP2P2")
	   {
	  p2xp2N [uBNx,uNBy]=[real(FTAx[i]),real(FTAy[i])];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
	    }
	    
	 else if(datastoragemode[i]=="ReP2P1")
	   {
	  p2xp1N [uBNx,uNBy]=[real(FTAx[i]),real(FTAy[i])];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
	    }   

		else if(datastoragemode[i]=="CxP1P1")
	   {
	   	  p1xp1N<complex> [uBNx,uNBy]=[FTAx[i],FTAy[i]];        
          U << uBNx[];
          U << endl; 
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : " << uBNx[].n << " + " << scalarnumber(i) << endl << endl;
		}
		else if(datastoragemode[i]=="Re")
	   {
          for(int j=0;j<scalarnumber(i);j++) {U << scalars(i,j) << endl;};
          cout << "$$    Dimension of written file : 0 + " << scalarnumber(i) << endl << endl;
		}	    
		    else
       {
        cout << "$$ ERROR in AdaptMesh : wrong type of storage mode at output : " << datastoragemode[i] << endl;   
        exit(-1);
       };
   }

cout << "$$ FreeFem : Successfully Leaving function   AdaptMesh.edp   "  <<  endl;

   




