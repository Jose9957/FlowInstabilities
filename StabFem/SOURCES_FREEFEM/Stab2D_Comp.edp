//
//  PROGRAM Stab_2D_Comp.edp
//	
//	Performs the linear stability analysis of a 2D compressible subsonic flow
//   
//
//  INPUT PARAMETERS (from keyboard or pipe) :
//   	Re, Ma, shift(Re,im) , Symmetry, Type, nev 
//
//   this solver will use Arnoldi
//
//	INPUT FILES :
//		BaseFlow.txt	-> base flow 
// 		mesh.msh 			->  mesh in Freefem format
//  OUTPUT FILES :
//
//  	Eigenmode##.txt   (txt format for FreeFem)
//      Eigenmode##.ff2m  (ff2m format for stabfem)
//
// in all modes :
//		Spectrum.txt -> All computed Eigenvalues
//
// 	ERROR MANAGEMENT : 
//      if Arnoldi method fails, TODO: Not handled yet
//
// Updated in October 2019. J.S; then december , D.F.

include "StabFem.idp";

include "Param_Mapping.edp";




//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 1 : parameters		
//

/////////////////////////////////////////////////////////////
// Physical parameters
real gamma=getARGV("-gamma",1.4); 
real Pr=getARGV("-Pr",0.7);
func Pk = [P2,P2,P1,P1,P1];  // finite element space for PETSc
real Re,Reans,Ma,Maans,Omegax,Omegaxans;
real nu;
string symmetry;
string iadjoint;
real shiftr, shifti;
complex shiftOP;
int nev;
string modeEig;
string namefile, namefileMeth;

// INPUT  
cout << " Enter Reynolds :   " << endl; cin  >> Re;	nu=1.0/Re;
cout << " Enter Mach :   " << endl; cin  >> Ma;
cout << " Enter SHIFT (re,im) :   " << endl; cin  >> shiftr >> shifti;
cout << " Symmetry properties ?? (A, S  or N)" << endl; cin >> symmetry;
cout << " Direct (D), Adjoint (A), D&A+sensitivity (S) ?" << endl; cin >> iadjoint;
cout << " Enter nev ? (will use simple shift-invert if nev = 1)" << endl; cin >> nev;

complex shift = 1i*shifti+shiftr;

// OUTPUT
cout << " ### PARAMETERS SELECTED : " << endl;
cout << " Re = " << Re << endl;
cout << " Ma = " << Ma << endl;
cout << " Shift = " << shift << endl; 
cout << " Symmetry = " << symmetry << endl; 
cout << " Method = " << iadjoint << endl; 
cout << " gamma = " << gamma << endl;
cout << " Pr = " << Pr << endl;

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//  

/////////////////////MESH//////////////////////////////////////////
mesh th;

th=readmesh(ffdatadir+"mesh.msh"); // global mesh read on rank 0
///////////////////////////////////////////////////////////////////

/////////////////////FE-SPACE//////////////////////////////////////////
fespace XXxxxH(th,[P2,P2,P1,P1,P1]); /// 
fespace XH(th,P2);             ////// f.e. space for vel.
fespace xh(th,P1);            ////// f.e. space for pressure

//////////////////////////// Def vector fields ///////////////////////////  
macro defU(u,p,T,rho)[u#x,u#y,p,T,rho]//EOF
macro defUU(u)[u#x,u#y,u#p,u#T,u#rho]//EOF
XXxxxH defUU(Ub);

//////////////////////////// INITIAL CONDITIONS ///////////////////////////////
int testCB;
SFcheckfile("BaseFlow.txt",testCB);
if (testCB==-1)
{
	if(mpirank==0) cout << "$$ No file BaseFlow.txt : starting from arbitrary initial condition" << endl;
	IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefied in your Macro_StabFem.idp
	macro DefaultGuessForNewton
		defUU(Ub) = [1.0,0.0,1.0,1.0,1.0]; //EOM
	ENDIFMACRO
	DefaultGuessForNewton;
} 
else
{
    ifstream fileGuess(ffdatadir + "BaseFlow.txt");
    fileGuess >> Ubx[];
    fileGuess >> Reans;
	fileGuess >> Maans;
	fileGuess >> Omegaxans;
	if(mpirank==0) cout << "$$ Re of guess field : " << Reans << endl; 
	if(mpirank==0) cout << "$$ Ma of guess field : " << Maans << endl; 
	if(mpirank==0) cout << "$$ Omegax of guess field : " << Omegaxans << endl; 
	defUU(Ub) = [Ubx,Uby,1 + gamma*Ma^2*Ubp,UbT,Ubrho];
};

//////////////////////////////////////////////////////////////



//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//
//

//////////////////////////// COMPLEX MAPPING //////////////////////////////////////////////////
IFMACRO(!dX)
macro dX(a) dX(a) //EOM
macro dY(a) dY(a) //EOM
macro JJ   1. //EOM
ENDIFMACRO
///////////////////////////////////////////////////////////////////////////////////////////////
IFMACRO(!SFEnergyMode)
	macro SFEnergyMode(u,Rho) 
	(
		sqrt(int2d(th)((abs(Rho*u#x)^2+abs(Rho*u#y)^2+abs(u#rho)^2+abs(Rho*u#T)^2)))
	) // EOM
ENDIFMACRO

IFMACRO(!SFWriteMode)
macro SFWriteMode(namefile,u,ev,shift,typeFlow,iter)
{
	ofstream file(namefile);
	fespace p1forff2m(th,P1); 
	p1forff2m xx,yy;
	xx=x;
	yy=y;
    p1forff2m<complex> ux1,uy1,pp1,vort1,rho1,T1,divergence;
	file << "### Data generated by Freefem++ ; " << endl;
	file << "Eigenmode for a 2D-compressible problem " << endl;
	file << "datatype " << typeFlow <<" datastoragemode CxP2P2P1P1P1 datadescriptors ux,uy,p,T" << endl;
	string descriptionFF="real* Re real* Ma complex* lambda complex shift int iter P1c vort P1c divergence "; 
	file << descriptionFF << endl << endl ; 
	file << Re  << endl << Ma << endl << real(ev) << " " << imag(ev) << " " << real(shift) << " " << imag(shift) << " " << iter << endl << endl;
	vort1=dy(u#x)-dx(u#y); 
	divergence=dx(u#x)+dy(u#y); 	
	for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
    for (int j=0;j<ux1[].n ; j++) file << real(divergence[][j]) << " " << imag(divergence[][j]) << endl;
	};
//EOM	
ENDIFMACRO

//////////////////////////// BOUNDARY CONDIT //////////////////////////////////////////////////

IFMACRO(!BoundaryconditionsStability)
macro BoundaryconditionsStability(du,u,symmetry)
	           on(1,du#x=0,du#y=0.0,du#T=0.0,du#rho=0.0)
	         + on(3,du#x=0,du#y=0.0,du#T=0.0,du#rho=0.0)
             + on(2,du#x=0.0,du#y=0.0)
             + int1d(th,6)(du#x*us#x*1e30*(symmetry=="A")+du#y*us#y*1e30*(symmetry=="S"))
//EOM
ENDIFMACRO
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////
macro div(u) ((dX(u#x)+dY(u#y)))//EOM
macro ugradf(u,f) ((u#x*dX(f)+u#y*dY(f)))//EOM
macro termnonlinear(u,v,w) ((w#x*(u#x*dX(v#x)+u#y*dY(v#x))+w#y*(u#x*dX(v#y)+u#y*dY(v#y))))//EOM
macro Grad(u) [[dX(u#x),dX(u#y)],[dY(u#x),dY(u#y)]]//EOM
macro Strain(u)[[dX(u#x),0.5*(dX(u#y)+dY(u#x))],[0.5*(dX(u#y)+dY(u#x)),dY(u#y)]]//EOM
macro gradgrad(u,v)(dX(u)*dX(v)+dY(u)*dY(v))//EOM
///////////////////////////////////////////////////////////////////////////////////////////////

IFMACRO(!NormalizeMode)
macro NormalizeMode(u)
	{
		real NORM = sqrt(int2d(th)(abs(u#x)^2+abs(u#y)^2));
		u#x[] = u#x[]/NORM;
	}
//EOM
ENDIFMACRO

//
//
//
//////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : Definition of problem
//
      
varf jacobian(defUU(du),defUU(us))=-intN(th)
			  (JJ*(
			  usrho*(durho*div(Ub)+Ubrho*div(du)+ugradf(Ub,durho)+ugradf(du,Ubrho)) 
			  //mass equation
			  -dup/(gamma*Ma^2)*div(us)+2.0/Re*(Strain(du):Grad(us))-2.0/(3.0*Re)*(div(du)*div(us))
			  +Ubrho*termnonlinear(du,Ub,us)+durho*termnonlinear(Ub,Ub,us)+Ubrho*termnonlinear(Ub,du,us)
			  //momentum
			  +usT*(durho*ugradf(Ub,UbT)+Ubrho*ugradf(Ub,duT)+Ubrho*ugradf(du,UbT)
			     +(gamma-1)*(div(Ub)*dup + div(du)*Ubp)
			     -gamma*(gamma-1.0)*Ma^2/Re*(2.0*((Strain(du):Strain(Ub))+(Strain(Ub):Strain(du)))
			     -2.0/3.0*(2.0*div(Ub)*div(du))))
			  +gamma/(Pr*Re)*gradgrad(duT,usT)
			  // energy
			   +usp*(dup-(durho*UbT+Ubrho*duT))
			  // shift
			  +shift*(usrho*durho+Ubrho*duy*usy+Ubrho*dux*usx+usT*Ubrho*duT)
			  ))
			  +BoundaryconditionsStability(du,us,symmetry);

varf b(defUU(du),defUU(us))=intN(th)(JJ*(usrho*durho+Ubrho*duy*usy+Ubrho*dux*usx+usT*Ubrho*duT));

//
//
//
//////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : ARNOLDI SOLVER / SLEPC
//    
	matrix<complex> OP,B;
    B= b(XXxxxH,XXxxxH);  

if(iadjoint=="D")
	{ OP=jacobian(XXxxxH,XXxxxH); shiftOP = shift; modeEig = "Eigenmode";}
else if(iadjoint=="A")
	{ OP=jacobian(XXxxxH,XXxxxH); OP = OP'; shiftOP = conj(shift); modeEig = "EigenmodeA";}
else if(iadjoint=="S"||iadjoint=="cS"||iadjoint=="E") 
	{ SFerror("$$ WARNING : type 'S'  and 'E' no longer supported ! please use SF_Sensitivity"); };

int k;
complex[int] ev(nev); // Eigenvalues
complex[int,int] EigenVEC(OP.n,nev);


SFEVSOLVE(k,nev,OP,B,shiftOP,ev,EigenVEC); // Warning : in this macro OP is A - shift B !

int Nmodes = min(k,nev); // nb. de vecteurs propres Ã  post-traiter
XXxxxH<complex> [int] [eux,euy,ep,eT,erho](Nmodes); // Eigenvectors
for (int i=0; i<Nmodes; i++)
{
	eux[i][] = EigenVEC(:,i);
};

//
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 6 : PostProcessing
//    

namefile=ffdatadir+"Spectrum.txt";
ofstream fileVP1(namefile); 
XXxxxH<complex> defU(u,up,uT,urho); // good names
for (int i=0;i<Nmodes;i++)
{
	if (iadjoint == "A")
	{
		ev[i] = conj(ev[i]); eux[i][] = conj(eux[i][]);
	}
     fileVP1 << real(ev[i]) << " " << imag(ev[i]) << endl;
     cout << " Eigenvalue : " << i+1 << "  : " << ev[i] << endl;
	 namefile=ffdatadir+"Eigenmode"+(i+1);
	 // Normalize the mode
	 ux[] = eux[i][];
	 NormalizeMode(u);
	 cout << "Normalizing eigenmode " << i << endl;
	 cout << "Writing eigenmode in file " << namefile << endl;
	 ofstream fileMode(namefile+".txt");
		 fileMode.precision(16);
   		 fileMode.scientific;
		 fileMode << eux[i][]; 
		 fileMode << endl << endl << Re << endl << Ma << endl << endl << real(ev[i]) << "   " << imag(ev[i])  << endl;
  	  SFWriteMode(namefile+".ff2m",u,ev[i],shiftOP,modeEig,1); 	  
};
cout << "$$ --- Stability solver has finished --- $$" << endl;

//
//
//
//////////////////////////////////////////////////////////////////////////////////


