/* =======================================

	Computation of Axisymmetric base flow with 3 velocity component and possibly a porous object
	
   ======================================= 

	PROGRAM Newton_AxiSwirl.edp
	Computation of Axisymmetric base flow [ux,ur,uphi](x,y)

	THIS FILE IS ADAPTED FROM Newton_Axi.edp

	INPUT PARAMETERS (from keyboard or pipe) :
		Re, ROTATION, Darcy, POROSITY
	INPUT FILES :		
		mesh.msh 			 -> Mesh in Freefem format
		(BaseFlow_guess.txt) -> Guess base flow (generated by mesh generator, time integration or previous Newton)
							   ( if this file is absent the program will start from zero, 
							     unless a macro DefaultGuessForNewton is defined )
	OUTPUT FILES :
		BaseFlow.txt		 -> Base flow (FF format)
		BaseFlow.ff2m		 -> Base flow (FF2M format) 

	ERROR MANAGEMENT : 
		if Newton iteration diverges, error code is 201.

	History : 
	INCORPORATED INTO THE STABFEM PROJECT BY D. FABRE ON A BUSY DAY AT UNIVERSITA DI SALERNO, 18 july 2017
	REwriten on october 2 2017 with macros.
	REWRITTEN with Adrien in 2028
	Upgraded to SF 3.0 july 2019 in Sapporo
...................................................... */

 /* ---------------------
		Import Macros 
    --------------------- */


	include "StabFem.idp";

/*  ------------------
		Paramètres 
    ------------------ */
	
	real Re;
	real Reans,lecture;
	real Da;
	real Porosity;
	real Omegax;
	real Uinfx = 1;
	
	cout << " Entrer le premier parametre (Reynolds) :" << endl;
    cin >>  Re;
    cout << " Entrer le second parametre (taux de rotation ou autre) :" << endl;
    cin >>  Omegax;
Da = 1; Porosity=1;
//IFMACRO(POROUS)	
	cout << " Entrer le Nombre de Darcy du disque :" << endl;
    cin >>  Da;
	
    cout << " Entrer la porosite du disque :" << endl;
    cin >>  Porosity;
//ENDIFMACRO
		// if(Porosity==0){Porosity=1e-30;};
		

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 2 : read files		
//

		
/*  -----------------------
		READING MESH and defining fe-spaces
    ----------------------- */
	
	mesh th = readmesh(ffdatadir+"mesh.msh");
	IFMACRO(FREEFEMPLOTS,YES)
		plot(th,wait=0);
	ENDIFMACRO

/*  ------------------
		Espaces EF 
    ------------------ */

	fespace Xh(th,P2);					//f.e. space for Velocity components
	fespace Mh(th,P1);					//f.e. space for Pressure
	fespace XXMh(th,[P2,P2,P1]);		//f.e. space for Triplet [u,v,p]
	fespace XXXMh(th,[P2,P2,P2,P1]);	//f.e. space for Quadruplet [u,v,w,p]

	XXXMh [ux,ur,uphi,up]; 				// -> unknown for the Navier-Stokes problem
	XXXMh [vx,vr,vphi,vp];				// -> test function for Navier-Stokes
	XXXMh [upx,upr,upphi,upp];			// -> buffer vector to store previous iteration (Newton) 
	XXXMh [dux,dur,duphi,dup];			// -> increment for the Newton iteration
	XXMh [uaxix,uaxir,uaxip];			// -> unknown for the Navier-Stokes problem
		
		
/*  ---------------------------
		READING BASEFLOW
    --------------------------- */

	int NdimUVP = uaxix[].n;
	int NdimUVWP = ux[].n;
	
	int NdimBaseFlow;
	SFcheckfile("BaseFlow_guess.txt",NdimBaseFlow)	
	
    if (NdimBaseFlow<0)
		{
		cout << "$$ No file BaseFlow_guess.txt : strarting from arbitrary initial condition" << endl;
		IFMACRO(!DefaultGuessForNewton) // if your want something else this macro may be redefined in your Macro_StabFem.idp
		macro DefaultGuessForNewton
		[ux,ur,uphi,up] = [0,0,0,0]; //EOM
		ENDIFMACRO
		DefaultGuessForNewton;
		} 
	else if(NdimBaseFlow == NdimUVP) 
		{
        cout << "Ndim = " << NdimUVP << " : reading UVP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> uaxix[];
        [ux,ur,uphi,up] = [uaxix,uaxir,0,uaxip];
		file >> Reans;
        }
	else if(NdimBaseFlow == NdimUVWP) 
        {
        cout << "Ndim = " << NdimUVWP << " : reading UVWP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow_guess.txt");
        file >> ux[]; 
		file >> Reans;
        }
	else 
        {
        cout << " Error : Wrong dimension For BaseFlow_guess.txt file" << endl;
        };

	cout << " Newton pour Re = " << Re << endl;	
	cout << " CI : " << Reans << endl;
	real nu = 1./Re;
     // If Nu is something else than 1/Re define a macro CUSTOMnu in your  .idp file
    IFMACRO(CUSTOMnu)
    nu = CUSTOMnu;
    ENDIFMACRO

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 3 : Customizable macros 	
//

/*  -----------------------
		Customizable macros for boundary conditions and postprocessing
		(The ones defined here are default ones ; don't change them ! 
		if you want to customize paste them in your SF_Custom.idp file) 
    ----------------------- */



// A. Boundary conditions 
IFMACRO(!Uinlet)
macro Uinlet() 1. //EOM
ENDIFMACRO
IFMACRO(!Vinlet)
macro Vinlet() 0. //EOM
ENDIFMACRO
IFMACRO(!Winlet)
macro Winlet() 0. //EOM
ENDIFMACRO

IFMACRO(!BoundaryconditionsBaseFlow)
macro BoundaryconditionsBaseFlow(du,up,v)
	           on(1,du#r=Vinlet-up#r,du#x=Uinlet-up#x)
             + on(2,21,22,23,du#x=0.0,du#r=0.0)
             + on(5,du#x=0.0)+on(4,du#r=0)
             + on(6,du#r=0.0)      
			 + on(1,du#phi=Winlet-up#phi)
			 + on(2,21,22,23,du#phi=0.0) 
			 + on(6,du#phi=0.0)
//EOM
ENDIFMACRO

// B. Post-processing
IFMACRO(!CalcPsi)      
macro CalcPsi(psi,vort,test)
      solve LapLace(psi,test) = int2d(th)(1/y*(dx(psi)*dx(test)+dy(psi)*dy(test)))
					         - int2d(th)(vort*test)
					         + on(th,6,21,22,23)(psi=0)
					         + on(1,2,4)(psi=y^2/2);
//EOM
ENDIFMACRO      

IFMACRO(!SFWriteBaseFlow)
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	{
	fespace p2forff2m(th,P2);  
    p2forff2m vort,vortx,psi,testvort; 
	/*vort=-dy(u#x)+dx(u#r);*/
	/*vortx = dy(u#phi)+u#phi/(1e-20+y); */ 
	solve calcvort(vort,testvort)=int2d(th)((-dy(u#x)+dx(u#r))*y*testvort)-int2d(th)(y*vort*testvort);
	solve calcvortx(vortx,testvort)=int2d(th)((y*dy(u#phi)+u#phi)*testvort)-int2d(th)(y*vortx*testvort);
	CalcPsi(psi,vort,testvort);
	ofstream file(filename);
   	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow for an axisymmetric incompressible problem" << endl;
    file << "datatype " << typeFlow << " datastoragemode ReP2P2P2P1.1 datadescriptors ux,ur,uphi,p,Re" << endl;
    file << "real* Re real* Omegax P2 psi P2 vortphi P2 vortx real iter " ; 
	string PostProcessBaseFlowDescription = " " ; 
	file << PostProcessBaseFlowDescription << endl << endl ; 
	file << Re << endl << Omegax << endl;	
	for (int j=0;j<vort[].n ; j++) file << psi[][j] << endl;
	for (int j=0;j<vort[].n ; j++) file << vort[][j] << endl;
	for (int j=0;j<vort[].n ; j++) file << vortx[][j] << endl;
	file << iter << endl << endl;
	};
//EOM
ENDIFMACRO

// C. Differential operators
/* Macro for Divergence  */
	macro div(im,u) (dx(u#x)+dy(u#r)+u#r/y+im/y*u#phi)//EOM

/* Macro for Vecocity gradient tensor  */
	macro Grad(im,u) [
			[dx(u#x),	dy(u#x),	im/y*u#x ], 
			[dx(u#r),	dy(u#r),	im/y*u#r-u#phi/y],
			[dx(u#phi),	dy(u#phi),	im/y*u#phi+u#r/y ]
			]//EOM

/* Macro for Rate-of-deformation tensor  */
	macro D(im,u) [	
				[dx(u#x),					.5*(dx(u#r)+dy(u#x)),				.5*(im/y*u#x+dx(u#phi)) ], 
				[.5*(dx(u#r)+dy(u#x)),		dy(u#r),							.5*(im/y*u#r-u#phi/y+dy(u#phi))],
				[.5*(im/y*u#x+dx(u#phi)),	.5*(im/y*u#r-u#phi/y+dy(u#phi)),	im/y*u#phi+u#r/y]
				]//EOM

/* Macro for Mutual convection operator  */
	macro Conv(ima,ua,imb,ub,v) ( 
              (Grad(ima,ua)*[ub#x,ub#r,ub#phi] + Grad(imb,ub)*[ua#x,ua#r,ua#phi])'*[v#x,v#r,v#phi]
              			)//EOM

// D. Misc
// Macros pour désactiver les milieux poreux
IFMACRO(!S1)
macro S1(x,y) 1 //
macro S2(x,y) 1 //
macro IsInObject(x,y) 0.//
ENDIFMACRO



//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 4 : problem definition
//

/*  -----------------------------------
		Résolution de Navier-Stokes 
    ----------------------------------- */



/* Système linéarisé */
	problem NewtonIter([dux,dur,duphi,dup],[vx,vr,vphi,vp]) =
		int2d(th)(
				(	vp*div(0,du)
					- S1(x,y)*Conv(0,up,0,du,v)
					+ dup*div(0,v)
					- 2*nu*S2(x,y)*(D(0,du):D(0,v))
					-IsInObject(x,y)*nu*(1/Da)*(dux*vx+dur*vr+duphi*vphi)
				)*y)
		- int1d(th,91,92,93)((1/Porosity-1)*((D(0,du)*[N.x,N.y,0])'*[vx,vr,vphi])*y)
		+ int2d(th)(
				(	vp*div(0,up)
					- .5*S1(x,y)*Conv(0,up,0,up,v)
					+ upp*div(0,v)
					- 2*nu*S2(x,y)*(D(0,up):D(0,v))
					- IsInObject(x,y)*nu*(1/Da)*(upx*vx+upr*vr+(upphi-Omegax*y)*vphi)
				)*y)
		- int1d(th,91,92,93)((1/Porosity-1)*((D(0,u)*[N.x,N.y,0])'*[vx,vr,vphi])*y)
		+ BoundaryconditionsBaseFlow(du,up,v);

//////////////////////////////////////////////////////////////////////////////////
//
//		CHAPTER 5 : Newton loop
//  
   
    
/* Paramètres de l'algorithme de Newton  */          
	real tolerance = 2e-12;
	real ener = 10;
	int Nitermax = 30;
	int iter = 0;
	
/* Algorithme de Newton  */
	while((ener>tolerance)&(ener<50)&(iter<=Nitermax))
        {
			upx[]=ux[];				// Uold=U   
			NewtonIter ;           	// Update of current solution u1=u1-w
			ux[] = ux[]+dux[];
			real enerl2=dux[].l2;
			ener = sqrt(int2d(th)(dux^2+dur^2+duphi^2)/th.area);
			cout << " iter = "<< iter+1 << "   Re = " << Re << " res = " << ener << " ; res l2 = " << enerl2 << endl;
			plot(dux,wait=0,value=false,nbiso=50,fill=1,
			     cmm="dux - Re="+int(Re)+" - It="+int(iter+1)+" - Res="+real(ener)+".");
			iter++;
		};


/*  ----------------------------
		Sortie des résultats 
    ---------------------------- */

/* Si non convergence */
	if((ener>50)||(iter>Nitermax))
		{
		cout << "$$ NEWTON ITERATION FAILED" << endl;
		cout << "$$ Leaving FreeFem++ with error code 201" << endl;
		exit(201);
		}
/* Si convergence */
	else
		{
		ofstream file(ffdatadir+"BaseFlow.txt"); 			// file in .txt format for FreeFem solvers
		file << ux[]; 
		file << endl << endl << Re << endl << Omegax << endl;
		SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",u,"BaseFlow",iter); // file in .ff2ml format for StabFem driver
		}; 
		

		plot(ux,wait=1,value=true,nbiso=50,fill=1,cmm="final Ux - Re="+real(Re)+" - Da="+real(Da)+" - eps="+real(Porosity)+" - Omega="+real(Omegax)+".");
		plot(ur,wait=1,value=true,nbiso=50,fill=1,cmm="final Ur - Re="+real(Re)+" - Da="+real(Da)+" - eps="+real(Porosity)+" - Omega="+real(Omegax)+".");
		plot(uphi,wait=1,value=true,nbiso=50,fill=1,cmm="final Uphi - Re="+real(Re)+" - Da="+real(Da)+" - eps="+real(Porosity)+" - Omega="+real(Omegax)+".");
		plot(up,wait=1,value=true,nbiso=50,fill=1,cmm="final P - Re="+real(Re)+" - Da="+real(Da)+" - eps="+real(Porosity)+" - Omega="+real(Omegax)+".");
		//plot(upsi,wait=1,value=false,nbiso=100,fill=0,cmm="Lignes courant - Re="+real(Re)+" - Da="+real(Da)+" - eps="+real(Porosity)+" - Omega="+real(Omegax)+"."); 	
		
		
		